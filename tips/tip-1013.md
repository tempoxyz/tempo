---
id: TIP-1013
title: Recovery Guardian Keys
description: Adds a valid_after timestamp to Access Keys enabling time-delayed recovery guardian patterns.
authors: Tanishk Goyal
status: Draft
related: TIP-1011, TIP-1000, AccountKeychain, IAccountKeychain.sol
protocolVersion: TBD (requires hardfork)
---

# TIP-1013: Recovery Guardian Keys

## Abstract

This TIP extends Access Keys with a `validAfter` timestamp field, enabling time-delayed key activation. Combined with unlimited spending limits and unrestricted address scoping, this creates a **recovery guardian** pattern where a trusted third party can recover an account only after a configurable delay period—giving the original owner time to revoke the guardian if they still have access.

## Motivation

Users face a fundamental tradeoff between security and recoverability:

- **High security** (hardware wallets, multi-sig): Risk permanent loss if keys are lost
- **High recoverability** (custodial, social recovery): Trust third parties with immediate access

Current Access Key permissions (spending limits, expiry, destination scoping) don't solve this because they either:
1. Expire (useless for long-term recovery)
2. Have spending limits (can't recover full account)
3. Are immediately active (guardian could act maliciously)

### Recovery Guardian Pattern

A **recovery guardian** is a trusted party (friend, family member, institution, or hardware backup) that can take over an account, but only after a time delay:

1. **Setup**: User provisions an Access Key to their guardian with:
   - No spending limits (unlimited access)
   - No destination restrictions (can interact with any contract)
   - `validAfter = now + 30 days` (or any delay period)

2. **Normal operation**: The guardian key cannot be used—it's not yet valid

3. **Recovery scenario**: If the user loses access:
   - Wait for the delay period to elapse
   - Guardian can now use the key to recover funds or transfer ownership

4. **Attack prevention**: If the user still has access and the guardian acts maliciously:
   - User sees the guardian key approaching validity
   - User revokes the guardian key before `validAfter`
   - User can provision a new guardian with a fresh delay

This mirrors social recovery patterns in smart contract wallets but at the protocol level.

### Use Cases

1. **Personal backup**: Provision a guardian key to a hardware wallet stored in a safe
2. **Family recovery**: Give a guardian key to a trusted family member
3. **Institutional recovery**: Enterprise accounts with IT department as guardian
4. **Dead man's switch**: Automatic inheritance if the owner becomes inactive
5. **Multi-guardian setup**: Multiple guardian keys with staggered `validAfter` times

---

# Specification

## Extended Data Structures

### KeyAuthorization

**Current fields (from TIP-1011):**
```solidity
struct KeyAuthorization {
    TokenLimit[] spendingLimits;
    uint64 expiry;
    address[] allowedDestinations;
}
```

**Proposed addition:**
```solidity
struct KeyAuthorization {
    TokenLimit[] spendingLimits;
    uint64 expiry;              // Key becomes invalid after this time
    address[] allowedDestinations;
    uint64 validAfter;          // Key becomes valid after this time (0 = immediately valid)
}
```

### Validity Window

A key is valid when: `validAfter <= block.timestamp < expiry`

| `validAfter` | `expiry` | Behavior |
|--------------|----------|----------|
| 0 | 0 | Always valid (no time constraints) |
| 0 | T | Valid until T |
| T | 0 | Valid after T (no expiry) |
| T1 | T2 | Valid between T1 and T2 |

**Constraint**: `validAfter < expiry` when both are non-zero, otherwise the key would never be valid.

## Interface Changes

### IAccountKeychain.sol

```solidity
/// @notice Authorizes a key with a validity window
/// @param key The public key to authorize
/// @param expiry Block timestamp when key expires (0 = no expiry)
/// @param validAfter Block timestamp when key becomes valid (0 = immediately valid)
/// @param spendingLimits Token spending limits
/// @param allowedDestinations Addresses the key may call (empty = unrestricted)
function authorizeKey(
    bytes calldata key,
    uint64 expiry,
    uint64 validAfter,
    TokenLimit[] calldata spendingLimits,
    address[] calldata allowedDestinations
) external;

/// @notice Returns the validity window for a key
/// @param key The public key to query
/// @return validAfter Timestamp when key becomes valid (0 = immediately valid)
/// @return expiry Timestamp when key expires (0 = no expiry)
function getValidityWindow(bytes calldata key) external view returns (uint64 validAfter, uint64 expiry);

/// @notice Updates the validAfter timestamp for an existing key
/// @dev Can only increase validAfter (push activation further into the future)
/// @param key The public key to update
/// @param newValidAfter New timestamp when key becomes valid
function updateValidAfter(bytes calldata key, uint64 newValidAfter) external;
```

## Semantic Behavior

### Key Validation Logic

When a transaction is submitted with an Access Key:

```
function validateKeyTiming(key):
    auth = getKeyAuthorization(key)
    
    // Check validAfter constraint
    if auth.validAfter > 0 and block.timestamp < auth.validAfter:
        revert KeyNotYetValid(auth.validAfter)
    
    // Check expiry constraint (existing behavior)
    if auth.expiry > 0 and block.timestamp >= auth.expiry:
        revert KeyExpired(auth.expiry)
    
    return true
```

### Guardian Key Update Rules

1. **Revocation**: The account owner can always revoke a guardian key entirely
2. **Delay extension**: The owner can call `updateValidAfter` to push `validAfter` further into the future
3. **Delay reduction**: The owner CANNOT reduce `validAfter`—this would defeat the security model
4. **Re-provisioning**: To reduce the delay, the owner must revoke and create a new key

```
function updateValidAfter(key, newValidAfter):
    auth = getKeyAuthorization(key)
    
    if newValidAfter <= auth.validAfter:
        revert CannotReduceValidAfter()
    
    if auth.expiry > 0 and newValidAfter >= auth.expiry:
        revert ValidAfterExceedsExpiry()
    
    auth.validAfter = newValidAfter
```

### Interaction with Other Permissions

The `validAfter` check is evaluated **first**, before any other permission checks:

1. `validAfter` check (is the key active yet?)
2. `expiry` check (has the key expired?)
3. `allowedDestinations` check (can this key call this address?)
4. `spendingLimits` check (does this key have sufficient allowance?)

If `validAfter` has not passed, the transaction reverts immediately without consuming spending limits or evaluating other constraints.

## Recovery Guardian Configuration

A typical recovery guardian key would be configured as:

```solidity
authorizeKey(
    guardianPublicKey,
    0,                          // No expiry
    uint64(block.timestamp + 30 days),  // Active in 30 days
    [],                         // No spending limits (unlimited)
    []                          // No destination restrictions
);
```

This creates a key that:
- Cannot be used for 30 days
- Has no expiry (valid indefinitely once active)
- Has no spending limits (full account access)
- Can interact with any contract

## Encoding

### RLP Encoding

The `KeyAuthorization` struct is extended with `validAfter` as a trailing optional field:

```
KeyAuthorization := RLP([
    spendingLimits: [TokenLimit, ...],
    expiry: uint64,
    allowedDestinations: [address, ...],  // From TIP-1011
    validAfter: uint64                    // New field
])
```

Using `#[rlp(trailing)]` semantics:
- Old encodings (without `validAfter`) decode as `validAfter = 0` (immediately valid)
- New encodings include `validAfter` explicitly

## Precompile Storage

New storage slot for the `validAfter` field:

| Mapping | Type | Description |
|---------|------|-------------|
| `valid_after[key]` | `u64` | Timestamp when key becomes valid |

Legacy keys (pre-fork) have `validAfter = 0` (immediately valid).

## Gas Costs

| Operation | Gas Cost |
|-----------|----------|
| `authorizeKey` with `validAfter` | +2,000 (additional SSTORE for timestamp) |
| `updateValidAfter` | ~5,000 (single SSTORE update) |
| Validity check (per tx) | ~100 (timestamp comparison) |

---

# Backward Compatibility

This TIP requires a **hardfork** due to changes in transaction encoding and execution semantics.

## RLP Encoding Changes

`KeyAuthorization` gains a new trailing field `validAfter`. Using `#[rlp(trailing)]`:
- Pre-fork keys decode with `validAfter = 0` (immediately valid)
- Post-fork keys may include `validAfter`

## Hardfork-Gated Features

The following MUST be gated behind hardfork activation:

1. **RLP decoding**: Accept `validAfter` field in `KeyAuthorization`
2. **Validity window enforcement**: Check `validAfter` before allowing key usage
3. **New precompile storage**: Write to `valid_after[key]` slot
4. **New interface methods**: `getValidityWindow()`, `updateValidAfter()`

---

# Invariants

1. **Validity window**: A key MUST only be usable when `validAfter <= block.timestamp < expiry` (with 0 meaning unbounded)

2. **Monotonic validAfter**: `validAfter` can only be increased via `updateValidAfter()`, never decreased

3. **Window consistency**: When both `validAfter` and `expiry` are non-zero, `validAfter < expiry` MUST hold

4. **Backward compatibility**: Keys authorized without `validAfter` MUST behave as if `validAfter = 0` (immediately valid)

5. **Check ordering**: The `validAfter` check MUST be evaluated before spending limits or destination restrictions

6. **Revocation precedence**: Account owners MUST always be able to revoke guardian keys regardless of their validity window

## Test Cases

1. **Basic validity window**: Verify key with `validAfter` in future cannot be used until that time
2. **Expiry interaction**: Verify key with both `validAfter` and `expiry` works correctly within window
3. **Update validAfter**: Verify `updateValidAfter` can only increase the timestamp
4. **Revocation**: Verify owner can revoke guardian key before it becomes valid
5. **Zero values**: Verify `validAfter = 0` means immediately valid, `expiry = 0` means no expiry
6. **Invalid window**: Verify authorization fails if `validAfter >= expiry`
7. **Upgrade path**: Verify existing keys continue to work (interpreted as `validAfter = 0`)
8. **Full recovery flow**: End-to-end test of guardian provisioning, waiting, and recovery

## Security Considerations

### Attack Vectors

1. **Guardian collusion**: Mitigated by the delay period—owner has time to react
2. **Key theft**: If the owner's main key is stolen, the guardian key provides a recovery path
3. **Guardian key theft**: Attacker must also wait for `validAfter`, giving owner time to revoke
4. **Time manipulation**: `block.timestamp` manipulation is bounded by consensus rules

### Recommended Practices

1. **Multiple guardians**: Use 2-3 guardians with staggered `validAfter` times
2. **Monitoring**: Set up alerts when guardian keys approach their `validAfter` time
3. **Reasonable delays**: 7-30 days is recommended; too short reduces security, too long reduces recoverability
4. **Regular review**: Periodically verify guardian keys are still appropriate

## References

- [TIP-1011: Enhanced Access Key Permissions](./tip-1011.md)
- [AccountKeychain docs](https://docs.tempo.xyz/protocol/transactions/AccountKeychain)
- [Social Recovery Wallets](https://vitalik.eth.limo/general/2021/01/11/recovery.html) - Vitalik Buterin
