---
id: TIP-xxxx
title: Subblocks v2 - Builder Delegation and Fallback Inclusion
description: Separates subblock builder identity from validator identity, embeds fee recipient in nonce key, and enables fallback 0x5b transaction inclusion.
authors: Mallesh Pai
status: Draft
related: Subblock Specification
protocolVersion: TBD
---

# TIP-1011: Subblocks v2 - Builder Delegation and Fallback Inclusion

## Abstract

This TIP introduces three major changes to the subblock system:

1. **Subblock Registry**: Validators can delegate subblock production to a separate builder identity with its own signing key, enabling operational separation between consensus participation and subblock building.

2. **Fee Recipient in Nonce Key**: The nonce key format for subblock transactions changes from `0x5b | validator_pubkey_prefix | nonce` to `0x5b | fee_recipient | nonce`, embedding the fee recipient directly in the transaction.

3. **Fallback 0x5b Transactions**: Allows 0x5b transactions to be included outside signed subblocks when a builder is unavailable or subblocks are full, with fees routed using the embedded fee recipient.

## Motivation

The current subblock design has several limitations:

1. **Validator coupling**: The validator's consensus key must also sign subblocks, meaning validators cannot delegate subblock production to separate infrastructure without sharing their consensus key.

2. **Fee recipient lookup**: The fee recipient is determined by looking up the validator from the nonce key's partial public key, requiring a registry lookup during execution.

3. **No fallback path**: If a validator's subblock builder is offline, users have no way to get their 0x5b transactions included.

This TIP addresses these issues by:

- Allowing validators to designate a separate subblock builder with its own ed25519 signing key
- Embedding the fee recipient directly in the nonce key, eliminating lookup during execution
- Enabling fallback inclusion of 0x5b transactions outside signed subblocks

---

# Specification

## 1. Subblock Registry

A new Subblock Registry precompile stores builder configurations designated by validators.

### 1.1 Data Structures

```solidity
struct SubblockBuilder {
    bytes32 signingKey;      // ed25519 public key for signing subblocks
    address feeRecipient;    // receives fees, must be unique across all builders
    address feeToken;        // preferred TIP-20 token for subblock fee payment
}
```

**Note on fee token**: The subblock fee token is stored in `SubblockRegistry`, separate from `TipFeeManager.validatorTokens`. This allows validators to have different token preferences for:
- **Subblock fees** (when other proposers include their subblocks): `SubblockRegistry.builders[validator].feeToken`
- **Proposer fees** (when they are the block proposer): `TipFeeManager.validatorTokens[validator]`

When processing fees for a 0x5b transaction:
1. The user pays in `tx.fee_token`
2. Extract `feeRecipient` from nonce key
3. Look up `builder = SubblockRegistry.builderOf(validatorFor(feeRecipient))`
4. If registered, attempt to swap to `builder.feeToken` if AMM liquidity available
5. If no liquidity or unregistered, fees are paid directly in `tx.fee_token`

### 1.2 Storage

```solidity
// Validator → their designated builder configuration
mapping(address => SubblockBuilder) public builders;

// Fee recipient → validator who registered it (for uniqueness enforcement)
mapping(address => address) public validatorOf;
```

### 1.3 Interface

```solidity
interface ISubblockRegistry {
    /// @notice Returns the builder configuration for a validator.
    /// @param validator The validator address.
    /// @return The SubblockBuilder struct, or zero values if not set.
    function builderOf(address validator) external view returns (SubblockBuilder memory);

    /// @notice Returns the ed25519 signing key for a given fee recipient.
    /// @param feeRecipient The fee recipient address.
    /// @return The 32-byte ed25519 public key.
    /// @dev Reverts if feeRecipient is not registered.
    function signingKeyFor(address feeRecipient) external view returns (bytes32);

    /// @notice Returns the preferred fee token for a given fee recipient.
    /// @param feeRecipient The fee recipient address.
    /// @return The TIP-20 token address, or zero if not registered.
    function feeTokenFor(address feeRecipient) external view returns (address);

    /// @notice Returns the validator that registered a fee recipient.
    /// @param feeRecipient The fee recipient address.
    /// @return The validator address, or zero if not registered.
    function validatorFor(address feeRecipient) external view returns (address);

    /// @notice Registers or updates the caller's subblock builder configuration.
    /// @param builder The builder configuration to set.
    /// @dev Only callable by active validators (per ValidatorConfig).
    /// @dev Reverts if feeRecipient is already registered by another validator.
    /// @dev Clears the old feeRecipient mapping if updating.
    function setSubblockBuilder(SubblockBuilder calldata builder) external;

    /// @notice Clears the caller's subblock builder configuration.
    /// @dev Only callable by the validator who registered it.
    function clearSubblockBuilder() external;
}
```

### 1.4 Behavior

**Registration:**
- Only `validatorAddress` entries from the `ValidatorConfig` precompile with `active = true` can call `setSubblockBuilder()`
- The SubblockRegistry queries `ValidatorConfig.validators(msg.sender)` to verify the caller is an active validator
- Each `feeRecipient` MUST be unique across all validators (enforced via `validatorOf` mapping)
- When updating, the old `feeRecipient` mapping is cleared before setting the new one
- Changes take effect immediately in the next block

**Self-delegation:**
- A validator MAY set themselves as the builder (use their own address as `feeRecipient`)
- In this case, the validator signs subblocks with the designated `signingKey`, which MAY differ from their consensus key

**Unregistered fee recipients:**
- If a 0x5b transaction has a `feeRecipient` not registered in `SubblockRegistry`, `validatorFor()` returns zero
- No validator token preference applies—fees are paid directly in `tx.fee_token`
- This enables fallback 0x5b transactions to pay fees even if the fee recipient is not registered

**Validator status changes:**
- If a validator becomes inactive in `ValidatorConfig`, their SubblockRegistry entry remains but:
  - Their signed subblocks are rejected during block validation
  - They cannot update their builder configuration until reactivated
- Inactive validators' `feeRecipient` mappings remain reserved to prevent address reuse conflicts

### 1.5 Precompile Address

```
SUBBLOCK_REGISTRY_ADDRESS = 0x0b10c0000000000000000000000000000000000X  // TBD
```

### 1.6 Relationship to ValidatorConfig

The SubblockRegistry is a **separate precompile** from ValidatorConfig but **depends on it** for validator set membership:

```
┌─────────────────────┐         ┌─────────────────────┐
│   ValidatorConfig   │◄────────│   SubblockRegistry  │
│                     │  reads  │                     │
│ - validatorAddress  │         │ - signingKey        │
│ - publicKey (ed25519)│        │ - feeRecipient      │
│ - active            │         │ - feeToken          │
│ - index             │         │                     │
└─────────────────────┘         └─────────────────────┘
     Source of truth              Builder delegation
     for validator set            configuration
```

- `ValidatorConfig.publicKey`: Used for **consensus signing** (block proposals, attestations)
- `SubblockRegistry.signingKey`: Used for **subblock signing** (separate operational key)

---

## 2. Nonce Key Format

### 2.1 New Format

Subblock transactions use the following nonce key format:

```
32 bytes total:
┌──────────────────┬───────────────────────────┬─────────────────────┐
│ 0x5b (1 byte)    │ fee_recipient (20 bytes)  │ nonce (11 bytes)    │
├──────────────────┼───────────────────────────┼─────────────────────┤
│ byte 31          │ bytes 11-30               │ bytes 0-10          │
└──────────────────┴───────────────────────────┴─────────────────────┘
```

- **Byte 31 (MSB)**: `0x5b` prefix identifying this as a subblock transaction
- **Bytes 11-30**: The 20-byte fee recipient address
- **Bytes 0-10**: 11-byte nonce value (2^88 possible values)

### 2.2 Nonce Key Construction

```solidity
function buildSubblockNonceKey(address feeRecipient, uint88 nonce) pure returns (uint256) {
    return (uint256(0x5b) << 248) | (uint256(uint160(feeRecipient)) << 88) | uint256(nonce);
}
```

### 2.3 Fee Recipient Extraction

```solidity
function extractFeeRecipient(uint256 nonceKey) pure returns (address) {
    require(uint8(nonceKey >> 248) == 0x5b, "Not a subblock nonce key");
    return address(uint160(nonceKey >> 88));
}
```

### 2.4 Nonce Extraction

```solidity
function extractNonce(uint256 nonceKey) pure returns (uint88) {
    return uint88(nonceKey);
}
```

---

## 3. Signed Subblock Structure

### 3.1 SubBlock

```rust
struct SubBlock {
    version: SubBlockVersion,  // V2 for this spec
    parent_hash: B256,         // Block hash this subblock builds on
    fee_recipient: Address,    // Must match all txs' nonce key fee_recipient
    transactions: Vec<Transaction>,
}
```

### 3.2 SignedSubBlock

```rust
struct SignedSubBlock {
    subblock: SubBlock,
    signature: Bytes,  // ed25519 signature from builder's signingKey
}
```

### 3.3 Signature Computation

```
signature_hash = keccak256(0x78 || RLP(subblock))
signature = ed25519_sign(signingKey, signature_hash)
```

### 3.4 Version

This TIP introduces `SubBlockVersion::V2`. Nodes MUST reject V1 subblocks after activation.

---

## 4. Subblock Metadata

### 4.1 Extended Metadata

The end-of-block subblock metadata system transaction includes offset fields to identify signed subblock transaction ranges:

```rust
struct SubBlockMetadata {
    version: SubBlockVersion,
    validator: Address,          // The validatorAddress from ValidatorConfig
    fee_recipient: Address,      // From the signed subblock
    signature: Bytes,            // ed25519 signature
    tx_start_index: u64,         // Start index in block tx list (0-based)
    tx_count: u64,               // Number of transactions in this subblock
}
```

The `validator` field is required for:
- **Gas budget enforcement**: Each validator has a per-validator gas allocation
- **Active status verification**: Must check `ValidatorConfig.validators(validator).active == true`
- **Signing key lookup**: `SubblockRegistry.builderOf(validator).signingKey` for signature verification

### 4.2 Indexing Rules

- Indices are zero-based over the full block transaction list
- Start-of-block system transactions are included in indexing
- End-of-block subblock metadata system transaction is excluded from indexing
- Each metadata entry references the contiguous range `[tx_start_index, tx_start_index + tx_count)`

### 4.3 Metadata Validity Rules

For each metadata entry:

1. The referenced range MUST be within the block transaction list bounds
2. All transactions in the range MUST have nonce key prefix `0x5b`
3. All transactions in the range MUST have the same `fee_recipient` in their nonce key, matching the metadata `fee_recipient`
4. Ranges MUST NOT overlap between metadata entries
5. Metadata entries MUST be ordered by `tx_start_index` in ascending order
6. Empty subblocks (`tx_count = 0`) are allowed; `tx_start_index` MUST fit between other ranges

### 4.4 Signature Verification

For each metadata entry:

1. Verify `ValidatorConfig.validators(validator).active == true`
2. Look up builder config: `builder = SubblockRegistry.builderOf(validator)`
3. Verify `builder.feeRecipient == fee_recipient` (must match)
4. Reconstruct the `SubBlock` from the referenced transaction range
5. Compute `signature_hash = keccak256(0x78 || RLP(subblock))`
6. Verify `ed25519_verify(builder.signingKey, signature_hash, signature)`
7. If any verification fails, the block is invalid

---

## 5. Fallback 0x5b Transactions

### 5.1 Definition

A **fallback 0x5b transaction** is a transaction with:
- Nonce key prefix `0x5b`
- NOT referenced by any subblock metadata entry (i.e., outside all `[tx_start_index, tx_start_index + tx_count)` ranges)

### 5.2 Inclusion Rules

- Fallback 0x5b transactions MAY appear anywhere in the block body
- Fallback 0x5b transactions MAY appear in both the proposer lane and gas incentive lane
- For gas accounting, fallback 0x5b transactions are treated as normal proposer transactions
- Multiple fallback 0x5b transactions from different fee recipients MAY appear in the same block

### 5.3 Root-Only Signing

All 0x5b transactions (signed subblock or fallback) MUST be signed by the root EOA key:
- Keychain signatures are NOT allowed
- `key_authorization` is NOT allowed

### 5.4 Fee Recipient Resolution

For any 0x5b transaction, the fee recipient is extracted directly from the nonce key (bytes 11-30). No registry lookup is needed for fee recipient determination.

### 5.5 Fee Token Resolution and AMM Liquidity

Fee collection uses `SubblockRegistry` for the builder's token preference:

1. The transaction's `fee_token` field specifies which token the user pays in
2. Extract `fee_recipient` from the transaction's nonce key
3. Look up `builder_fee_token = SubblockRegistry.feeTokenFor(fee_recipient)`

**AMM Swap Behavior:**

If `tx.fee_token != builder_fee_token` and the builder has a token preference (non-zero):
- If sufficient AMM liquidity exists, swap `tx.fee_token` to `builder_fee_token`
- If insufficient liquidity, the fee recipient receives `tx.fee_token` directly (no swap)

The transaction is **never invalidated** due to missing AMM liquidity—the fee recipient simply receives whichever token the user paid in.

**Unregistered fee recipients:**

If `fee_recipient` is not registered in `SubblockRegistry`:
- `feeTokenFor()` returns zero address
- No token preference applies
- Fees are paid to `fee_recipient` directly in `tx.fee_token` (no swap attempted)

### 5.6 Fee Failure Behavior

- **Signed subblock transactions**: Follow existing subblock fee failure semantics
- **Fallback 0x5b transactions**: Follow normal transaction semantics—if fee payment fails (insufficient balance), the transaction is invalid and the block is invalid if included

Note: Missing AMM liquidity does NOT cause transaction failure. The validator simply receives the user's fee token directly.

---

## 6. Transaction Routing

### 6.1 Builder Endpoint

Builders MUST expose an RPC endpoint for receiving subblock transactions. Users submit 0x5b transactions to the builder whose `fee_recipient` matches their nonce key.

### 6.2 Subblock Submission Endpoint

All validators MUST expose an endpoint for receiving signed subblocks from builders:

```
POST /subblocks/submit
Content-Type: application/octet-stream
Body: RLP-encoded SignedSubBlock
```

Validators store received subblocks and propagate them internally. When a validator becomes proposer, they select subblocks for inclusion.

### 6.3 Fallback Submission

Users MAY submit 0x5b transactions to any node's public RPC as a fallback path. These transactions enter the proposer's fallback mempool and are included as fallback 0x5b transactions if:
- The builder is offline or unavailable
- The builder's signed subblock did not include the transaction
- The subblock gas budget is exhausted

### 6.4 No P2P Gossip for Subblocks

Signed subblocks are NOT propagated via p2p gossip. The dedicated submission endpoint is the only ingress path for subblocks.

---

## 7. End-to-End Flow

### 7.1 Setup (Once per Validator)

```
1. Validator calls SubblockRegistry.setSubblockBuilder({
       signingKey: <builder's ed25519 pubkey>,
       feeRecipient: <builder's fee address>,
       feeToken: <TIP-20 token address>
   })
2. Registry stores the mapping, enforces feeRecipient uniqueness
3. Builder starts operating with signingKey, advertises feeRecipient to users
```

### 7.2 Transaction Creation (User)

```
1. User selects a builder by feeRecipient
2. User constructs nonce key: 0x5b | feeRecipient | nonce
3. User signs transaction with ROOT EOA key (no keychain)
4. User submits transaction to builder's RPC endpoint
   - Optionally also submits to public RPC as fallback
```

### 7.3 Subblock Building (Builder)

```
1. Builder collects transactions matching their feeRecipient
2. Builder validates each transaction (nonce, balance, execution)
3. Builder orders transactions, respects gas budget
4. Builder creates SubBlock with parent_hash = current chain tip
5. Builder signs with ed25519 signingKey → SignedSubBlock
6. Builder submits to validators' subblock endpoint
```

### 7.4 Block Building (Proposer)

```
1. Proposer receives SignedSubBlocks from validators' internal propagation
2. For each subblock:
   a. Look up signingKey by feeRecipient in registry
   b. Verify ed25519 signature
   c. Verify all txs have matching feeRecipient in nonce key
   d. Verify parent_hash matches current tip
   e. Execute transactions, verify validity
3. Select valid subblocks, respecting per-validator gas limits
4. Include fallback 0x5b transactions from mempool (if any)
5. Build SubBlockMetadata with tx_start_index/tx_count for each signed subblock
6. Append SubBlockMetadata system transaction at end of block
```

### 7.5 Block Execution (All Nodes)

```
1. Execute block transactions in order
2. For each 0x5b transaction:
   a. Extract feeRecipient from nonce key (bytes 11-30)
   b. Look up feeToken from registry (or use default)
   c. Deduct fees in feeToken, credit to feeRecipient
3. Process SubBlockMetadata system transaction:
   a. For each metadata entry, verify signature against registry signingKey
   b. Verify tx ranges match the transactions in the block
   c. If any verification fails, block is invalid
```

---

## 8. Gas Accounting

### 8.1 Per-Validator Gas Budget

Gas budgets remain per-validator, not per-builder:

```
shared_gas_limit = block_gas_limit / TEMPO_SHARED_GAS_DIVISOR
per_validator_gas = shared_gas_limit / num_validators
```

The validator's designated builder uses their validator's gas allocation.

### 8.2 Fallback Transaction Accounting

Fallback 0x5b transactions consume gas from the proposer's non-shared gas budget, not from any validator's shared allocation.

---

## 9. Subblock Lifecycle

### 9.1 Subblock Validity

A signed subblock is valid only if:
- `parent_hash` matches the current chain tip
- The `validator` in metadata is active in `ValidatorConfig`
- The `fee_recipient` matches the registered `SubblockRegistry.builderOf(validator).feeRecipient`
- All transactions have nonce key prefix `0x5b` with matching `fee_recipient`
- The signature verifies against `SubblockRegistry.builderOf(validator).signingKey`
- Total gas does not exceed the validator's per-validator gas budget

### 9.2 Subblock Expiry

Subblocks expire immediately when `parent_hash` becomes stale. Subblocks have a 1-block lifetime.

### 9.3 Conflicting Subblocks

If a builder submits multiple subblocks for the same `parent_hash`, the proposer selects the one with higher total gas used (maximizing fees).

### 9.4 Deduplication

Validators deduplicate received subblocks by `(fee_recipient, parent_hash)`. Only the most recent (or highest-gas) subblock is retained.

---

# Invariants

## Must Hold

| ID | Invariant |
|----|-----------|
| **S1** | Fee recipient uniqueness: Each `feeRecipient` is registered by at most one validator. This ensures nonce key namespaces do not collide. |
| **S2** | Validator identity: Only active validators (per `ValidatorConfig`) can register or update builder configurations |
| **S3** | Nonce key format: All 0x5b transactions have fee recipient in bytes 11-30 of the nonce key |
| **S4** | Signature validity: Signed subblock signatures verify against the `signingKey` registered for the `validator` in SubblockRegistry |
| **S5** | Metadata consistency: `SubBlockMetadata.fee_recipient` MUST match `SubblockRegistry.builderOf(validator).feeRecipient` |
| **S6** | Range validity: Metadata tx ranges are non-overlapping, ordered, and within bounds |
| **S7** | Fee routing: Fees are paid to the fee recipient extracted from the nonce key |
| **S8** | Root-only signing: 0x5b transactions reject keychain signatures |
| **S9** | Gas budget: Each validator's subblock does not exceed `per_validator_gas` |
| **S10** | Immediate effect: Builder configuration changes take effect in the next block |

## Test Cases

1. **Happy path**: Validator registers builder, user submits tx, builder creates subblock, proposer includes it
2. **Builder offline**: User submits to fallback mempool, tx included as fallback 0x5b
3. **Fee recipient uniqueness**: Second validator cannot register same feeRecipient
4. **Signature verification**: Invalid signature causes block rejection
5. **Nonce key mismatch**: Tx with wrong feeRecipient in nonce key rejected from subblock
6. **Overlapping ranges**: Block with overlapping metadata ranges is invalid
7. **Keychain signature**: 0x5b tx with keychain signature is rejected
8. **Unregistered fee recipient**: Fallback tx pays fees directly in tx.fee_token to fee_recipient
9. **Builder rotation**: Validator updates builder config, new builder's subblocks accepted
10. **Gas budget exceeded**: Subblock exceeding per-validator gas is rejected
11. **Conflicting subblocks**: Higher-gas subblock selected over lower-gas
12. **Stale parent hash**: Subblock with old parent_hash rejected
13. **Inactive validator**: Subblock from inactive validator rejected, even if builder config exists
14. **Non-validator caller**: Non-validator address cannot call setSubblockBuilder
15. **Metadata fee_recipient mismatch**: Block invalid if metadata fee_recipient doesn't match registry
16. **Fee token swap with liquidity**: If AMM liquidity exists, validator receives their preferred token
17. **Fee token swap without liquidity**: If no AMM liquidity, validator receives tx.fee_token directly
18. **Unregistered recipient fee**: Fallback 0x5b tx to unregistered recipient pays in tx.fee_token (no swap)

---

# Implementation Notes

## Relationship to Current Implementation

The current implementation stores subblock-related configuration as follows:

| Data | Current Location | TIP-1011 Location |
|------|------------------|-------------------|
| Fee recipient address | CLI arg (`--consensus.fee-recipient`) | `SubblockRegistry.builders[validator].feeRecipient` |
| Subblock signing key | CLI arg (`--consensus.signing-key`), same as consensus key | `SubblockRegistry.builders[validator].signingKey` (separate from consensus) |
| Subblock fee token | `TipFeeManager.validatorTokens[validator]` | `SubblockRegistry.builders[validator].feeToken` |
| Proposer fee token | `TipFeeManager.validatorTokens[validator]` | Unchanged (remains in `TipFeeManager`) |

Key changes:
1. **Fee recipient moves on-chain**: Currently a CLI config, becomes an on-chain registry entry
2. **Signing key separation**: Currently uses the consensus ed25519 key, becomes a dedicated builder key
3. **Subblock fee token separated**: Validators can now have different token preferences for subblock fees vs proposer fees

---

# Migration

## Activation

This TIP activates at a specific block height. After activation:

- SubBlockVersion::V1 subblocks are rejected
- The old nonce key format (`0x5b | validator_pubkey_prefix | nonce`) is no longer valid
- Validators must register builder configurations before their subblocks are accepted

## Migration Steps

1. **Pre-activation**: Validators call `setSubblockBuilder()` to register their builder configurations
2. **Activation block**: Protocol switches to V2 subblock validation
3. **Post-activation**: V1 subblocks and old nonce key formats are rejected

Validators who want to continue using their consensus key for subblock signing should still register, setting `signingKey` to their preferred key and `feeRecipient` to their validator address.
