---
id: TIP-1011
title: Enhanced Access Key Permissions
description: Extends Access Keys with periodic spending limits and destination/function scoping for subscription-based and restricted access patterns.
authors: Tanishk Goyal 
status: Draft
related: TIP-1000, AccountKeychain, IAccountKeychain.sol
protocolVersion: TBD (requires hardfork)
---

# TIP-1011: Enhanced Access Key Permissions

## Abstract

This TIP extends Access Keys with two new permission features: (1) **periodic spending limits** that automatically reset after a configurable time period, enabling subscription-based access patterns, and (2) **call scoping** that restricts keys to only interact with specific contract addresses and/or specific function selectors on those contracts.

## Motivation

Currently, Access Keys support spending limits (per-TIP-20 token caps) and expiry timestamps. However, these primitives are insufficient for common real-world patterns:

### Periodic Spending Limits

The existing `TokenLimit` specifies a one-time spending cap that depletes permanently. This model doesn't support subscription-based patterns where:

- A service needs recurring access to a fixed amount per billing cycle
- Users want to authorize "up to X tokens per month" without re-authorizing
- dApps implement subscription models (e.g., streaming services, SaaS payments)

**Use cases:**
1. **Subscription services**: Authorize a streaming service to charge 10 USDC/month
2. **Recurring donations**: Allow an NPO to withdraw up to 5 USDC weekly
3. **Payroll systems**: Enable payroll contracts to transfer salaries monthly
4. **Rate-limited APIs**: Authorize API access keys with per-period token budgets

### Call Scoping (Destination + Function Selector)

Users have requested the ability to bind Access Keys to specific destinations and functions (e.g., "only allow transactions to Uniswap's `swap()` function"). This provides more granular permission scoping similar to Solana's delegate primitive.

**Two levels of scoping:**
1. **Address-only scoping**: Restrict key to specific contract addresses (any function)
2. **Address+Selector scoping**: Restrict key to specific function selectors on specific addresses

**Use cases:**
1. **DeFi integrations**: Allow a trading bot key to only call `swap()` on a specific DEX contract
2. **Gaming**: Scope a session key to only call `move()` and `attack()` on a game contract
3. **Subscription services**: Allow a key to only call `charge()` on a specific payment contract
4. **Limited approvals**: Allow a key to call `approve()` only on specific tokens
5. **DAO operations**: Scope a delegate key to only call `vote()` on governance contracts

**Current workaround**: Deploy a proxy contract that enforces destination/function restrictions, adding gas overhead and complexity.

---

# Specification

## Extended Data Structures

### TokenLimit

**Current:**
```solidity
struct TokenLimit {
    address token;
    uint256 limit;
}
```

**Proposed:**
```solidity
struct TokenLimit {
    address token;
    uint256 limit;      // Per-period limit when period > 0, one-time limit otherwise
    uint256 remainingInPeriod;  // Remaining allowance in current period
    uint64 period;      // Period duration in seconds (0 = one-time limit)
    uint64 periodEnd;   // Timestamp when current period expires
}
```

### CallScope

A new struct for specifying address+selector restrictions:

```solidity
struct CallScope {
    address target;     // Contract address (address(0) = wildcard for any address)
    bytes4 selector;    // Function selector (bytes4(0) = wildcard for any function)
}
```

**Semantics:**
- `target=0x123, selector=0xaabbccdd` → Only call function `0xaabbccdd` on address `0x123`
- `target=0x123, selector=0x00000000` → Call any function on address `0x123` (address-only scoping)
- `target=0x0, selector=0xaabbccdd` → Call function `0xaabbccdd` on any address (selector-only scoping)
- Empty `allowedCalls` array → Unrestricted (can call any function on any address)

### KeyAuthorization

**Current fields retained:**
- `spendingLimits`: `TokenLimit[]`
- `expiry`: `uint64`

**New fields:**
```solidity
struct KeyAuthorization {
    TokenLimit[] spendingLimits;
    uint64 expiry;
    CallScope[] allowedCalls; // Empty array = unrestricted
}
```

 Address-only scoping is achieved by setting `selector = bytes4(0)`.

## Interface Changes

### IAccountKeychain.sol

```solidity
/// @notice Authorizes a key with enhanced permissions
/// @param key The public key to authorize
/// @param expiry Block timestamp when key expires
/// @param spendingLimits Token spending limits (may include periodic limits)
/// @param allowedCalls Call scopes (address+selector pairs) the key may call (empty = unrestricted)
function authorizeKey(
    bytes calldata key,
    uint64 expiry,
    TokenLimit[] calldata spendingLimits,
    CallScope[] calldata allowedCalls
) external;

/// @notice Returns the allowed call scopes for a key
/// @param key The public key to query
/// @return calls Array of allowed call scopes (empty = unrestricted)
function getAllowedCalls(bytes calldata key) external view returns (CallScope[] memory calls);

/// @notice Returns the remaining limit for a token, accounting for period resets
/// @param key The public key to query
/// @param token The token address
/// @return remaining The remaining spending limit for the current period
/// @return periodEnd The timestamp when the current period ends (0 if one-time limit)
function getRemainingLimit(bytes calldata key, address token) external view returns (uint256 remaining, uint64 periodEnd);
```

## Semantic Behavior

### Periodic Limit Reset Logic

When a spending attempt occurs:

```
function verifyAndUpdateSpending(key, token, amount):
    limit = getTokenLimit(key, token)
    
    if limit.period > 0:  // Periodic limit
        if block.timestamp >= limit.periodEnd:
            // Reset period — advance periodEnd by whole multiples of period
            // to prevent drift when transactions land late
            elapsed = block.timestamp - limit.periodEnd
            periodsElapsed = elapsed / limit.period + 1
            limit.periodEnd += periodsElapsed * limit.period
            limit.remainingInPeriod = limit.limit  // Reset to per-period allowance
    
    if amount > limit.remainingInPeriod:
        revert SpendingLimitExceeded()
    
    limit.remainingInPeriod -= amount
```

### Call Validation Logic

When a transaction is submitted with an Access Key:

```
function validateCall(key, destination, calldata):
    allowed = getAllowedCalls(key)
    
    if allowed.length == 0:
        return true  // Unrestricted
    
    selector = calldata[0:4]  // First 4 bytes of calldata
    
    for scope in allowed:
        targetMatch = (scope.target == address(0)) || (scope.target == destination)
        selectorMatch = (scope.selector == bytes4(0)) || (scope.selector == selector)
        
        if targetMatch && selectorMatch:
            return true
    
    revert CallNotAllowed()
```

**Special cases:**
- Empty calldata (ETH transfer): selector is treated as `bytes4(0)`. A scope with `selector=bytes4(0)` matches ETH transfers.
- Contract creation (`to=null`): Always rejected if `allowedCalls` is non-empty (cannot whitelist contract creation).

### Interaction Rules

1. **Mixed limits**: Keys can have a mix of one-time and periodic limits for different tokens
2. **Call scope + limits**: Both constraints are evaluated independently; both must pass
3. **Period updates**: Calling `updateSpendingLimit()` updates the per-period amount and resets the current period
4. **Empty calls**: An empty `allowedCalls` array means the key is unrestricted (can call any function on any address)
5. **Batch transactions**: For AA transactions with multiple calls, each call is validated independently against the allowed scopes

## Gas Costs

| Operation | Additional Gas |
|-----------|----------------|
| `authorizeKey` with N call scopes | ~20,000 + 7,000 × N |
| `authorizeKey` with periodic limit | ~3,000 per periodic token |
| Call scope check (per call) | ~2,100 + 300 × N |
| Period reset (when triggered) | ~5,000 |

## Encoding

### Transaction Authorization

The `KeyAuthorization` struct is RLP-encoded in the transaction's authorization field:

```
KeyAuthorization := RLP([
    spendingLimits: [TokenLimit, ...],
    expiry: uint64,
    allowedCalls: [CallScope, ...]
])

TokenLimit := RLP([
    token: address,
    limit: uint256,
    remainingInPeriod: uint256,
    period: uint64,
    periodEnd: uint64
])

CallScope := RLP([
    target: address,
    selector: bytes4
])
```

---

# Backward Compatibility

This TIP requires a **hardfork** due to changes in transaction encoding and execution semantics.

## RLP Encoding Changes

### TokenLimit (2 fields → 5 fields)

The current `TokenLimit` struct encodes as `[token, limit]`. This TIP extends it to `[token, limit, remainingInPeriod, period, periodEnd]`.

**Breaking change**: Old nodes cannot decode new transactions with 5-field `TokenLimit`. New nodes must implement version-tolerant decoding:

```
On decode:
  if list.len() == 2:
    // V1 (legacy one-time limit)
    remainingInPeriod = limit
    period = 0
    periodEnd = 0
  else if list.len() == 5:
    // V2 (periodic limit)
    decode all fields
  else:
    error
```

Post-fork, all new `TokenLimit` encodings MUST use the 5-field format for consistency.

### KeyAuthorization (trailing field addition)

`KeyAuthorization` uses `#[rlp(trailing)]` which allows appending optional fields. Adding `allowedCalls: Option<Vec<CallScope>>` as the last field is compatible with this pattern:

- Old encodings (without `allowedCalls`) decode as `allowedCalls = None` (unrestricted)
- New encodings with `allowedCalls` will be rejected by old nodes

## Compact/Database Encoding

Although `TokenLimit` has `#[derive(reth_codecs::Compact)]`, it is **not used in production storage**. The storage path is:

```
TempoTransaction (derived Compact)
  └─ key_authorization: Option<SignedKeyAuthorization>
       └─ SignedKeyAuthorization (custom Compact impl → uses RLP internally)
            └─ KeyAuthorization (RLP encoded)
                 └─ limits: Option<Vec<TokenLimit>> (RLP encoded)
```

`SignedKeyAuthorization` implements a custom `Compact` that wraps RLP encoding. Therefore, `TokenLimit` is always serialized as RLP bytes in the database, not via its derived Compact layout.

**Implication**: If we implement version-tolerant RLP decoding for `TokenLimit` (accept 2-field or 5-field lists), existing database entries will decode correctly. **No DB rebuild required** for this change.

## Precompile Storage Changes

The current storage layout:
- `keys[account][keyId] → AuthorizedKey` (packed slot)
- `spending_limits[key][token] → U256` (remaining amount)

This TIP requires additional per-token state for periodic limits. **Additive storage approach** (no migration required):

| Mapping | Type | Description |
|---------|------|-------------|
| `spending_limits[key][token]` | `U256` | Reinterpreted as `remainingInPeriod` |
| `spending_limit_max[key][token]` | `U256` | Per-period cap (new) |
| `spending_limit_period[key][token]` | `u64` | Period duration in seconds (new) |
| `spending_limit_period_end[key][token]` | `u64` | Current period end timestamp (new) |

For call scoping:
| Mapping | Type | Description |
|---------|------|-------------|
| `allowed_calls_len[key]` | `u64` | Number of allowed call scopes |
| `allowed_calls_target[key][index]` | `Address` | Target address at index |
| `allowed_calls_selector[key][index]` | `bytes4` | Function selector at index |

Legacy keys (pre-fork) have `period = 0`, `max = 0`, and behave as one-time limits.

## Hardfork-Gated Features

The following MUST be gated behind the hardfork activation:

1. **RLP decoding**: Accept 5-field `TokenLimit` and `allowedCalls` in `KeyAuthorization`
2. **Periodic limit reset logic**: Check `periodEnd` and reset `remainingInPeriod` on spend
3. **Call scoping enforcement**: Validate transaction `to` and calldata against `allowedCalls`
4. **New precompile storage writes**: Write to new storage slots for period/call scope data
5. **New precompile interface methods**: `getAllowedCalls()`, updated `getRemainingLimit()` return type

Pre-fork blocks MUST be replayed with old semantics to preserve state root consistency.

---

# Invariants

1. **Period monotonicity**: `periodEnd` MUST only increase; it cannot be set to a past timestamp.

2. **Limit conservation**: For periodic limits, `remainingInPeriod` MUST NOT exceed `limit` after any reset.

3. **Call scope enforcement**: If `allowedCalls` is non-empty, transactions with (destination, selector) pairs not matching any allowed scope MUST revert.

4. **Backward compatibility**: Keys authorized without the new fields MUST behave as unrestricted (`allowedCalls = []`) with one-time limits (`period = 0`).

5. **Wildcard matching**: `target=address(0)` matches any address; `selector=bytes4(0)` matches any selector (including ETH transfers).

6. **Expiry precedence**: Key expiry MUST be checked before spending limits or call scope restrictions.

## Test Cases

1. **Periodic reset**: Verify that a periodic limit resets correctly after the period elapses
2. **Partial period usage**: Verify that unused periodic allowance does not roll over
3. **Call scope allow (address+selector)**: Verify that calls matching (target, selector) succeed
4. **Call scope allow (address-only)**: Verify that any function on an allowed address succeeds when `selector=0`
5. **Call scope allow (selector-only)**: Verify that allowed selector on any address succeeds when `target=0`
6. **Call scope deny**: Verify that calls not matching any allowed scope revert
7. **Empty allowed calls**: Verify that empty `allowedCalls` allows any call
8. **Mixed limits**: Verify that a key can have both one-time and periodic limits for different tokens
9. **Upgrade path**: Verify that existing keys continue to function after upgrade
10. **Batch call validation**: Verify that all calls in a batch transaction are validated against allowed scopes
11. **ETH transfer with call scoping**: Verify that ETH transfers (empty calldata) work correctly with `selector=0` scopes

## References

- [AccountKeychain docs](https://docs.tempo.xyz/protocol/transactions/AccountKeychain)
- [IAccountKeychain.sol](docs/specs/src/interfaces/IAccountKeychain.sol)
- [GitHub Issue #1865](https://github.com/tempoxyz/tempo/issues/1865) - Periodic spending limits
- [GitHub Issue #1491](https://github.com/tempoxyz/tempo/issues/1491) - Destination address scoping
