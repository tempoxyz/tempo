---
id: TIP-1022
title: Virtual Addresses for TIP-20 Deposit Forwarding
description: Precompile-native virtual addresses that auto-forward TIP-20 deposits to a registered master wallet, eliminating sweep transactions.
authors: Lizm Horne, Mallesh Pai, Dan Robinson
status: Draft
related: TIP-20, TIP-403
protocolVersion: TBD (requires hardfork)
---

# TIP-1022: Virtual Addresses for TIP-20 Deposit Forwarding

## Abstract

This TIP introduces **virtual addresses**: a reserved address prefix that, when detected in any TIP-20 transfer, causes the precompile to auto-credit a registered master wallet instead of the target address. This eliminates sweep transactions entirely for exchanges, ramps, and payment processors that generate per-user deposit addresses. Master registration is a one-time on-chain call; deposit address derivation is fully off-chain.

## Motivation

- **Eliminate sweep transactions.** Exchanges, ramps, and payment processors (e.g., Bridge/Stripe, Coinbase) need to offer each customer a unique deposit address. Today, funds arriving at each address must be swept back to a central wallet in separate transactions, which is an enormous operational cost at scale. Virtual addresses auto-credit the master wallet at the protocol level, making sweeps unnecessary.

- **Avoid the 250,000 gas new-account cost.** Tempo charges 250,000 gas to create state for a new address on first use. With virtual addresses, deposit addresses never create on-chain state, so the first transfer to a new deposit address costs the same as any other transfer.

- **Prevent state bloat.** Without virtual addresses, each customer deposit address creates a new account in the state trie. At enterprise scale (millions of deposit addresses), this is significant and permanent state growth. Virtual addresses avoid this entirely: no accounts are created, regardless of how many deposit addresses an exchange generates.

---

# Specification

## Address Layout

Virtual addresses are standard 20-byte EVM addresses with a reserved prefix:

```
[8-byte PREFIX] [4-byte masterId] [8-byte userTag]
= 20 bytes total
```

| Field | Bytes | Description |
|-------|-------|-------------|
| **PREFIX** | 8 | Fixed prefix `0xFDFDFDFDFDFDFDFD`. Identifies virtual addresses with collision probability ~1/2⁶⁴. |
| **masterId** | 4 | Deterministic identifier derived from the master address. Supports up to ~4 billion masters. |
| **userTag** | 8 | Opaque per-user identifier, derived off-chain. 64-bit space supports >10¹⁹ unique deposit addresses per master. |

### Prefix Selection: `0xFDFDFDFDFDFDFDFD`

An 8-byte prefix provides collision resistance of ~1/2⁶⁴. The probability that any randomly-generated EOA or CREATE2-deployed contract matches this prefix is approximately 5.4 × 10⁻²⁰, which is negligible by any measure and infeasible to grind even with dedicated hardware.

### masterId Derivation

The `masterId` is **deterministic**, derived from the address that calls `registerVirtualMaster()` and a caller-supplied salt:

```
masterId = bytes4(keccak256(abi.encodePacked(msg.sender, salt)))
```

The salt is a `bytes32` value chosen by the caller. A salt of `bytes32(0)` is the natural default for first-time registration. This eliminates dependence on transaction ordering and is stable under reorgs. The `masterId` is permanently bound to the **registration address** and does not change if the master is later rotated to a new address via `proposeUpdateMaster` / `finalizeUpdateMaster`. This is what makes deposit addresses stable: they embed `masterId`, so they continue to work regardless of master rotation.

In the unlikely event of a masterId collision (two `(address, salt)` pairs mapping to the same 4-byte hash), the second registration reverts with `MasterIdCollision`. The caller can simply retry with a different salt. Post-rotation, the mapping from master address to masterId is not directly derivable anyway (since the master address changes but masterId is fixed), so strict derivation from the address alone provides no additional benefit.

### userTag Derivation (Off-Chain)

The `userTag` is an opaque 8-byte value generated off-chain by the exchange/processor. The protocol does not interpret or validate it. It exists solely so the exchange can attribute deposits to specific users via the emitted `VirtualForward` event.

Exchanges maintain their own internal mapping `{internalUserId → virtualAddress}`. No on-chain transaction is needed to create a new deposit address.

It is recommended (but not required) to derive userTags using a keyed hash (e.g., HMAC) to prevent third parties from enumerating deposit addresses.

### Worked Example

An exchange with master address `0xABCD...1234` registers with salt `bytes32(0)`:
- `masterId = bytes4(keccak256(abi.encodePacked(0xABCD...1234, bytes32(0))))` → e.g., `0x07A3B1C2`
- For user #103048, the exchange derives a userTag → e.g., `0xa7c3f19e2b8d4501`

```
Virtual address = 0xFDFDFDFDFDFDFDFD  07A3B1C2  a7c3f19e2b8d4501
                  ^^^^^^^^^^^^^^^^^^  ^^^^^^^^  ^^^^^^^^^^^^^^^^
                  prefix (8)          masterId  userTag (8)
```

## Registry Precompile

Virtual address resolution requires a registry that maps `masterId → masterAddress`. This is managed through a new precompile.

### Interface

```solidity
interface IVirtualAddressRegistry {
    // ──────────────────── Events ────────────────────

    /// @notice Emitted when a new master is registered.
    event MasterRegistered(
        bytes4 indexed masterId,
        address indexed masterAddress
    );

    /// @notice Emitted when a master address update is proposed.
    event MasterUpdateProposed(
        bytes4 indexed masterId,
        address indexed currentMaster,
        address indexed proposedMaster,
        uint256 effectiveAt
    );

    /// @notice Emitted when a master address update takes effect.
    event MasterUpdateFinalized(
        bytes4 indexed masterId,
        address indexed oldMaster,
        address indexed newMaster
    );

    /// @notice Emitted when a master address update is cancelled.
    event MasterUpdateCancelled(
        bytes4 indexed masterId
    );

    /// @notice Emitted when forwarding is paused for a master.
    event ForwardingPaused(bytes4 indexed masterId);

    /// @notice Emitted when forwarding is resumed for a master.
    event ForwardingResumed(bytes4 indexed masterId);

    // ──────────────────── Errors ────────────────────

    /// @notice The computed masterId is already registered to a different address.
    error MasterIdCollision();

    /// @notice Caller is not the current master for this masterId.
    error NotMaster();

    /// @notice No pending update exists for this masterId.
    error NoPendingUpdate();

    /// @notice The timelock period has not elapsed.
    error TimelockNotElapsed();

    /// @notice The master address is already registered.
    error AlreadyRegistered();

    /// @notice Forwarding is paused for this masterId.
    error ForwardingPaused();

    /// @notice The virtual address has a valid prefix but its masterId is not registered.
    error VirtualAddressUnregistered();

    // ──────────────── Registration ──────────────────

    /// @notice Registers msg.sender as a virtual address master.
    /// @dev masterId is derived deterministically as bytes4(keccak256(abi.encodePacked(msg.sender, salt))).
    ///      Reverts with MasterIdCollision if the derived masterId is already taken
    ///      by a different address. Reverts with AlreadyRegistered if msg.sender is
    ///      already registered. On collision, the caller can retry with a different salt.
    /// @param salt Caller-chosen salt for masterId derivation. Use bytes32(0) as the default.
    /// @return masterId The derived master identifier.
    function registerVirtualMaster(bytes32 salt) external returns (bytes4 masterId);

    // ────────────────── Queries ─────────────────────

    /// @notice Returns the current master address for a given masterId, or address(0) if unregistered.
    function getMaster(bytes4 masterId) external view returns (address);

    /// @notice Returns true if forwarding is currently active (not paused) for this masterId.
    function isForwardingActive(bytes4 masterId) external view returns (bool);

    /// @notice Resolves a virtual address to its current master.
    ///         Returns address(0) if the address does not match VIRTUAL_PREFIX.
    ///         Reverts with VirtualAddressUnregistered if the masterId is not registered.
    ///         Reverts with ForwardingPaused if forwarding is paused for this masterId.
    function resolveVirtualAddress(address virtualAddr) external view returns (address master);

    /// @notice Returns true if the address matches the VIRTUAL_PREFIX.
    function isVirtualAddress(address addr) external pure returns (bool);

    /// @notice Decodes a virtual address into its components.
    /// @return isVirtual True if the address matches VIRTUAL_PREFIX.
    /// @return masterId The 4-byte master identifier (zero if not virtual).
    /// @return userTag The 8-byte user tag (zero if not virtual).
    function decodeVirtualAddress(address addr)
        external pure returns (bool isVirtual, bytes4 masterId, bytes8 userTag);

    /// @notice Returns the pending master update for a given masterId, if any.
    /// @return proposedMaster The proposed new master address (address(0) if none).
    /// @return effectiveAt The timestamp at which the update can be finalized (0 if none).
    function getPendingUpdate(bytes4 masterId)
        external view returns (address proposedMaster, uint256 effectiveAt);

    // ──────────── Master Rotation (Timelocked) ──────

    /// @notice The proposed new master address is invalid.
    error InvalidNewMaster();

    /// @notice Proposes updating the master address for the caller's masterId.
    /// @dev Only callable by the current master. Starts a timelock of UPDATE_TIMELOCK.
    ///      A new proposal replaces any existing pending proposal (timelock resets).
    ///      Reverts with InvalidNewMaster if newMaster is:
    ///        - address(0)
    ///        - the current master address (no-op)
    ///        - an address whose first 8 bytes match VIRTUAL_PREFIX (forwarding loop)
    /// @param newMaster The proposed new master address.
    function proposeUpdateMaster(address newMaster) external;

    /// @notice Finalizes a pending master address update after the timelock has elapsed.
    /// @dev Callable by anyone once the timelock has elapsed. This ensures liveness:
    ///      if the current master key is lost after proposing a rotation, the update
    ///      can still be finalized.
    /// @param masterId The master identifier whose pending update should be finalized.
    function finalizeUpdateMaster(bytes4 masterId) external;

    /// @notice Cancels a pending master address update.
    /// @dev Only callable by the current master.
    function cancelUpdateMaster() external;

    // ──────────── Pause / Resume ────────────────────

    /// @notice Pauses forwarding for the caller's masterId. Transfers to virtual
    ///         addresses under this master will revert while paused.
    /// @dev Only callable by the current master.
    function pauseForwarding() external;

    /// @notice Resumes forwarding for the caller's masterId.
    /// @dev Only callable by the current master.
    function resumeForwarding() external;
}
```

### Security Considerations for Master Addresses

The master address has full control over forwarding: it can propose rotations, pause/resume forwarding, and cancel pending updates. If the master key is compromised, an attacker can redirect future deposits (after the timelock elapses) or disrupt operations by pausing forwarding. The 48-hour timelock provides a detection window but is not a complete defense, since the attacker can also cancel legitimate rotations or toggle pause state.

Operators registering as virtual address masters SHOULD use appropriately hardened key management, including multisig wallets, hardware security modules, or similar controls commensurate with the value flowing through their deposit addresses.

### Constants

| Name | Value | Description |
|------|-------|-------------|
| `VIRTUAL_PREFIX` | `0xFDFDFDFDFDFDFDFD` | 8-byte prefix identifying virtual addresses |
| `UPDATE_TIMELOCK` | `172800` (48 hours) | Minimum delay before a master address update takes effect |

## Transfer Path Modification

The TIP-20 precompile transfer hot path (`transfer`, `transferFrom`, `transferWithMemo`, `mint`, `mintFrom`) is modified to detect virtual addresses and resolve them before crediting.

### Resolution Logic

```
function resolveRecipient(to: address) -> address:
    // Fast path: check first 8 bytes against VIRTUAL_PREFIX
    if to[0:8] != VIRTUAL_PREFIX:
        return to  // Not virtual, no overhead beyond an 8-byte comparison

    // Parse masterId from bytes 8..12
    masterId = to[8:12]

    // Look up master address
    master = registry.getMaster(masterId)

    // Unregistered masterId → revert (never black-hole funds)
    if master == address(0):
        revert VirtualAddressUnregistered()

    // Forwarding paused → revert (incident response)
    if !registry.isForwardingActive(masterId):
        revert ForwardingPaused()

    return master
```

### Gas Overhead

| Path | Additional cost |
|------|----------------|
| Non-virtual transfer | Effectively zero (single `u64` prefix comparison) |
| Virtual transfer (cold) | ~2,200 gas (one cold SLOAD for `masterId → master` registry lookup) |
| Virtual transfer (warm) | ~100 gas (one warm SLOAD) |

Precompile storage reads are metered using the same warm/cold SLOAD gas parameters as EVM storage. A standard TIP-20 `transfer` already performs ~4 SLOADs (pause check, policy lookup, sender balance, recipient balance) plus SSTOREs and log emissions, so one additional registry read is a modest increment.

The gas overhead for virtual transfers is borne by the sender.

### Event Emission

When a virtual address is resolved, **two events** are emitted in order:

1. **`VirtualForward`**, for deposit attribution by the exchange's indexer:
   ```solidity
   event VirtualForward(
       address indexed virtualAddress,
       address indexed masterAddress,
       address indexed token,
       uint256 amount
   );
   ```

2. **Standard `Transfer`**, with the master as the actual recipient, for correct balance tracking by explorers and indexers:
   ```solidity
   event Transfer(address indexed from, address indexed to, uint256 amount);
   // `to` = masterAddress (the account whose balance increased)
   ```

This ensures `balanceOf(masterAddress)` is always consistent with `Transfer` events, while the `VirtualForward` event provides the attribution data enterprises need.

## Behavior During Master Rotation

While a master rotation is pending (after `proposeUpdateMaster`, before `finalizeUpdateMaster`), all transfers to virtual addresses continue to forward to the **current** master. The proposed new master does not receive any forwards until the rotation is finalized. This ensures deposit attribution remains unambiguous during the timelock window.

## Self-Forwarding

If the current master sends tokens to one of its own virtual addresses, the transfer resolves back to the master, effectively a transfer to self. The standard TIP-20 self-transfer semantics apply (no net balance change). A `VirtualForward` event is still emitted per invariant #5. Indexers SHOULD NOT interpret `VirtualForward` as net inflow when `from == masterAddress`.

## Interaction with TIP-403 Policies

Virtual address resolution happens **before** TIP-403 transfer authorization checks. The resolved master address is used as the effective recipient for policy evaluation:

- If the **master** is sanctioned/blocked, the transfer reverts (correct behavior).
- If the **sender** is sanctioned/blocked, the transfer reverts (existing behavior).
- The virtual address itself is never checked against policies (it has no independent identity).

## Interaction with Account-Level Features

- **`balanceOf(virtualAddress)`**: Always returns 0. Virtual addresses do not hold balances.
- **Nonce**: Virtual addresses cannot sign transactions (no private key controls the forwarding). They have no nonce.
- **ETH/native transfers**: Unaffected. Virtual address forwarding applies **only** to TIP-20 precompile operations.

---

# Invariants

## Core Invariants

1. **No fund loss**: A TIP-20 transfer to a virtual address MUST either credit the registered master's balance by exactly the transfer amount, or revert. Funds MUST NOT be credited to the virtual address itself or lost.

2. **Revert on unregistered**: A transfer to an address matching `VIRTUAL_PREFIX` whose `masterId` is not registered MUST revert. It MUST NOT credit any account.

3. **Revert on paused**: A transfer to a virtual address whose master has paused forwarding MUST revert.

4. **Balance consistency**: After a successful virtual-forwarded transfer of amount `X`, `balanceOf(master)` MUST have increased by exactly `X`. `balanceOf(virtualAddress)` MUST remain 0.

5. **Event consistency**: Every virtual-forwarded transfer MUST emit a `VirtualForward` event followed by a standard `Transfer` event with `to = masterAddress`.

6. **Non-virtual path unaffected**: Transfers to addresses that do not match `VIRTUAL_PREFIX` MUST behave identically to pre-TIP-1022 semantics, with negligible gas overhead.

7. **Deterministic masterId**: `masterId` MUST equal `bytes4(keccak256(abi.encodePacked(registrationAddress, salt)))`, where `registrationAddress` is the address that originally called `registerVirtualMaster()` and `salt` is the caller-supplied salt. It MUST NOT change on master rotation, and MUST NOT depend on registration order or transaction ordering.

8. **Timelock enforcement**: A master address update MUST NOT take effect until at least `UPDATE_TIMELOCK` seconds after the proposal.

## Critical Test Cases

- Transfer to virtual address with registered, active master → credits master, emits both events.
- Transfer to virtual address with unregistered masterId → reverts.
- Transfer to virtual address with paused master → reverts.
- Transfer to non-virtual address starting with `0xFD` but not matching full 8-byte prefix → normal transfer (no forwarding).
- `masterId` collision: two different `(address, salt)` pairs that hash to the same `bytes4` → second registration reverts with `MasterIdCollision`. Retrying with a different salt succeeds.
- Master rotation: propose → wait < timelock → finalize reverts. Propose → wait ≥ timelock → finalize succeeds (callable by anyone). New master receives forwards; old master loses all privileges.
- Master rotation: propose → cancel → finalize reverts.
- Master rotation: during timelock window, transfers forward to old (current) master, not proposed master.
- Master rotation: double-propose replaces pending proposal and resets timelock.
- `finalizeUpdateMaster` called with unregistered or no-pending masterId → reverts.
- `proposeUpdateMaster(address(0))` → reverts with `InvalidNewMaster`.
- `proposeUpdateMaster(currentMaster)` → reverts with `InvalidNewMaster`.
- `proposeUpdateMaster(virtualPrefixAddress)` → reverts with `InvalidNewMaster`.
- Reorg safety: registration + transfer in same block, block reorged → transfer reverts (masterId no longer registered).
- Self-forwarding: master sends to own virtual address → credits master (no net change), emits `VirtualForward`.
- `transferFrom`, `transferWithMemo`, `mint`, `mintFrom` all respect virtual address resolution.
- TIP-403 policy applied to resolved master address, not virtual address.
- `balanceOf(virtualAddress)` returns 0 before and after forwarded transfer.
