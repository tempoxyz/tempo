---
id: TIP-1022
title: Virtual Addresses for TIP-20 Deposit Forwarding
description: Precompile-native virtual addresses that auto-forward TIP-20 deposits to a registered master wallet, eliminating sweep transactions.
authors: Lizm Horne, Mallesh Pai, Dan Robinson
status: Draft
related: TIP-20, TIP-403
protocolVersion: TBD (requires hardfork)
---

# TIP-1022: Virtual Addresses for TIP-20 Deposit Forwarding

## Abstract

This TIP introduces **virtual addresses**: a reserved address prefix that, when detected in TIP-20 recipient-bearing operations, causes the precompile to auto-credit a registered master wallet instead of the target address. This eliminates sweep transactions entirely for exchanges, ramps, and payment processors that generate per-user deposit addresses. Master registration is a one-time on-chain call; deposit address derivation is fully off-chain.

## Motivation

- **Eliminate sweep transactions.** Exchanges, ramps, and payment processors (e.g., Bridge/Stripe, Coinbase) need to offer each customer a unique deposit address. Today, funds arriving at each address must be swept back to a central wallet in separate transactions, which is an enormous operational cost at scale. Virtual addresses auto-credit the master wallet at the protocol level, making sweeps unnecessary.

- **Avoid the 250,000 gas new-account cost.** Tempo charges 250,000 gas to create state for a new address on first use. With virtual addresses, deposit addresses never create on-chain state, so the first transfer to a new deposit address costs the same as any other transfer.

- **Prevent state bloat.** Without virtual addresses, each customer deposit address creates a new account in the state trie. At enterprise scale (millions of deposit addresses), this is significant and permanent state growth. Virtual addresses avoid this entirely: no accounts are created, regardless of how many deposit addresses an exchange generates.

---

# Specification

## Address Layout

Virtual addresses are standard 20-byte EVM addresses with a reserved prefix, interpreted as a byte array where byte `0` is the leftmost byte in the hex string:

```
[8-byte PREFIX] [4-byte masterId] [8-byte userTag]
= 20 bytes total
```

| Field | Bytes | Description |
|-------|-------|-------------|
| **PREFIX** | 8 | Fixed prefix `0xFDFDFDFDFDFDFDFD`. Identifies virtual addresses with collision probability ~1/2⁶⁴. |
| **masterId** | 4 | Deterministic identifier derived from the master address. Supports up to ~4 billion masters. |
| **userTag** | 8 | Opaque per-user identifier, derived off-chain. 64-bit space supports >10¹⁹ unique deposit addresses per master. |

Parsing is position-based and endian-neutral:

- `addr[0:8]` = `VIRTUAL_PREFIX`
- `addr[8:12]` = `masterId` (the raw 4-byte sequence as it appears in the address)
- `addr[12:20]` = `userTag` (the raw 8-byte sequence as it appears in the address)

Implementations MUST NOT reinterpret `masterId` or `userTag` using host endianness.

## Conformance and Scope

TIP-1022 applies only to TIP-20 precompile recipient resolution for the entrypoints listed in **Transfer Path Modification**.

TIP-1022 does **not** alter TIP-20 methods that do not carry a recipient (e.g., `approve`, `burn`, `permit`) and does not alter non-TIP-20 protocol behavior.

Before TIP-1022 activation (`protocolVersion` hardfork), all TIP-20 behavior remains unchanged.

### Prefix Selection: `0xFDFDFDFDFDFDFDFD`

An 8-byte prefix provides collision resistance of ~1/2⁶⁴. The probability that any randomly-generated EOA or CREATE2-deployed contract matches this prefix is negligible by any measure and infeasible to grind even with dedicated hardware.

### Master ID Derivation

The `masterId` is **deterministic**, derived from the address that calls `registerVirtualMaster()` and a caller-supplied salt:

```
masterId = bytes4(keccak256(abi.encodePacked(msg.sender, salt)))
```

The salt is a `bytes32` value chosen by the caller. A salt of `bytes32(0)` is the natural default for first-time registration. This eliminates dependence on transaction ordering and is stable under reorgs. The `masterId` is permanently bound to the **registration address** and does not change if the master is later rotated to a new address via `proposeUpdateMaster` / `finalizeUpdateMaster`. This is what makes deposit addresses stable: they embed `masterId`, so they continue to work regardless of master rotation.

In the unlikely event of a masterId collision (two `(address, salt)` pairs mapping to the same 4-byte hash), the second registration reverts with `MasterIdCollision`. The caller can retry with a different salt.

### User Tag Derivation (Off-Chain)

The `userTag` is an opaque 8-byte value generated off-chain by the exchange/processor. The protocol does not interpret or validate it. It exists solely so the exchange can attribute deposits to specific users via the emitted `VirtualForward` event.

Exchanges maintain their own internal mapping `{internalUserId → virtualAddress}`. No on-chain transaction is needed to create a new deposit address.

Operators SHOULD derive userTags using a keyed hash (e.g., HMAC) to reduce third-party enumeration of deposit addresses.

### Worked Example

An exchange with master address `0xABCD...1234` registers with salt `bytes32(0)`:
- `masterId = bytes4(keccak256(abi.encodePacked(0xABCD...1234, bytes32(0))))` → e.g., `0x07A3B1C2`
- For user #103048, the exchange derives a userTag → e.g., `0xa7c3f19e2b8d4501`

```
Virtual address = 0xFDFDFDFDFDFDFDFD  07A3B1C2  a7c3f19e2b8d4501
                  ^^^^^^^^^^^^^^^^^^  ^^^^^^^^  ^^^^^^^^^^^^^^^^
                  prefix (8)          masterId  userTag (8)
```

## Registry Precompile

Virtual address resolution requires a registry that maps `masterId → masterAddress`. This is managed through a new precompile.

The registry MUST maintain a one-to-one mapping between active masters and `masterId`s:

- each `masterId` maps to at most one active master address
- each active master address maps to at most one `masterId`

A **valid master address** MUST satisfy TIP-20 recipient safety constraints:

- MUST NOT be `address(0)`
- MUST NOT match `VIRTUAL_PREFIX`
- MUST NOT be a TIP-20 token address (i.e., MUST pass TIP-20 recipient validation for transfer paths)

### Interface

```solidity
interface IVirtualAddressRegistry {
    // ──────────────────── Events ────────────────────

    /// @notice Emitted when a new master is registered.
    event MasterRegistered(
        bytes4 indexed masterId,
        address indexed masterAddress
    );

    /// @notice Emitted when a master address update is proposed.
    event MasterUpdateProposed(
        bytes4 indexed masterId,
        address indexed currentMaster,
        address indexed proposedMaster,
        uint256 effectiveAt
    );

    /// @notice Emitted when a master address update takes effect.
    event MasterUpdateFinalized(
        bytes4 indexed masterId,
        address indexed oldMaster,
        address indexed newMaster
    );

    /// @notice Emitted when a master address update is cancelled.
    event MasterUpdateCancelled(
        bytes4 indexed masterId
    );

    /// @notice Emitted when forwarding is paused for a master.
    event ForwardingPaused(bytes4 indexed masterId);

    /// @notice Emitted when forwarding is resumed for a master.
    event ForwardingResumed(bytes4 indexed masterId);

    // ──────────────────── Errors ────────────────────

    /// @notice The computed masterId is already registered to a different address.
    error MasterIdCollision();

    /// @notice Caller is not the current master for this masterId.
    error NotMaster();

    /// @notice No pending update exists for this masterId.
    error NoPendingUpdate();

    /// @notice The timelock period has not elapsed.
    error TimelockNotElapsed();

    /// @notice The master address is already registered.
    error AlreadyRegistered();

    /// @notice The caller/new master address is invalid for virtual forwarding.
    error InvalidMasterAddress();

    /// @notice Forwarding is paused for this masterId.
    error ForwardingPausedForMaster();

    /// @notice The virtual address has a valid prefix but its masterId is not registered.
    error VirtualAddressUnregistered();

    // ──────────────── Registration ──────────────────

    /// @notice Registers msg.sender as a virtual address master.
    /// @dev masterId is derived deterministically as bytes4(keccak256(abi.encodePacked(msg.sender, salt))).
    ///      Reverts with InvalidMasterAddress if msg.sender is not a valid master address.
    ///      Reverts with MasterIdCollision if the derived masterId is already taken
    ///      by a different address. Reverts with AlreadyRegistered if msg.sender is
    ///      already registered. On collision, the caller can retry with a different salt.
    /// @param salt Caller-chosen salt for masterId derivation. Use bytes32(0) as the default.
    /// @return masterId The derived master identifier.
    function registerVirtualMaster(bytes32 salt) external returns (bytes4 masterId);

    // ────────────────── Queries ─────────────────────

    /// @notice Returns the current master address for a given masterId, or address(0) if unregistered.
    function getMaster(bytes4 masterId) external view returns (address);

    /// @notice Returns the active masterId for a given master address.
    /// @return isRegistered True if masterAddress is currently registered.
    /// @return masterId The active masterId (undefined when isRegistered is false).
    function getMasterId(address masterAddress)
        external view returns (bool isRegistered, bytes4 masterId);

    /// @notice Returns true if forwarding is currently active (not paused) for this masterId.
    /// @dev Returns false for unregistered masterIds.
    function isForwardingActive(bytes4 masterId) external view returns (bool);

    /// @notice Resolves a virtual address to its current master.
    ///         Returns address(0) if the address does not match VIRTUAL_PREFIX.
    ///         Reverts with VirtualAddressUnregistered if the masterId is not registered.
    ///         Reverts with ForwardingPausedForMaster if forwarding is paused for this masterId.
    function resolveVirtualAddress(address virtualAddr) external view returns (address master);

    /// @notice Returns true if the address matches the VIRTUAL_PREFIX.
    function isVirtualAddress(address addr) external pure returns (bool);

    /// @notice Decodes a virtual address into its components.
    /// @return isVirtual True if the address matches VIRTUAL_PREFIX.
    /// @return masterId The 4-byte master identifier (zero if not virtual).
    /// @return userTag The 8-byte user tag (zero if not virtual).
    function decodeVirtualAddress(address addr)
        external pure returns (bool isVirtual, bytes4 masterId, bytes8 userTag);

    /// @notice Returns the pending master update for a given masterId, if any.
    /// @return proposedMaster The proposed new master address (address(0) if none).
    /// @return effectiveAt The timestamp at which the update can be finalized (0 if none).
    function getPendingUpdate(bytes4 masterId)
        external view returns (address proposedMaster, uint256 effectiveAt);

    // ──────────── Master Rotation (Timelocked) ──────

    /// @notice Proposed new master is equal to current master (no-op).
    error InvalidNewMaster();

    /// @notice Proposes updating the master address for the caller's masterId.
    /// @dev Only callable by the current master. Starts a timelock of UPDATE_TIMELOCK.
    ///      A new proposal replaces any existing pending proposal (timelock resets).
    ///      Reverts with InvalidMasterAddress if newMaster is not a valid master address.
    ///      Reverts with InvalidNewMaster if newMaster equals current master (no-op).
    ///      Reverts with AlreadyRegistered if newMaster is already the active master
    ///      for any masterId.
    /// @param newMaster The proposed new master address.
    function proposeUpdateMaster(address newMaster) external;

    /// @notice Finalizes a pending master address update after the timelock has elapsed.
    /// @dev Callable by anyone once the timelock has elapsed. This ensures liveness:
    ///      if the current master key is lost after proposing a rotation, the update
    ///      can still be finalized.
    ///      Timelock condition is: block.timestamp >= effectiveAt.
    ///      Re-validates proposedMaster at finalize-time and reverts with:
    ///        - InvalidMasterAddress if proposedMaster is no longer a valid master address
    ///        - AlreadyRegistered if proposedMaster became the active master for another masterId
    /// @param masterId The master identifier whose pending update should be finalized.
    function finalizeUpdateMaster(bytes4 masterId) external;

    /// @notice Cancels a pending master address update.
    /// @dev Only callable by the current master.
    function cancelUpdateMaster() external;

    // ──────────── Pause / Resume ────────────────────

    /// @notice Pauses forwarding for the caller's masterId. Transfers to virtual
    ///         addresses under this master will revert while paused.
    /// @dev Only callable by the current master.
    function pauseForwarding() external;

    /// @notice Resumes forwarding for the caller's masterId.
    /// @dev Only callable by the current master.
    function resumeForwarding() external;
}
```

### Security Considerations for Master Addresses

The master address has full control over forwarding: it can propose rotations, pause/resume forwarding, and cancel pending updates. If the master key is compromised, an attacker can redirect future deposits (after the timelock elapses) or disrupt operations by pausing forwarding. The 48-hour timelock provides a detection window but is not a complete defense, since the attacker can also cancel legitimate rotations or toggle pause state.

Operators registering as virtual address masters SHOULD use appropriately hardened key management, including multisig wallets, hardware security modules, or similar controls commensurate with the value flowing through their deposit addresses.

### Constants

| Name | Value | Description |
|------|-------|-------------|
| `VIRTUAL_PREFIX` | `0xFDFDFDFDFDFDFDFD` | 8-byte prefix identifying virtual addresses |
| `UPDATE_TIMELOCK` | `172800` (48 hours) | Minimum delay before a master address update takes effect |

## Transfer Path Modification

The following TIP-20 entrypoints are modified to detect virtual addresses and resolve them before crediting:

- `transfer`
- `transferFrom`
- `transferWithMemo`
- `transferFromWithMemo`
- `mint`
- `mintWithMemo`
- `systemTransferFrom`

### Resolution Logic

```
function resolveRecipient(to: address) -> address:
    // Fast path: check first 8 bytes against VIRTUAL_PREFIX
    if to[0:8] != VIRTUAL_PREFIX:
        return to  // Not virtual, no overhead beyond an 8-byte comparison

    // Registry resolves + validates:
    // - reverts VirtualAddressUnregistered if masterId not registered
    // - reverts ForwardingPausedForMaster if forwarding is paused
    // - returns current master otherwise
    return registry.resolveVirtualAddress(to)
```

For every entrypoint in this TIP:

1. compute `effectiveRecipient = resolveRecipient(to)`
2. run recipient validation and TIP-403 authorization checks against `effectiveRecipient` (not the virtual address)
3. apply balance changes to `effectiveRecipient`
4. emit events per **Event Emission**

If `resolveRecipient` reverts, the enclosing TIP-20 operation MUST revert atomically with no balance changes and no TIP-20 events.

### Gas Overhead

| Path | Additional cost |
|------|----------------|
| Non-virtual transfer | One 8-byte prefix comparison; no registry lookup |
| Virtual transfer (cold) | ~2,200 gas (one cold registry metadata lookup) |
| Virtual transfer (warm) | ~100 gas (one warm registry metadata lookup) |

Precompile storage reads are metered using the same warm/cold SLOAD gas parameters as EVM storage. These estimates assume the registry metadata needed for resolution (`masterAddress` + forwarding active/paused state) is retrievable in one storage lookup. Implementations that split this metadata across multiple slots MUST meter accordingly.

A standard TIP-20 `transfer` already performs ~4 SLOADs (pause check, policy lookup, sender balance, recipient balance) plus SSTOREs and log emissions, so one additional registry lookup is a modest increment.

The gas overhead for virtual transfers is borne by the sender.

### Event Emission

When a virtual address is resolved, `VirtualForward` MUST be emitted exactly once and MUST precede the canonical `Transfer` event for that operation.

```solidity
event VirtualForward(
    address indexed virtualAddress,
    address indexed masterAddress,
    address indexed token,
    uint256 amount
);
```

For a successful forwarded operation:

- `virtualAddress` MUST equal the original call argument `to`
- `masterAddress` MUST equal `effectiveRecipient`
- `token` MUST equal the TIP-20 token precompile address executing the operation
- `amount` MUST equal the operation amount argument

Additional TIP-20 events (memo/mint variants) MUST preserve existing TIP-20 ordering, with recipient fields set to the resolved `masterAddress` (never the virtual address):

- `transfer`, `transferFrom`, `systemTransferFrom`:
  1. `VirtualForward`
  2. `Transfer` (`to = masterAddress`)

- `transferWithMemo`, `transferFromWithMemo`:
  1. `VirtualForward`
  2. `Transfer` (`to = masterAddress`)
  3. `TransferWithMemo` (`to = masterAddress`)

- `mint`:
  1. `VirtualForward`
  2. `Transfer` (`from = address(0)`, `to = masterAddress`)
  3. `Mint` (`to = masterAddress`)

- `mintWithMemo`:
  1. `VirtualForward`
  2. `Transfer` (`from = address(0)`, `to = masterAddress`)
  3. `TransferWithMemo` (`from = address(0)`, `to = masterAddress`)
  4. `Mint` (`to = masterAddress`)

This keeps `balanceOf(masterAddress)` consistent with canonical TIP-20 accounting events while preserving deposit attribution.

If an operation reverts at any point, `VirtualForward` MUST NOT be emitted.

## Behavior During Master Rotation

While a master rotation is pending (after `proposeUpdateMaster`, before `finalizeUpdateMaster`), all transfers to virtual addresses continue to forward to the **current** master. The proposed new master does not receive any forwards until the rotation is finalized. This ensures deposit attribution remains unambiguous during the timelock window.

## Self-Forwarding

If the current master sends tokens to one of its own virtual addresses, the transfer resolves back to the master, effectively a transfer to self. The standard TIP-20 self-transfer semantics apply (no net balance change). A `VirtualForward` event is still emitted per invariant #5. Indexers SHOULD NOT interpret `VirtualForward` as net inflow when `from == masterAddress`.

## Interaction with TIP-403 Policies

Virtual address resolution happens **before** TIP-403 transfer authorization checks. The resolved master address is used as the effective recipient for policy evaluation:

- If the **master** is sanctioned/blocked, the transfer reverts (correct behavior).
- If the **sender** is sanctioned/blocked, the transfer reverts (existing behavior).
- The virtual address itself is never checked against policies (it has no independent identity).

## Interaction with Account-Level Features

- **`balanceOf(virtualAddress)`**: Always returns 0. Virtual addresses do not hold balances.
- **Nonce**: Virtual addresses cannot sign transactions (no private key controls the forwarding). They have no nonce.

---

# Invariants

## Core Invariants

1. **No fund loss**: A TIP-20 transfer to a virtual address MUST either credit the registered master's balance by exactly the transfer amount, or revert. Funds MUST NOT be credited to the virtual address itself or lost.

2. **Revert on unregistered**: A transfer to an address matching `VIRTUAL_PREFIX` whose `masterId` is not registered MUST revert. It MUST NOT credit any account.

3. **Revert on paused**: A transfer to a virtual address whose master has paused forwarding MUST revert.

4. **Balance consistency**: After a successful virtual-forwarded transfer of amount `X`, `balanceOf(master)` MUST have increased by exactly `X`. `balanceOf(virtualAddress)` MUST remain 0.

5. **Event consistency**: Every virtual-forwarded operation MUST emit exactly one `VirtualForward`, and it MUST occur before the canonical `Transfer`. Any additional TIP-20 events for that entrypoint (e.g., `TransferWithMemo`, `Mint`) MUST use `masterAddress` in recipient fields.

6. **Non-virtual path unaffected**: Transfers to addresses that do not match `VIRTUAL_PREFIX` MUST behave identically to pre-TIP-1022 semantics, with no registry lookup.

7. **Deterministic masterId**: `masterId` MUST equal `bytes4(keccak256(abi.encodePacked(registrationAddress, salt)))`, where `registrationAddress` is the address that originally called `registerVirtualMaster()` and `salt` is the caller-supplied salt. It MUST NOT change on master rotation, and MUST NOT depend on registration order or transaction ordering.

8. **Timelock enforcement**: A master address update MUST NOT take effect until at least `UPDATE_TIMELOCK` seconds after the proposal.

9. **Master uniqueness**: At all times, active mappings MUST be one-to-one (`masterId -> masterAddress` and `masterAddress -> masterId`).

10. **Atomic revert behavior**: If virtual resolution fails (unregistered or paused), the enclosing TIP-20 call MUST revert with no state changes and no events.

11. **`getMasterId` unambiguity**: `getMasterId` MUST provide explicit registration status (`isRegistered`) and MUST NOT rely on a sentinel `masterId` value.

## Critical Test Cases

- Transfer to virtual address with registered, active master → credits master, emits `VirtualForward` and canonical `Transfer` (plus any method-specific TIP-20 events, if applicable).
- Transfer to virtual address with unregistered masterId → reverts.
- Transfer to virtual address with paused master → reverts.
- Transfer to non-virtual address starting with `0xFD` but not matching full 8-byte prefix → normal transfer (no forwarding).
- Byte parsing conformance: `decodeVirtualAddress` MUST treat address bytes as `[0:8]=prefix,[8:12]=masterId,[12:20]=userTag` independent of host endianness.
- `masterId` collision: two different `(address, salt)` pairs that hash to the same `bytes4` → second registration reverts with `MasterIdCollision`. Retrying with a different salt succeeds.
- Register from an invalid master address (virtual-prefix or TIP-20 token address) → reverts with `InvalidMasterAddress`.
- Master rotation: propose → wait < timelock → finalize reverts. Propose → wait ≥ timelock → finalize succeeds (callable by anyone). New master receives forwards; old master loses all privileges.
- Master rotation: propose → cancel → finalize reverts.
- Master rotation: during timelock window, transfers forward to old (current) master, not proposed master.
- Master rotation: double-propose replaces pending proposal and resets timelock.
- `finalizeUpdateMaster` called with unregistered or no-pending masterId → reverts.
- `proposeUpdateMaster(address(0))` → reverts with `InvalidMasterAddress`.
- `proposeUpdateMaster(currentMaster)` → reverts with `InvalidNewMaster`.
- `proposeUpdateMaster(virtualPrefixAddress)` → reverts with `InvalidMasterAddress`.
- `proposeUpdateMaster(tip20TokenAddress)` → reverts with `InvalidMasterAddress`.
- `proposeUpdateMaster(newMasterAlreadyRegistered)` → reverts with `AlreadyRegistered`.
- `finalizeUpdateMaster` re-checks master validity and uniqueness:
  - invalid proposed master → `InvalidMasterAddress`
  - already-registered proposed master → `AlreadyRegistered`
- `getMasterId(unregisteredAddress)` returns `(false, <ignored>)`; `getMasterId(registeredMaster)` returns `(true, masterId)`.
- Reorg safety: registration + transfer in same block, block reorged → transfer reverts (masterId no longer registered).
- Self-forwarding: master sends to own virtual address → credits master (no net change), emits `VirtualForward`.
- `transferFrom`, `transferWithMemo`, `transferFromWithMemo`, `mint`, `mintWithMemo`, and `systemTransferFrom` all respect virtual address resolution.
- Event ordering for forwarded `transferWithMemo`, `transferFromWithMemo`, `mint`, and `mintWithMemo` matches the rules in **Event Emission**.
- TIP-403 policy applied to resolved master address, not virtual address.
- `balanceOf(virtualAddress)` returns 0 before and after forwarded transfer.
- On forwarded path revert (`VirtualAddressUnregistered`/`ForwardingPausedForMaster`), no `VirtualForward`, `Transfer`, `TransferWithMemo`, or `Mint` events are emitted.
