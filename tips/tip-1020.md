---
id: TIP-1020
title: Signature Verification Precompile
description: A precompile for verifying Tempo signatures onchain.
authors: Jake Moxey (@jxom)
status: Draft
related: Tempo Transaction Spec
protocolVersion: T2
---

# TIP-1020: Signature Verification Precompile

## Abstract

This TIP introduces a signature verification precompile that enables contracts to verify Tempo signature types (secp256k1, P256, WebAuthn) without relying on custom verifier contracts.

## Motivation

Tempo supports multiple signature schemes beyond standard secp256k1. Currently, contracts cannot verify Tempo signatures onchain without implementing custom verification logic for each signature type.

This precompile exposes Tempo's native signature verification to contracts, reusing the existing audited verification logic from Tempo transaction processing.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.

### Precompile Address

```
0x5165300000000000000000000000000000000000
```

### Interface

```solidity
interface ISignatureVerifier {
    error InvalidSignature();

    /// @notice Verifies a Tempo signature
    /// @param signer The expected signer address
    /// @param hash The message hash that was signed
    /// @param signature The encoded signature (see Tempo Transaction spec for formats)
    /// @return True if valid, reverts otherwise
    function verify(address signer, bytes32 hash, bytes calldata signature) external view returns (bool);
}
```

### Signature Encoding

Signatures MUST be encoded using the same format as [Tempo Transaction signatures](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#signature-types):

| Type | Format | Length |
|------|--------|--------|
| secp256k1 | `r \|\| s \|\| v` | 65 bytes |
| P256 | `0x01 \|\| r \|\| s \|\| x \|\| y \|\| prehash` | 130 bytes |
| WebAuthn | `0x02 \|\| webauthn_data \|\| r \|\| s \|\| x \|\| y` | 129–2049 bytes |

For backwards compatibility, secp256k1 signatures have no type prefix. All other signature types are prefixed with a type identifier byte.

### Verification Logic

The precompile MUST use the same verification logic as Tempo transaction signature validation. See the [Tempo Transaction Signature Validation spec](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#signature-validation) for details.

The precompile does NOT support Keychain signatures directly. For Keychain signature verification, see [Verifying Keychain Signatures in Contracts](#verifying-keychain-signatures-in-contracts).

### Gas Costs

Gas costs follow the [Tempo Transaction Signature Gas Schedule](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#signature-verification-gas-schedule):

| Type | Gas Cost |
|------|----------|
| secp256k1 | 3,000 |
| P256 | 8,000 |
| WebAuthn | 8,000 |

**Note**: Unlike transaction signature verification, WebAuthn signatures do not incur additional calldata gas in the precompile. The EVM already charges calldata gas when the signature is passed as a function argument, so adding it again would result in double-charging.

### Verifying Keychain Signatures in Contracts

Keychain signatures (type prefix `0x03`) are not supported by this precompile directly. Contracts can verify them by combining this precompile with the [AccountKeychain precompile](https://docs.tempo.xyz/protocol/transactions/AccountKeychain) (`0xaAAAaaAA00000000000000000000000000000000`).

A Keychain signature has the format `0x03 || user_address || inner_signature`. To verify one, a contract SHOULD perform the following steps:

1. **Decode the Keychain signature** — strip the `0x03` prefix, extract the `user_address` (20 bytes) and the `inner_signature` (remaining bytes).
2. **Derive the access key address** from the inner signature (the signer of the inner signature is the access key).
3. **Verify the inner signature** — call `ISignatureVerifier.verify(accessKeyAddress, hash, inner_signature)` on this precompile to validate that the inner signature is cryptographically valid.
4. **Validate the access key is authorized** — call `IAccountKeychain.getKey(user_address, accessKeyAddress)` on the AccountKeychain precompile and check that:
   - The key exists (i.e., `keyInfo.keyId != address(0)`)
   - The key is not revoked (`keyInfo.isRevoked == false`)
   - The key has not expired (`keyInfo.expiry > block.timestamp` or `keyInfo.expiry == type(uint64).max`)
5. **(Optional) Check spending limits** — if the key enforces limits (`keyInfo.enforceLimits == true`), call `IAccountKeychain.getRemainingLimit(user_address, accessKeyAddress, token)` to verify the key has sufficient remaining allowance.

## Rationale

### Reusing Tempo Transaction Logic

This precompile hooks directly into the existing signature verification logic used by Tempo transactions. This guarantees:

1. **1:1 compatibility** with transaction signature verification
2. **Audited code** — no new cryptographic implementations
3. **Consistent gas schedule** — same costs as transaction signatures

### Signer Parameter

The `signer` parameter is required because:

- For secp256k1, callers typically want to verify a specific expected signer
- For P256/WebAuthn, the derived address must be compared against an expected signer

This allows a single function call to both verify the signature and confirm the signer.

### Revert on Invalid

The function reverts on invalid signatures rather than returning `false`:

- **Explicit errors**: Callers know exactly why verification failed
- **Fail-fast**: Invalid signatures are programming errors or attacks
- **Simple success path**: If the call doesn't revert, the signature is valid
