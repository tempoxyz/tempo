---
id: TIP-1020
title: Signature Verification Precompile
description: A precompile for verifying Tempo signatures onchain.
authors: Jake Moxey (@jxom)
status: Draft
related: TIP-1003
protocolVersion: T2
---

# TIP-1020: Signature Verification Precompile

## Abstract

This TIP introduces a signature verification precompile that enables contracts to verify Tempo signature types (secp256k1, P256, WebAuthn, Keychain) without relying on custom verifier contracts.

## Motivation

Tempo supports multiple signature schemes beyond standard secp256k1. Currently, contracts cannot verify Tempo signatures onchain without implementing custom verification logic for each signature type.

This precompile exposes Tempo's native signature verification to contracts, reusing the existing audited verification logic from Tempo transaction processing.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.

### Precompile Address

```
0x5165300000000000000000000000000000000000
```

### Interface

```solidity
interface ISignatureVerifier {
    error InvalidSignature();

    /// @notice Verifies a Tempo signature
    /// @param signer The expected signer address
    /// @param hash The message hash that was signed
    /// @param signature The encoded signature (see Tempo Transaction spec for formats)
    /// @return True if valid, reverts otherwise
    function verify(address signer, bytes32 hash, bytes calldata signature) external view returns (bool);
}
```

### Signature Encoding

Signatures MUST be encoded using the same format as [Tempo Transaction signatures](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#signature-types):

| Type | Format | Length |
|------|--------|--------|
| secp256k1 | `r \|\| s \|\| v` | 65 bytes |
| P256 | `0x01 \|\| r \|\| s \|\| x \|\| y \|\| prehash` | 130 bytes |
| WebAuthn | `0x02 \|\| webauthn_data \|\| r \|\| s \|\| x \|\| y` | 129–2049 bytes |
| Keychain | `0x03 \|\| user_address \|\| inner_signature` | Variable |

For backwards compatibility, secp256k1 signatures have no type prefix. All other signature types are prefixed with a type identifier byte.

### Verification Logic

The precompile MUST use the same verification logic as Tempo transaction signature validation. See the [Tempo Transaction Signature Validation spec](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#signature-validation) for details.

#### Keychain Signatures

Keychain verification validates that an access key is authorized, not revoked, and not expired. It does NOT enforce spending limits because:

- Spending limits require value/token amounts from transaction context
- Limit enforcement requires state updates, inappropriate for a `view` function

Contracts needing limit checks should query `getRemainingLimit()` on the AccountKeychain precompile separately.

### Gas Costs

Gas costs follow the [Tempo Transaction Signature Gas Schedule](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#signature-verification-gas-schedule):

| Type | Gas Cost |
|------|----------|
| secp256k1 | 3,000 |
| P256 | 8,000 |
| WebAuthn | 8,000 |
| Keychain | Inner signature cost + 3,000 |

**Note**: Unlike transaction signature verification, WebAuthn signatures do not incur additional calldata gas in the precompile. The EVM already charges calldata gas when the signature is passed as a function argument, so adding it again would result in double-charging.

## Rationale

### Reusing Tempo Transaction Logic

This precompile hooks directly into the existing signature verification logic used by Tempo transactions. This guarantees:

1. **1:1 compatibility** with transaction signature verification
2. **Audited code** — no new cryptographic implementations
3. **Consistent gas schedule** — same costs as transaction signatures

### Signer Parameter

The `signer` parameter is required because:

- For secp256k1, callers typically want to verify a specific expected signer
- For P256/WebAuthn, the derived address must be compared against an expected signer

This allows a single function call to both verify the signature and confirm the signer.

### Revert on Invalid

The function reverts on invalid signatures rather than returning `false`:

- **Explicit errors**: Callers know exactly why verification failed
- **Fail-fast**: Invalid signatures are programming errors or attacks
- **Simple success path**: If the call doesn't revert, the signature is valid
