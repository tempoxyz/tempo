---
id: TIP-1020
title: Signature Verification Precompile
description: A precompile for verifying Tempo signatures onchain.
authors: Jake Moxey (@jxom)
status: Draft
related: Tempo Transaction Spec
protocolVersion: T2
---

# TIP-1020: Signature Verification Precompile

## Abstract

This TIP introduces a signature verification precompile that enables contracts to verify Tempo signature types (secp256k1, P256, WebAuthn) without relying on custom verifier contracts.

## Motivation

Tempo supports multiple signature schemes beyond standard secp256k1. Currently, contracts cannot verify Tempo signatures onchain without implementing custom verification logic for each signature type.

This precompile exposes Tempo's native signature verification to contracts, reusing the existing audited verification logic from Tempo transaction processing.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119.

### Precompile Address

```
0x5165300000000000000000000000000000000000
```

### Interface

```solidity
interface ISignatureVerifier {
    error InvalidSignature();

    /// @notice Verifies a stateless Tempo signature (secp256k1, P256, WebAuthn).
    ///         Does NOT support Keychain signatures.
    /// @param signer The expected signer address
    /// @param hash The message hash that was signed
    /// @param signature The encoded signature (see Tempo Transaction spec for formats)
    /// @return True if valid, reverts otherwise
    function verify(address signer, bytes32 hash, bytes calldata signature) external view returns (bool);

    /// @notice Verifies any Tempo signature, including Keychain signatures.
    ///         For stateless key types (secp256k1, P256, WebAuthn), behaves identically to `verify`.
    ///         For Keychain signatures, additionally validates the access key against
    ///         the AccountKeychain precompile (existence, revocation, expiry).
    /// @param signer The expected signer address
    /// @param hash The message hash that was signed
    /// @param signature The encoded signature (see Tempo Transaction spec for formats)
    /// @return True if valid, reverts otherwise
    function verifyStateful(address signer, bytes32 hash, bytes calldata signature) external view returns (bool);
}
```

### Signature Encoding

Signatures MUST be encoded using the same format as [Tempo Transaction signatures](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#signature-types):

| Type | Format | Length |
|------|--------|--------|
| secp256k1 | `r \|\| s \|\| v` | 65 bytes |
| P256 | `0x01 \|\| r \|\| s \|\| x \|\| y \|\| prehash` | 130 bytes |
| WebAuthn | `0x02 \|\| webauthn_data \|\| r \|\| s \|\| x \|\| y` | 129–2049 bytes |
| Keychain | `0x03 \|\| user_address \|\| inner_signature` | variable |

For backwards compatibility, secp256k1 signatures have no type prefix. All other signature types are prefixed with a type identifier byte.

### Verification Logic

The precompile MUST use the same verification logic as Tempo transaction signature validation. See the [Tempo Transaction Signature Validation spec](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#signature-validation) for details.

#### `verify`

The `verify` function MUST support only stateless signature types (secp256k1, P256, WebAuthn). It MUST revert if a Keychain signature (type prefix `0x03`) is provided.

#### `verifyStateful`

For stateless signature types (secp256k1, P256, WebAuthn), `verifyStateful` MUST behave identically to `verify`.

For Keychain signatures (type prefix `0x03`), `verifyStateful` MUST perform the following steps:

1. **Decode the Keychain signature** — strip the `0x03` prefix, extract the `user_address` (20 bytes) and the `inner_signature` (remaining bytes).
2. **Verify the `signer` matches** — the `signer` parameter MUST equal the `user_address` extracted from the Keychain signature.
3. **Derive the access key address** from the inner signature (the signer of the inner signature is the access key).
4. **Verify the inner signature** — validate that the inner signature is cryptographically valid for the given `hash`.
5. **Validate the access key is authorized** — query the [AccountKeychain precompile](https://docs.tempo.xyz/protocol/transactions/AccountKeychain) (`0xaAAAaaAA00000000000000000000000000000000`) and check that:
   - The key exists (i.e., `keyInfo.keyId != address(0)`)
   - The key is not revoked (`keyInfo.isRevoked == false`)
   - The key has not expired (`keyInfo.expiry > block.timestamp` or `keyInfo.expiry == type(uint64).max`)

### Gas Costs

Gas costs follow the [Tempo Transaction Signature Gas Schedule](https://docs.tempo.xyz/protocol/transactions/spec-tempo-transaction#signature-verification-gas-schedule):

| Type | Gas Cost |
|------|----------|
| secp256k1 | 3,000 |
| P256 | 8,000 |
| WebAuthn | 8,000 |
| Keychain | inner signature cost + 2,600 (cold `CALL` to AccountKeychain) |

**Note**: Unlike transaction signature verification, WebAuthn signatures do not incur additional calldata gas in the precompile. The EVM already charges calldata gas when the signature is passed as a function argument, so adding it again would result in double-charging.

## Rationale

### Reusing Tempo Transaction Logic

This precompile hooks directly into the existing signature verification logic used by Tempo transactions. This guarantees:

1. **1:1 compatibility** with transaction signature verification
2. **Audited code** — no new cryptographic implementations
3. **Consistent gas schedule** — same costs as transaction signatures

### Signer Parameter

The `signer` parameter is required because:

- For secp256k1, callers typically want to verify a specific expected signer
- For P256/WebAuthn, the derived address must be compared against an expected signer

This allows a single function call to both verify the signature and confirm the signer.

### Revert on Invalid

The function reverts on invalid signatures rather than returning `false`:

- **Explicit errors**: Callers know exactly why verification failed
- **Fail-fast**: Invalid signatures are programming errors or attacks
- **Simple success path**: If the call doesn't revert, the signature is valid
