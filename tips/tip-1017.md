---
id: TIP-1017
title: Subblocks v2 - Builder Delegation
description: Separates subblock builder identity from validator identity with many-to-one delegation, independent ECDSA signing, relay-node p2p authentication, and expiring nonce support.
authors: Mallesh Pai
status: Draft
related: Subblock Specification, TIP-1009
protocolVersion: TBD
---

# TIP-1017: Subblocks v2 - Builder Delegation

## Abstract

This TIP introduces major changes to the subblock system:

1. **Builder Delegation**: Validators can delegate subblock production to a builder identified by an ECDSA address. Multiple validators can delegate to the same builder, who accumulates their combined gas budget. Multiple physical machines can share the same builder ECDSA key for redundancy.

2. **Separate Signing Key**: Builders sign subblocks with their own ECDSA key (secp256k1), separate from the validator's consensus key. This avoids sharing the consensus key.

3. **Relay Nodes**: Each physical builder machine has its own ed25519 key for commonware p2p authentication. These relay nodes are registered under the builder in the SubblockRegistry and are authorized to deliver subblocks to proposers on behalf of the builder.

4. **Nonce Key Format**: The nonce key format changes to `0x5b | builder_address | nonce`, embedding the builder identity directly in the transaction.

5. **Expiring Nonces in Subblocks**: Subblock transactions can use expiring nonces by setting the nonce portion to all 1s (`0xFFFF...`).

## Motivation

The current subblock design has several limitations:

1. **Validator coupling**: The validator's consensus key must also sign subblocks, meaning validators cannot delegate subblock production to separate infrastructure without sharing their consensus key.

2. **One-to-one only**: Each validator must run their own subblock builder; there's no way to delegate to a shared builder.

3. **No expiring nonces**: Subblock transactions require sequential 2D nonces, preventing use of expiring nonces (TIP-1009).

4. **No redundancy model**: There is no way for a builder to run multiple physical machines for high availability while maintaining a single on-chain identity.

This TIP addresses these issues by:

- Allowing validators to delegate to builders identified by ECDSA address
- Supporting many-to-one delegation where multiple validators share a builder
- Using the builder's own ECDSA key for subblock signing (separate from consensus key)
- Introducing relay nodes (ed25519) for p2p authentication, allowing multiple physical machines per builder
- Enabling expiring nonces within subblock transactions

---

# Specification

## 1. Subblock Registry

A new Subblock Registry precompile stores builder configurations, validator delegations, and relay node registrations.

### 1.1 Data Structures

```solidity
struct BuilderConfig {
    address feeRecipient;  // where subblock fees are sent
    address feeToken;      // preferred TIP-20 token for fee payment
}
```

**Note on fee token**: The builder's fee token is stored in `SubblockRegistry`, separate from `TipFeeManager.validatorTokens`. This allows:
- **Subblock fees** (for txs in builder's subblocks): `SubblockRegistry.configOf(builder).feeToken`
- **Proposer fees** (when validator is block proposer): `TipFeeManager.validatorTokens[validator]`

When processing fees for a subblock transaction:
1. Resolve the user's fee token using standard Tempo resolution (tx preference → user preference → inference → PathUSD)
2. Extract `builder_address` from nonce key (big-endian bytes 1-20)
3. Resolve `fee_recipient` from SubBlockMetadata (populated by the proposer from parent block's registry state)
4. Resolve builder's `feeToken` from SubblockRegistry (parent block post-state)
5. If `feeToken` is set and differs from user's token, attempt swap via Fee AMM (constant-rate 0.997) if liquidity available
6. If no liquidity or no feeToken preference, fees are paid directly in the user's resolved fee token
7. Fees are sent to `fee_recipient`

### 1.2 Storage

```solidity
// Validator → builder they delegate to (zero = not delegated)
mapping(address => address) public delegatedBuilder;

// Builder address → their configuration
mapping(address => BuilderConfig) public builderConfig;

// Builder address → number of validators delegating to them (gas weight)
mapping(address => uint256) public gasWeight;

// Relay node ed25519 pubkey → builder address that registered it (zero = unregistered)
mapping(bytes32 => address) public relayOwner;

// Builder address → number of registered relay nodes
mapping(address => uint256) public relayCount;

// Builder address → relay node pubkeys (indexed for enumeration)
mapping(address => mapping(uint256 => bytes32)) public relayAt;
```

### 1.3 Interface

```solidity
interface ISubblockRegistry {
    // ========== Validator Functions ==========

    /// @notice Delegates the caller's subblock production to a builder.
    /// @param builder The builder's ECDSA address.
    /// @dev Only callable by validators in the ValidatorConfig set.
    /// @dev Clears any existing delegation first.
    /// @dev Increments the builder's gasWeight.
    /// @dev Requires builderConfig[builder].feeRecipient != address(0).
    function delegateToBuilder(address builder) external;

    /// @notice Clears the caller's delegation.
    /// @dev Only callable by validators with an existing delegation.
    /// @dev Decrements the previous builder's gasWeight.
    function clearDelegation() external;

    // ========== Builder Functions ==========

    /// @notice Sets the caller's builder configuration.
    /// @param feeRecipient Where subblock fees are sent.
    /// @param feeToken Preferred TIP-20 token for fee payment.
    /// @dev Builder identity is msg.sender (ECDSA address).
    function setBuilderConfig(address feeRecipient, address feeToken) external;

    /// @notice Clears the caller's builder configuration.
    function clearBuilderConfig() external;

    // ========== Relay Node Functions ==========

    /// @notice Registers an ed25519 relay node under the caller's builder identity.
    /// @param relayPubkey The relay node's ed25519 public key.
    /// @dev Only the builder (msg.sender) can register relay nodes.
    /// @dev Reverts if relayPubkey is already registered to a different builder.
    function registerRelayNode(bytes32 relayPubkey) external;

    /// @notice Unregisters a relay node from the caller's builder identity.
    /// @param relayPubkey The relay node's ed25519 public key.
    /// @dev Only the builder that registered it can unregister.
    function unregisterRelayNode(bytes32 relayPubkey) external;

    // ========== View Functions ==========

    /// @notice Returns the builder a validator has delegated to.
    /// @param validator The validator address.
    /// @return The builder's ECDSA address, or zero if not delegated.
    function builderOf(address validator) external view returns (address);

    /// @notice Returns a builder's configuration.
    /// @param builder The builder's ECDSA address.
    /// @return The BuilderConfig struct (zero values if not configured).
    function configOf(address builder) external view returns (BuilderConfig memory);

    /// @notice Returns a builder's fee recipient.
    /// @param builder The builder's ECDSA address.
    /// @return The fee recipient, or zero if not configured.
    function feeRecipientFor(address builder) external view returns (address);

    /// @notice Returns a builder's preferred fee token.
    /// @param builder The builder's ECDSA address.
    /// @return The TIP-20 token address, or zero if not configured.
    function feeTokenFor(address builder) external view returns (address);

    /// @notice Returns a builder's gas weight (number of delegating validators).
    /// @param builder The builder's ECDSA address.
    /// @return The gas weight.
    function gasWeightOf(address builder) external view returns (uint256);

    /// @notice Returns the builder that registered a relay node.
    /// @param relayPubkey The relay node's ed25519 public key.
    /// @return The builder address, or zero if unregistered.
    function relayOwnerOf(bytes32 relayPubkey) external view returns (address);

    /// @notice Returns the number of relay nodes registered to a builder.
    /// @param builder The builder's ECDSA address.
    /// @return The relay node count.
    function relayCountOf(address builder) external view returns (uint256);

    /// @notice Returns the relay node pubkey at a given index for a builder.
    /// @param builder The builder's ECDSA address.
    /// @param index The index (0-based).
    /// @return The relay node's ed25519 public key.
    function relayNodeAt(address builder, uint256 index) external view returns (bytes32);
}
```

### 1.4 Behavior

**Delegation:**
- Only addresses in the `ValidatorConfig` validator set can call `delegateToBuilder()`
- The SubblockRegistry queries `ValidatorConfig.validators(msg.sender)` to verify the caller is a validator (the `validators()` view returns a `Validator` struct; a non-zero `publicKey` confirms membership)
- When delegating, any existing delegation is cleared first (atomically updates gasWeight)
- On-chain state changes (delegation, config, gasWeight) take effect immediately in the next block

**Builder configuration:**
- `setBuilderConfig()` is called by the builder from their ECDSA address (`msg.sender`)
- `feeRecipient` MUST be set (non-zero) before validators can delegate to a builder
- If `feeToken` is zero, no swap is attempted (user's token is used)
- `clearBuilderConfig()` MUST force-clear all delegations pointing to the builder and decrement `gasWeight` to zero. This prevents a state where a builder has `gasWeight > 0` but no configured `feeRecipient`, which would create ambiguous fee routing.

**Relay nodes:**
- A builder registers relay node ed25519 pubkeys via `registerRelayNode()`
- Each relay pubkey can only be registered to one builder at a time
- A builder MAY register at most **4** relay nodes. `registerRelayNode()` reverts if this limit is exceeded.
- Relay nodes are used solely for commonware p2p authentication; the p2p layer verifies ed25519 identity, not the chain
- Builders SHOULD register at least one relay node before validators delegate to them

**Gas weight:**
- `gasWeight[builder]` is the count of validators currently delegating to that builder
- Incremented when a validator calls `delegateToBuilder(builder)`
- Decremented when a validator calls `clearDelegation()` or delegates to a different builder
- Used to compute the builder's total gas budget

**Validator set changes:**
- The subblock builder is separate infrastructure from the validator node. A validator being temporarily "down" or offline does NOT affect their builder's ability to produce subblocks.
- `gasWeight[builder]` always reflects the number of validators **in the consensus set** delegating to that builder.
- When a validator is **removed from ValidatorConfig** (exits the validator set):
  - Their delegation MUST be cleared
  - `gasWeight` for their builder is decremented
  - This can be done lazily (during next delegation change) or eagerly (via callback from ValidatorConfig)
- This ensures gas budgets accurately reflect the current validator set.

**Registry state snapshot:**
- All SubblockRegistry lookups during block validation and execution (gasWeight, feeRecipient, feeToken, relay ownership) use the **post-state of the parent block**. Registry mutations within the current block do NOT affect subblock validity or fee routing for that same block. This ensures deterministic validation independent of transaction ordering within a block.

**P2P peer set updates:**
- P2P authorization changes (adding/removing relay nodes from the authorized peer set) take effect at **epoch boundaries**, not per-block. The DKG Manager snapshots the relay node set at the start of each epoch. On-chain gasWeight changes are reflected in the p2p peer set starting from the next epoch.

### 1.5 Precompile Address

```
SUBBLOCK_REGISTRY_ADDRESS = 0x0b10c0000000000000000000000000000000000X  // TBD
```

### 1.6 Relationship to ValidatorConfig

The SubblockRegistry is a **separate precompile** from ValidatorConfig but **depends on it** for validator set membership:

```
┌─────────────────────┐         ┌─────────────────────┐
│   ValidatorConfig   │◄────────│   SubblockRegistry  │
│                     │  reads  │                     │
│  (validator set)    │         │ - delegatedBuilder  │
│                     │         │ - builderConfig     │
│                     │         │ - gasWeight         │
│                     │         │ - relayNodes        │
└─────────────────────┘         └─────────────────────┘
     Source of truth              Builder delegation
     for validator set            and relay node config
```

- ValidatorConfig defines **who is in the validator set** (used for consensus)
- SubblockRegistry tracks **builder delegations and relay nodes** (separate from consensus)

**P2P peer set**: At each epoch boundary, the DKG Manager reads relay node ed25519 pubkeys from SubblockRegistry for all builders with `gasWeight > 0` and adds them to the commonware p2p oracle for the subblocks channel. This allows relay nodes to join the authenticated network and deliver subblocks on behalf of their builder. Relay node authentication is handled by the p2p layer, not verified on-chain. Relay nodes are authorized only for subblock delivery — they are NOT added to the consensus participant set.

---

## 2. Nonce Key Format

### 2.1 Subblock Nonce Key

The nonce key is a `uint256` value. All byte indices below refer to the **big-endian** representation of this 32-byte value, where byte 0 is the most significant byte (leftmost) and byte 31 is the least significant byte (rightmost). This matches the Rust `U256::to_be_bytes()` convention used in the existing codebase.

**Note on V1 compatibility**: V1 subblock transactions also use the `0x5b` prefix but embed a 15-byte `PartialValidatorKey` in bytes 1-15 (big-endian). V2 changes this to a 20-byte builder address in bytes 1-20. Nodes distinguish V1 from V2 based on the fork activation height — all `0x5b` transactions in blocks at or above the activation height use V2 parsing; below it, V1 parsing.

```
32 bytes (big-endian, byte 0 = MSB):
┌──────────────────┬──────────────────────────────────┬─────────────────────┐
│ 0x5b (1 byte)    │ builder_address (20 bytes)        │ nonce (11 bytes)    │
├──────────────────┼──────────────────────────────────┼─────────────────────┤
│ byte 0 (MSB)     │ bytes 1-20                       │ bytes 21-31 (LSB)   │
└──────────────────┴──────────────────────────────────┴─────────────────────┘
```

- **Byte 0 (MSB)**: `0x5b` prefix identifying this as a subblock transaction
- **Bytes 1-20**: Builder's 20-byte ECDSA address
- **Bytes 21-31**: 11-byte nonce value (uint88, 2^88 possible values)

### 2.2 Nonce Key Construction

```
nonceKey = (0x5b << 248) | (uint160(builder_address) << 88) | nonce
```

### 2.3 Builder Extraction

```
builder_address = address(uint160(nonceKey >> 88))
```

In big-endian byte terms: `builder_address = nonceKey.to_be_bytes()[1..21]`

### 2.4 Nonce Extraction

```solidity
function extractNonce(uint256 nonceKey) pure returns (uint88) {
    return uint88(nonceKey);
}
```

### 2.5 Subblock Transaction Detection

```solidity
function isSubblockTx(uint256 nonceKey) pure returns (bool) {
    return uint8(nonceKey >> 248) == 0x5b;
}
```

---

## 3. Expiring Nonces in Subblocks

### 3.1 Motivation

TIP-1009 introduced expiring nonces for parallel transaction submission without sequential ordering. This TIP extends that support to subblock transactions.

### 3.2 Detection

A subblock transaction uses expiring nonce semantics if:
1. The nonce key has `0x5b` prefix (bytes 31)
2. The nonce portion (bytes 0-10) is all 1s: `0xFFFFFFFFFFFFFFFFFFFFFF` (max uint88, 11 bytes)

```solidity
uint88 constant EXPIRING_NONCE_MARKER = type(uint88).max;  // 0xFFFFFFFFFFFFFFFFFFFFFF

function isSubblockExpiringNonce(uint256 nonceKey) pure returns (bool) {
    return isSubblockTx(nonceKey) && extractNonce(nonceKey) == EXPIRING_NONCE_MARKER;
}
```

### 3.3 Nonce Key Format (Expiring)

```
32 bytes (big-endian, byte 0 = MSB):
┌──────────────────┬──────────────────────────────────┬─────────────────────┐
│ 0x5b (1 byte)    │ builder_address (20 bytes)        │ 0xFFF...FF (11 bytes)│
├──────────────────┼──────────────────────────────────┼─────────────────────┤
│ byte 0 (MSB)     │ bytes 1-20                       │ bytes 21-31 = max   │
└──────────────────┴──────────────────────────────────┴─────────────────────┘
```

### 3.4 Replay Protection

Subblock expiring nonce transactions follow TIP-1009 semantics:
- `validBefore` field is required
- `nonce` field must be `0`
- Replay protection via transaction hash + **same circular buffer** as TIP-1009
- Same validity window (30 seconds max)

The only difference from standard expiring nonces is the nonce key format, which routes the transaction to a specific builder. The replay protection shares the same `expiringNonceSeen` and `expiringNonceRing` storage as regular expiring nonces—no separate buffer is needed since the transaction hash is globally unique.

### 3.5 Nonce Key Construction (Expiring)

```
expiringNonceKey = (0x5b << 248) | (uint160(builder_address) << 88) | EXPIRING_NONCE_MARKER
```

---

## 4. Signed Subblock Structure

### 4.1 SubBlock

```rust
struct SubBlock {
    version: SubBlockVersion,  // V2 for this spec
    parent_hash: B256,         // Block hash this subblock builds on
    builder: Address,          // Builder's ECDSA address (replaces V1's fee_recipient field)
    chain_id: u64,             // Chain ID for cross-chain replay protection
    transactions: Vec<Transaction>,
}
```

**Note**: V1 used `fee_recipient: Address` in this position. V2 replaces it with `builder: Address` (the fee recipient is resolved from SubblockRegistry) and adds `chain_id`. The RLP field order changes, producing a different signature hash domain.

### 4.2 SignedSubBlock

```rust
struct SignedSubBlock {
    subblock: SubBlock,
    signature: Bytes,  // ECDSA signature (65 bytes: r, s, v)
}
```

### 4.3 Signature Computation

```
signature_hash = keccak256(0x78 || RLP(subblock))
signature = ecdsa_sign(builder_private_key, signature_hash)
```

The `0x78` magic byte provides domain separation from other signed payloads. The `chain_id` field in the SubBlock prevents cross-chain replay of subblock signatures.

### 4.4 Signature Verification

```
hash = keccak256(0x78 || RLP(subblock))
recovered = ecrecover(hash, signature)
valid = (recovered == subblock.builder)
```

### 4.5 Version

This TIP introduces `SubBlockVersion::V2`. Nodes MUST reject V1 subblocks after activation.

---

## 5. Subblock Metadata

### 5.1 SubBlockMetadata

The proposer includes metadata about included subblocks in a system transaction:

```rust
struct SubBlockMetadata {
    version: SubBlockVersion,  // V2 for this spec
    builder: Address,          // Builder's ECDSA address (replaces V1's validator: B256)
    fee_recipient: Address,    // Resolved from SubblockRegistry at parent block state
    signature: Bytes,          // ECDSA signature (65 bytes: r, s, v)
}
```

**Note**: This preserves the V1 metadata structure (version, identity, fee_recipient, signature) but changes the identity field from `validator: B256` (ed25519 pubkey) to `builder: Address` (ECDSA address), and the signature from ed25519 to ECDSA. The `fee_recipient` is resolved from the registry at the parent block's post-state and included in the metadata so all nodes agree on fee routing without re-querying the registry.

### 5.2 Metadata Validation

During block execution, the SubBlockMetadata system transaction is processed. The system transaction contains a `Vec<SubBlockMetadata>` — one entry per included subblock.

1. For each entry:
   a. Verify ECDSA signature recovers `entry.builder` address
   b. Verify all 0x5b transactions in the block whose nonce key builder_address matches `entry.builder` are contiguous and correspond to this entry
   c. Verify `gasWeight[builder] > 0` at the parent block's post-state
   d. Verify `entry.fee_recipient` matches `SubblockRegistry.feeRecipientFor(builder)` at the parent block's post-state

2. Verify subblock transaction groups are non-overlapping and in order within the block

### 5.3 Gas Budget Enforcement

Each builder's subblock is limited by their accumulated gas budget:

```
per_validator_gas = (block_gas_limit / TEMPO_SHARED_GAS_DIVISOR) / num_validators
builder_gas_budget = per_validator_gas × gasWeight[builder]
```

The metadata includes the `builder` address. During validation:
1. Look up `gasWeight[builder]` from SubblockRegistry
2. Compute builder's gas budget as `per_validator_gas × gasWeight`
3. Verify subblock's total gas usage does not exceed budget

---

## 6. Fee Routing

### 6.1 Fee Recipient Resolution

For subblock transactions (nonce key has `0x5b` prefix):

1. Extract `builder_address` from nonce key (big-endian bytes 1-20)
2. Use `fee_recipient` from SubBlockMetadata (resolved by proposer from parent block's registry state)
3. If `fee_recipient` is zero (edge case), fees go to the block proposer

### 6.2 Fee Token Resolution

The user's fee token is resolved using standard Tempo resolution:
1. Transaction's explicit `fee_token` field (if set)
2. User's default fee token preference (from user config)
3. Inference from transaction context
4. PathUSD (default)

### 6.3 Fee Token Swap

If `user_fee_token != builder_fee_token` and the builder has a token preference:
- If sufficient AMM liquidity exists, swap to `builder_fee_token`
- If insufficient liquidity, the fee recipient receives `user_fee_token` directly

The transaction is **never invalidated** due to missing AMM liquidity.

### 6.4 Builder Config Lifecycle

Builders must have `feeRecipient` configured before any validator can delegate to them.

`clearBuilderConfig()` force-clears all delegations pointing to the builder and decrements `gasWeight` to zero (see Section 1.4). After this, no new subblocks can be included for the builder since `gasWeight == 0`. This prevents a state where subblock transactions reference a builder with no fee routing configuration.

If, due to a race condition within a single block, a subblock references a builder whose `feeRecipient` is zero at the parent block's post-state, the `fee_recipient` in the SubBlockMetadata resolves to zero and fees are paid to the block proposer instead.

---

## 7. Transaction Routing

### 7.1 Builder Endpoint

Builders MUST expose an RPC endpoint for receiving subblock transactions from users. Users submit transactions to the builder whose address matches their nonce key.

### 7.2 Subblock Delivery via P2P

Relay nodes join the authenticated commonware p2p network using their ed25519 key. Each relay node operates on behalf of a builder and sends signed subblocks (signed with the builder's ECDSA key) directly to the next proposer via p2p, the same mechanism used in V1.

The proposer stores received subblocks and selects them for inclusion during block building. The proposer validates the ECDSA signature on the subblock, not the relay node's p2p identity — any authorized relay node can deliver a subblock for any builder it is registered to.

### 7.3 Relay Node P2P Authorization

The p2p peer set is updated at **epoch boundaries** (not per-block). At each epoch boundary, the DKG Manager snapshots the SubblockRegistry state:
- All relay node ed25519 pubkeys registered under builders with `gasWeight > 0` are added to the authorized peer set for the subblocks p2p channel
- Relay nodes whose builder has `gasWeight == 0` are excluded
- This is a separate authorization list from the consensus participant set — relay nodes are authorized only for subblock delivery, not for consensus messages

---

## 8. End-to-End Flow

### 8.1 Setup (Once per Builder)

```
1. Builder provisions an ECDSA keypair (secp256k1); this key is shared
   across all physical builder machines for subblock signing
2. Builder calls SubblockRegistry.setBuilderConfig(feeRecipient, feeToken)
   from their ECDSA address
3. For each physical machine:
   a. Machine generates an ed25519 keypair for p2p authentication
   b. Builder calls SubblockRegistry.registerRelayNode(relayPubkey)
   c. Machine starts a commonware p2p node with its ed25519 key
```

### 8.2 Setup (Once per Validator)

```
1. Validator selects a builder to delegate to (by ECDSA address)
2. Validator calls SubblockRegistry.delegateToBuilder(builderAddress)
3. Registry increments builder's gasWeight
```

### 8.3 Transaction Creation (User)

```
1. User selects a builder by ECDSA address
2. User constructs nonce key: 0x5b | builder_address | nonce
   - For sequential: nonce = next available value
   - For expiring: nonce = 0xFFF...FF (max uint88)
3. User signs transaction with ROOT EOA key (no keychain)
4. User submits transaction to builder's RPC endpoint
```

### 8.4 Subblock Building (Builder)

```
1. Builder collects transactions matching their address in nonce key
2. Builder validates each transaction (nonce, balance, execution)
3. Builder orders transactions, respects gas budget
4. Builder creates SubBlock with parent_hash = current chain tip
5. Builder signs with ECDSA → SignedSubBlock
6. Relay node sends SignedSubBlock to next proposer via commonware p2p
```

### 8.5 Block Building (Proposer)

```
1. Proposer receives SignedSubBlocks from relay nodes via p2p
2. For each subblock:
   a. Verify ECDSA signature recovers subblock.builder address
   b. Verify all txs have nonce key builder_address matching subblock.builder
   c. Verify parent_hash matches current tip
   d. Verify gasWeight[builder] > 0
   e. Compute builder's gas budget from gasWeight
   f. Verify total gas does not exceed budget
   g. Execute transactions, verify validity
3. Select valid subblocks
4. Build SubBlockMetadata for each (version, builder, fee_recipient from registry, signature)
5. Append Vec<SubBlockMetadata> as system transaction at end of block
```

### 8.6 Block Execution (All Nodes)

```
1. Execute block transactions in order
2. For each 0x5b transaction:
   a. Extract builder_address from nonce key (big-endian bytes 1-20)
   b. Determine if expiring nonce (nonce portion = max uint88)
   c. If expiring: use TIP-1009 replay protection
   d. Else: use 2D nonce semantics
   e. Resolve fee recipient from SubBlockMetadata
   f. Resolve fee token from SubblockRegistry (parent block post-state)
   g. Deduct fees, credit to fee recipient
3. Process SubBlockMetadata system transaction:
   a. Verify ECDSA signatures recover declared builder addresses
   b. Verify builder_address in metadata matches nonce key of corresponding txs
   c. If any verification fails, block is invalid
```

---

## 9. Gas Accounting

### 9.1 Per-Validator Gas Budget

Gas budgets are computed per-validator:

```
shared_gas_limit = block_gas_limit / TEMPO_SHARED_GAS_DIVISOR
per_validator_gas = shared_gas_limit / num_validators
```

### 9.2 Builder Gas Budget

A builder's gas budget is the sum of per-validator gas for all validators in the consensus set delegating to them:

```
builder_gas_budget = per_validator_gas × gasWeight[builder]
```

Since delegations are cleaned up when validators leave the set (see Section 1.4), `gasWeight` accurately reflects the builder's current gas allocation.

### 9.3 Gas Incentive Lane

Unused gas from subblocks becomes available for the gas incentive lane:

```
incentive_gas = Σ (per_validator_gas - subblock_gas_used)
```

Transactions after subblocks may use this pooled unused gas. The gas incentive lane is only available to the proposer if they include the subblocks — excluding subblocks forfeits the unused gas pool entirely. This creates an incentive for proposers to include subblocks even though subblock fees go to the builder: the proposer captures fees from the incentive lane transactions that fill the unused gas budget.

---

## 10. Subblock Lifecycle

### 10.1 Subblock Validity

A signed subblock is valid only if:
- `parent_hash` matches the current chain tip
- The ECDSA signature recovers `subblock.builder`
- `gasWeight[builder] > 0` (at least one validator in the set delegates to this builder)
- All transactions have nonce key `0x5b` prefix with builder_address matching `subblock.builder`
- Total gas does not exceed the builder's computed gas budget

**Fee failure**: If a subblock transaction cannot pay fees (e.g., user emptied their account in the main block), the transaction becomes a noop but the nonce is still incremented. The block remains valid.

### 10.2 Subblock Expiry

Subblocks expire immediately when `parent_hash` becomes stale. Subblocks have a 1-block lifetime.

### 10.3 Conflicting Subblocks

If a builder submits multiple subblocks for the same `parent_hash`, the proposer selects the one with the higher total `gas_limit` sum (static, no execution needed). On tie, the subblock with the lower `signature_hash` is selected (deterministic tie-break).

### 10.4 Deduplication

Validators deduplicate received subblocks by `(builder, parent_hash)`. Only the subblock with the highest total `gas_limit` sum is retained (same selection rule as Section 10.3).

---

## 11. Builder Redundancy

### 11.1 Architecture

A builder is identified by a single ECDSA address. A builder operator MAY run multiple physical machines that share signing authority for this ECDSA key. Each machine has its own ed25519 key for p2p authentication, registered as a relay node in the SubblockRegistry.

```
┌─────────────────────────────────────────────┐
│              Builder (ECDSA address)         │
│                                             │
│  ┌─────────────┐  ┌─────────────┐           │
│  │  Machine A   │  │  Machine B   │  ...     │
│  │  ed25519 #1  │  │  ed25519 #2  │          │
│  │  (relay node)│  │  (relay node)│          │
│  └──────┬───────┘  └──────┬───────┘          │
│         │                 │                  │
│    commonware p2p    commonware p2p          │
└─────────────────────────────────────────────┘
```

### 11.2 Transaction Fan-Out

For high availability, builders SHOULD deploy a load balancer that fans out every incoming transaction to all physical machines. Since all machines share the same ECDSA key and build from the same transaction pool, any machine can produce a valid subblock. The proposer selects one subblock per builder per block (Section 10.3); because all machines see the same transactions, no user transactions are lost regardless of which machine's subblock is selected.

### 11.3 Operational Guidance (Non-Normative)

- Builders SHOULD run multiple machines across availability zones
- Builders SHOULD use an HSM, KMS, or remote signer for the shared ECDSA key rather than distributing raw private key material
- Builders SHOULD register relay nodes for all active machines so each can independently deliver subblocks to the proposer

---

# Invariants

## Must Hold

| ID | Invariant |
|----|-----------|
| **S1** | Delegation requirement: Only validators in the consensus set can call `delegateToBuilder()` |
| **S2** | Gas weight consistency: `gasWeight[builder]` equals count of validators in the set delegating to that builder |
| **S3** | Nonce key format: All 0x5b transactions have builder address in big-endian bytes 1-20 |
| **S4** | Signature validity: Subblock ECDSA signatures recover the declared builder address |
| **S5** | Builder match: All transactions in a subblock have nonce key builder_address matching the subblock's builder |
| **S6** | Subblock ordering: Subblock transaction groups in the block are non-overlapping, contiguous, and in metadata order |
| **S7** | Fee routing: Fees are sent to `feeRecipientFor(builder)` |
| **S8** | Root-only signing: 0x5b transactions reject keychain signatures |
| **S9** | Gas budget: Each builder's subblock does not exceed their computed gas budget |
| **S10** | Immediate effect: Delegation and config changes take effect in the next block |
| **S11** | Expiring nonce detection: Nonce = max uint88 triggers TIP-1009 semantics |
| **S12** | Relay uniqueness: A relay node ed25519 pubkey can only be registered to one builder at a time |
| **S13** | Relay cap: A builder may register at most 4 relay nodes |
| **S14** | Registry snapshot: Subblock validation and fee routing use the parent block's post-state for all registry lookups |
| **S15** | Config clearing: `clearBuilderConfig()` force-clears all delegations to the builder and sets `gasWeight` to zero |

## Test Cases

1. **Happy path**: Validator delegates to builder, user submits tx, builder creates subblock, proposer includes it
2. **Many-to-one delegation**: Multiple validators delegate to same builder, builder gets combined gas budget
3. **Signature verification**: Invalid ECDSA signature causes block rejection
4. **Builder mismatch**: Tx with wrong builder in nonce key rejected from subblock
5. **Overlapping ranges**: Block with overlapping metadata ranges is invalid
6. **Keychain signature**: 0x5b tx with keychain signature is rejected
7. **Unregistered builder**: Delegation rejected if builder has no feeRecipient configured
8. **Builder rotation**: Validator changes delegation, old builder loses gas weight
9. **Gas budget exceeded**: Subblock exceeding computed gas budget is rejected
10. **Conflicting subblocks**: Higher-gas subblock selected over lower-gas
11. **Stale parent hash**: Subblock with old parent_hash rejected
12. **Validator exits set**: Validator removed from ValidatorConfig, their delegation cleared, builder's gasWeight decremented
13. **Expiring nonce subblock**: Tx with nonce = max uint88 uses TIP-1009 replay protection
14. **Fee token swap with liquidity**: If AMM liquidity exists, builder receives their preferred token
15. **Fee token swap without liquidity**: If no AMM liquidity, fee recipient receives user's fee token
16. **Relay node registration**: Builder registers multiple relay nodes, all are authorized in p2p peer set
17. **Relay node uniqueness**: Registering a relay pubkey already owned by another builder reverts
18. **Multi-machine redundancy**: Two relay nodes submit subblocks for same builder, proposer selects one, no txs lost
19. **Config clearing with delegations**: Builder calls clearBuilderConfig(), all delegations are force-cleared, gasWeight drops to zero
20. **Relay node cap**: Fifth relay node registration for same builder reverts
21. **Cross-chain replay**: Subblock signed on chain A is invalid on chain B (chain_id mismatch)

---

# Design Rationale

## Root-Only Signing for Subblock Transactions

Subblock transactions (0x5b prefix) require root EOA signatures and reject keychain (access key) signatures. This is intentional due to a race condition with key revocation:

1. User signs a 0x5b tx with an access key, submits to builder
2. Builder validates signature against current keychain state, includes in subblock
3. In the same block, a main block tx revokes that access key
4. Block execution order: main txs execute first, then subblock txs
5. When the subblock tx executes, the key is already revoked

The problem: signature validation happens at subblock validation time (before block building), not during execution. The subblock tx would still execute even though the key was revoked in the same block.

This violates user expectations. When a user revokes an access key, they expect immediate effect. Allowing keychain signatures for subblock txs would create a window where revoked keys can still authorize transactions.

**Alternative considered**: Re-validate keychain signatures during execution. This was rejected because:
- Adds execution-time overhead for every subblock tx
- Creates griefing vector: users could intentionally revoke keys to cause builder's subblock to fail
- Complicates the execution model

Root-only signing is the simplest solution that maintains user expectations around key revocation.

## ECDSA for Builder Signing, ed25519 for P2P

Builders use ECDSA (secp256k1) for subblock signing and are identified by their Ethereum-style address. Relay nodes use ed25519 for commonware p2p authentication. This separation exists because:

1. **Multiple machines need independent p2p identities**: Commonware's authenticated p2p network requires a unique ed25519 key per node. A builder running multiple machines for redundancy needs separate p2p identities for each.

2. **Subblock signing must be shared**: All machines must produce valid subblocks under the same identity. ECDSA with a shared key (via HSM/KMS) is a well-understood operational pattern.

3. **Clean separation of concerns**: ECDSA handles on-chain identity and authorization (signing, gas accounting, fee routing). Ed25519 handles network transport authentication only.

**Alternative considered**: Using ed25519 for both signing and p2p (one key for everything). This was the original design but was abandoned because it prevents running multiple machines per builder — each machine would need its own ed25519 key for p2p, but subblocks need a single signing identity.

---

# Implementation Notes

## Relationship to Current Implementation

The current implementation stores subblock-related configuration as follows:

| Data | Current Location | TIP-1017 Location |
|------|------------------|-------------------|
| Fee recipient address | CLI arg (`--consensus.fee-recipient`) | `SubblockRegistry.builderConfig[builder].feeRecipient` |
| Subblock signing key | CLI arg (`--consensus.signing-key`), ed25519 | Builder's ECDSA key (shared across machines) |
| Subblock fee token | `TipFeeManager.validatorTokens[validator]` | `SubblockRegistry.builderConfig[builder].feeToken` |
| Proposer fee token | `TipFeeManager.validatorTokens[validator]` | Unchanged (remains in `TipFeeManager`) |
| P2P identity | Validator ed25519 key | Relay node ed25519 keys (one per machine, registered under builder) |

Key changes:
1. **Separate signing key**: Builder uses ECDSA, not the validator's consensus key
2. **Many-to-one delegation**: Validators can share a builder, accumulating gas budgets
3. **Builder configures fee routing**: The builder (not validator) sets fee recipient and token preferences
4. **Relay nodes for p2p**: Each physical machine has its own ed25519 key for p2p, registered under the builder
5. **Expiring nonce support**: Subblock txs can use expiring nonces by setting nonce = max uint88

---

# Migration

## Activation

This TIP activates at a specific block height. After activation:

- SubBlockVersion::V1 subblocks are rejected
- The old nonce key format (`0x5b | validator_pubkey_prefix | nonce`) is no longer valid
- Validators must delegate to a builder before their subblock gas is usable

## Migration Steps

1. **Pre-activation**: Builders call `setBuilderConfig()` from their ECDSA address to configure fee routing
2. **Pre-activation**: Builders call `registerRelayNode()` for each physical machine's ed25519 pubkey
3. **Pre-activation**: Validators call `delegateToBuilder()` to delegate their gas budget
4. **Activation block**: Protocol switches to V2 subblock validation
5. **Post-activation**: V1 subblocks and old nonce key formats are rejected

Validators who want to build their own subblocks should provision a separate ECDSA key for the builder:
```solidity
// From builder ECDSA address:
SubblockRegistry.setBuilderConfig(feeRecipient, preferredFeeToken);
SubblockRegistry.registerRelayNode(relayNodeEd25519Pubkey);

// From validator address:
SubblockRegistry.delegateToBuilder(builderAddress);
```
