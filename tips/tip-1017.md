---
id: TIP-1017
title: Validator Config V2 precompile
description: Validator Config V2 precompile for improved management of consensus participants
authors: Janis (@superfluffy)
status: Draft
---

# ValidatorConfig V2

## Abstract

TIP-1017 introduces ValidatorConfig V2, a new precompile for managing consensus participants. ValidatorConfigV2 introduces clearer tracking for accurately reconstructing validator sets for any epoch, and extra safety checks on validator input values. Validator config v2 is designed with security in mind that would allow for permissionless validator rotation. 

## Motivation

V1 allowed the chain to switch validators between `active` and `inactive`, forcing nodes to retain historical account state for each epoch. Insufficient safety checks on precompile inputs also prevented validators from rotating permissionlessly, and this was permanently disabled on Tempo by setting the addresses of validators to unowned addresses. This TIP also introduces extra safety checks on validator inputs as an extra layer of security. 

# Specification

## Precompile Address
```solidity
address constant VALIDATOR_CONFIG_V2_ADDRESS = 0xCCCCCCCC00000000000000000000000000000001;
```

## Interface

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

/// @title IValidatorConfigV2 - Validator Config V2 Precompile Interface
/// @notice Interface for managing consensus validators with append-only, delete-once semantics
interface IValidatorConfigV2 {

    /// @notice Thrown when caller lacks authorization to perform the requested action
    error Unauthorized();

    /// @notice Thrown when trying to add a validator with an address that already exists
    error AddressAlreadyHasValidator();

    /// @notice Thrown when trying to add a validator with a public key that already exists
    error PublicKeyAlreadyExists();

    /// @notice Thrown when validator is not found
    error ValidatorNotFound();

    /// @notice Thrown when trying to delete a validator that is already deleted
    error ValidatorAlreadyDeleted();

    /// @notice Thrown when public key is invalid (zero)
    error InvalidPublicKey();

    /// @notice Thrown when validator address is invalid (zero)
    error InvalidValidatorAddress();

    /// @notice Thrown when the Ed25519 signature verification fails
    error InvalidSignature();

    /// @notice Thrown when V2 is not yet initialized (writes blocked before init)
    error NotInitialized();

    /// @notice Thrown when V2 is already initialized (migration blocked after init)
    error AlreadyInitialized();

    /// @notice Thrown when migration is not complete (not all V1 validators migrated)
    error MigrationNotComplete();

    /// @notice Thrown when migration index is out of order
    error InvalidMigrationIndex();

    /// @notice Thrown when address is not in valid ip:port format
    /// @param input The invalid input that was provided
    /// @param backtrace Additional error context
    error NotIpPort(string input, string backtrace);

    /// @notice Thrown when address is not a valid IP (for egress field)
    /// @param input The invalid input that was provided
    /// @param backtrace Additional error context
    error NotIp(string input, string backtrace);

    /// @notice Thrown when trying to use an ingress IP already in use by another active validator
    /// @param ingress The ingress address that is already in use
    error IngressAlreadyExists(string ingress);

    /// @notice Validator information (V2 - append-only, delete-once)
    /// @param publicKey Ed25519 communication public key (non-zero, unique across all validators)
    /// @param validatorAddress Ethereum-style address of the validator (unique among active validators)
    /// @param ingress Address where other validators can connect (format: `<ip>:<port>`)
    /// @param egress IP address from which this validator will dial, e.g. for firewall whitelisting (format: `<ip>`)
    /// @param index Position in validators array (assigned at creation, immutable)
    /// @param addedAtHeight Block height when validator was added
    /// @param deactivatedAtHeight Block height when validator was deleted (0 = active)
    struct Validator {
        bytes32 publicKey;
        address validatorAddress;
        string ingress;
        string egress;
        uint64 index;
        uint64 addedAtHeight;
        uint64 deactivatedAtHeight;
    }

    /// @notice Get all validators in array order starting from idx.
    /// @dev The getter checks remaining gas before doing storage reads to ensure it will not fail from out-of-gas.
    /// @param idx The index of validators to start reading from
    /// @return validators Array of validators with their information
    function getAllValidators(uint256 idx) external view returns (Validator[] memory validators);

    /// @notice Get only active validators (where deactivatedAtHeight == 0)
    /// @return validators Array of active validators
    function getActiveValidators() external view returns (Validator[] memory validators);

    /// @notice Get the owner of the precompile
    /// @return The owner address
    function owner() external view returns (address);

    /// @notice Get total number of validators ever added (including deleted)
    /// @return The count of validators
    function validatorCount() external view returns (uint64);

    /// @notice Get validator information by index in the validators array
    /// @param index The index in the validators array
    /// @return The validator struct at the given index
    function validatorByIndex(uint64 index) external view returns (Validator memory);

    /// @notice Get validator information by address
    /// @param validatorAddress The validator address to look up
    /// @return The validator struct for the given address
    function validatorByAddress(address validatorAddress) external view returns (Validator memory);

    /// @notice Get validator information by public key
    /// @param publicKey The validator's public key to look up
    /// @return The validator struct for the given public key
    function validatorByPublicKey(bytes32 publicKey) external view returns (Validator memory);

    /// @notice Get the epoch at which a fresh DKG ceremony will be triggered
    /// @return The epoch number, or 0 if no fresh DKG is scheduled.
    ///         The fresh DKG ceremony runs in epoch N, and epoch N+1 uses the new DKG polynomial.
    function getNextFullDkgCeremony() external view returns (uint64);

    /// @notice Add a new validator (owner only)
    /// @dev The signature must be an Ed25519 signature over:
    ///      keccak256(bytes8(chainId) || contractAddress || validatorAddress || ingress || egress)
    ///      using the namespace "TEMPO_VALIDATOR_CONFIG_V2_ADD_VALIDATOR".
    ///      This proves the caller controls the private key corresponding to publicKey.
    ///      Reverts if isInitialized() returns false.
    /// @param validatorAddress The address of the new validator
    /// @param publicKey The validator's Ed25519 communication public key
    /// @param ingress The validator's inbound address `<ip>:<port>` for incoming connections
    /// @param egress The validator's outbound IP address `<ip>` for firewall whitelisting
    /// @param signature Ed25519 signature (64 bytes) proving ownership of the public key
    function addValidator(
        address validatorAddress,
        bytes32 publicKey,
        string calldata ingress,
        string calldata egress,
        bytes calldata signature
    ) external;

    /// @notice Deactivates a validator (owner or validator only)
    /// @dev Marks the validator as deactivated by setting deactivatedAtHeight to the current block height.
    ///      The validator's entry remains in storage for historical queries.
    ///      The public key remains reserved and cannot be reused. The address remains
    ///      reserved unless reassigned via transferValidatorOwnership.
    /// @param validatorAddress The validator address to deactivate
    function deactivateValidator(address validatorAddress) external;

    /// @notice Rotate a validator to a new identity (owner or validator only)
    /// @dev Atomically deactivates the specified validator entry and appends a new one. The same validation rules for addValidator also applies to rotateValidator.
    /// @param validatorAddress The address of the validator to rotate
    /// @param publicKey The new validator's Ed25519 communication public key
    /// @param ingress The new validator's inbound address `<ip>:<port>` for incoming connections
    /// @param egress The new validator's outbound IP address `<ip>` for firewall whitelisting
    /// @param signature Ed25519 signature (64 bytes) proving ownership of the new public key
    function rotateValidator(
        address validatorAddress,
        bytes32 publicKey,
        string calldata ingress,
        string calldata egress,
        bytes calldata signature
    ) external;

    /// @notice Update a validator's IP addresses (owner or validator only)
    /// @dev Can be called by the contract owner or by the validator's own address.
    ///      This allows validators to update their network addresses without requiring
    ///      a full rotation.
    /// @param validatorAddress The address of the validator to update
    /// @param ingress The new inbound address `<ip>:<port>` for incoming connections
    /// @param egress The new outbound IP address `<ip>` for firewall whitelisting
    function setIpAddresses(
        address validatorAddress,
        string calldata ingress,
        string calldata egress
    ) external;

    /// @notice Transfer a validator entry to a new address (owner or validator only)
    /// @dev Can be called by the contract owner or by the validator's own address.
    ///      Updates the validator's address in the lookup maps.
    ///      Reverts if the new address already exists in the validator set.
    /// @param currentAddress The current address of the validator to transfer
    /// @param newAddress The new address to assign to the validator
    function transferValidatorOwnership(address currentAddress, address newAddress) external;

    /// @notice Transfer owner of the contract (owner only)
    /// @param newOwner The new owner address
    function transferOwnership(address newOwner) external;

    /// @notice Set the epoch at which a fresh DKG ceremony will be triggered (owner only)
    /// @param epoch The epoch in which to run the fresh DKG ceremony.
    ///        Epoch N runs the ceremony, and epoch N+1 uses the new DKG polynomial.
    function setNextFullDkgCeremony(uint64 epoch) external;

    /// @notice Migrate a single validator at `idx` from V1 to V2 (owner only)
    /// @param idx Index of the validator in V1 validators array (must equal current validatorsArray.length)
    function migrateValidator(uint64 idx) external;

    /// @notice Initialize V2 and enable reads (owner only)
    /// @dev Should only be called after all validators have been migrated via migrateValidator.
    function initializeIfMigrated() external;

    /// @notice Check if V2 has been initialized from V1
    /// @return True if initialized, false otherwise
    function isInitialized() external view returns (bool);

    /// @notice Get the height at which the contract was initialized
    /// @return the height at which the contract was initialized. Note that this
    ///         value only makes sense in conjunction with isInitialized()
    function getInitializedAtHeight() external view returns (uint64);
}
```

## Changes From V1

### Validator Lifecycle

Validators in V2 follow a fixed lifecycle:
1. **Addition**: Either from `addValidator` or `migrateValidator` from V1. This creates a permanent validator entry with `addedAtHeight` set to the current block height and `deactivatedAtHeight = 0`.
2. **Active period**: Validator participates in consensus while `deactivatedAtHeight == 0`.
3. **Deactivation**: Either `deactivateValidator` or `rotateValidator` sets `deactivatedAtHeight` for that validator entry to the current block height.

Note that once `addedAtHeight` or `deactivatedAtHeight` for a validator entry is set, it cannot be set again any way. After deactivation, the validator entry will stay in storage forever.

### New V2 Safety Checks

Validator config V2 introduces additional safety checks on validator inputs over validator config V1:
1. Validator ed25519 public keys must be unique across all validators (active + inactive).
2. Validator addresses must be unique across active validators. Duplication in the set of inactive validators is allowed.
3. The ingress (previously "inbound") must be a valid IP with port (<ip>:<port>), and the IP must be unique across all active validators.
4. The egress (previously "outbound") must be a valid IP.
5. A signature must be provided over the parameters of `addValidator` or `rotateValidator` from the ed25519 key to be added. This is an anti-footgun mechanism to prevent accidentally adding the wrong key. The signature format is detailed below
6. Each validator maintains a constant `idx` value in the validator array. In V1, we used `validatorAddress` for update and delete operations, which allowed validators to front-run the call to prevent themselves from being updated or deleted by the owner. 

### Ed25519 Signature Verification on Adding a New Validator

When adding a validator, the caller must provide an Ed25519 signature proving ownership of the public key. The signature is checked over a full message containing: the length of the namespace in bytes, the namespace, and a 32-byte hashed message.

**Namespace:** `addValidator` uses `b"TEMPO_VALIDATOR_CONFIG_V2_ADD_VALIDATOR"` and `rotateValidator` uses `b"TEMPO_VALIDATOR_CONFIG_V2_ROTATE_VALIDATOR"`.

**Message:**
```
message = keccak256(
    bytes8(chainId)       // uint64: Prevents cross-chain replay
    || contractAddress    // address: Prevents cross-contract replay
    || validatorAddress   // address: Binds to specific validator address
    || ingress            // string: Binds network configuration
    || egress             // string: Binds network configuration
)
```

The Ed25519 signature is computed over the message using the namespace parameter (see commonware's [signing scheme](https://github.com/commonwarexyz/monorepo/blob/abb883b4a8b42b362d4003b510bd644361eb3953/cryptography/src/ed25519/scheme.rs#L38-L40) and [union format](https://github.com/commonwarexyz/monorepo/blob/abb883b4a8b42b362d4003b510bd644361eb3953/utils/src/lib.rs#L166-L174)).

### TODO: Consensus Layer Usage
<!-- 
**IP Address Changes**: When a validator's IP address changes via `setIpAddresses`, the consensus layer is expected to update its peer list on the next finalized block.

**Validator Addition and Deactivation**: When validators are added or deleted (this also applies to rotation),
there is no warmup period: deactivated validators are immediately removed from the set of players on the next epoch,
while activated validators are immediately added on the next epoch. This means that compared to validator config V1,
there is no cooldown and no warmup period.

**DKG Player Selection**: The consensus layer determines DKG players for epoch `E+1` by reading state at `boundary(E)` and filtering:

```
players(E+1) = validators.filter(v =>
    v.addedAtHeight <= boundary(E) &&
    (v.deactivatedAtHeight == 0 || v.deactivatedAtHeight > boundary(E))
)
```

This enables nodes to reconstruct DKG player sets without accessing historical account stateâ€”critical for node recovery and late-joining validators.

### CL Read Behavior

The CL checks `v2.isInitialized()` to determine which contract to read:

- **`initialized == false`**: CL reads from V1
- **`initialized == true`**: CL reads from V2

This is handled entirely in the CL logic, not in the V2 precompile. The V2
precompile does NOT proxy reads to V1. -->

## Migration

If validator config V2 is to be used in a new network without V1, `initializeIfMigrated` can be called immediately (with zero V1 validators) to skip migration.

Validator migration must be carefully designed and executed to prevent footguns that could cause consensus to break down, triggering a chain halt. Due to the high gas costs of `SSTORE` imposed by TIP-1000, migration is performed manually and validator-by-validator to ensure that there is no risk of too many validators causing the migration transaction to fail from out-of-gas. 

### Migration Process

1. At the hardfork timestamp or block number, validator config V2 becomes active on the network. The consensus layer still continues to read from validator config V1 during this time.
2. The owner calls `migrateValidator(0)`. The first call copies the `owner` from validator config V1 over to validator config V2.
3. The owner continues and calls `migrateValidator(idx)` for `1...n` where `n` is the total number of validators in validator config V1.
4. During this migration, if a validator goes offline, the owner is able to deactivate the validator in both the V1 and V2 contracts.
5. When all validator entries have been copied over, the owner calls `initializeIfMigrated()` which checks that all validators have been migrated over. It sets `initialized` to true which signals to the CL to start reading from validator config V2 instead of V1.
6. The owner collects addresses from each validator and calls `transferValidatorOwnership` for each entry to enable permissionless rotation.

### Permitted Calls to V2 during migration

The owner is able to call: `deactivateValidator`, `transferOwnership`, `setIpAddresses`, `migrateValidator` and `initializeIfMigrated`. `migrateValidator` and `initializeIfMigrated` cannot be called once the contract is initialized.

In theory, validators can call `deactivateValidator` and `setIpAddresses`, but because the addresses are unowned on Tempo, they are unable to do so.

### Permitted Calls to V1 during migration

All calls are allowed to V1 during migration (after the hardfork timestamp). Note that since validator addresses are unowned, validators are unable to call any function on V1.

# Security

## Considerations

- **Migration timing**: Migration must be completed (including `initializeIfMigrated()`) before an epoch boundary to avoid disrupting DKG. The admin should schedule migration during a period with sufficient time buffer before the next epoch transition.

## Test Cases

The test suite should cover the following categories:

### Happy Paths

Each mutating function (`addValidator`, `deactivateValidator`, `rotateValidator`, `setIpAddresses`, `transferValidatorOwnership`, `transferOwnership`, `setNextFullDkgCeremony`, `migrateValidator`, `initializeIfMigrated`) succeeds when called by an authorized caller with valid inputs.

### Authorization

- **Owner-only**: `addValidator`, `transferOwnership`, `migrateValidator`, `initializeIfMigrated`, `setNextFullDkgCeremony` revert with `Unauthorized` for non-owner callers.
- **Owner or validator**: `rotateValidator`, `deactivateValidator`, `setIpAddresses`, `transferValidatorOwnership` revert with `Unauthorized` for callers that are neither the owner nor the validator.
- **Pre-initialization**: `addValidator`, `rotateValidator`, `transferValidatorOwnership` revert with `NotInitialized` before `initializeIfMigrated()` is called. `deactivateValidator` and `setIpAddresses` are allowed before initialization.

### Uniqueness and Validation

- **Public key uniqueness**: `addValidator` and `rotateValidator` revert with `PublicKeyAlreadyExists` if the key is already used by any validator (active or inactive).
- **Address uniqueness**: `addValidator` reverts with `AddressAlreadyHasValidator` if the address belongs to an active validator. Reuse of deactivated addresses is allowed.
- **Ingress IP uniqueness**: `addValidator`, `rotateValidator`, and `setIpAddresses` revert with `IngressAlreadyExists` if the ingress IP is already in use by another active validator (even with a different port).
- **Input validation**: Zero public keys revert with `InvalidPublicKey`. Zero addresses revert with `InvalidValidatorAddress`. Invalid ingress format reverts with `NotIpPort`. Invalid egress format reverts with `NotIp`.
- **Signature verification**: `addValidator` and `rotateValidator` revert with `InvalidSignature` for wrong signatures, wrong length, or wrong signer.

### State Transitions

- **Deactivation is permanent**: `deactivateValidator` on an already-deactivated validator reverts with `ValidatorAlreadyDeleted`. Once `deactivatedAtHeight` is set, it cannot change.
- **Rotation is atomic**: `rotateValidator` deactivates the old entry and appends a new entry in the same transaction. The new entry gets the next available index.
- **Non-existent validators**: Operations on non-existent validators revert with `ValidatorNotFound`.

### Migration

- **Sequential migration**: `migrateValidator(idx)` reverts with `InvalidMigrationIndex` if `idx != validatorsArray.length`.
- **Migration blocked after init**: `migrateValidator` reverts with `AlreadyInitialized` after `initializeIfMigrated()`.
- **Init blocked if incomplete**: `initializeIfMigrated()` reverts with `MigrationNotComplete` if not all V1 validators have been migrated.
- **State copied correctly**: Migrated validators preserve public key, address, ingress, and egress from V1. Active V1 validators get `deactivatedAtHeight == 0`; inactive ones get `addedAtHeight == deactivatedAtHeight`. Owner and `nextDkgCeremony` are copied from V1.

## Invariants

1. **Append-only array**: `validatorsArray` length only increases; it never decreases.
2. **Immutable identity**: Once added, a validator's `publicKey`, `index`, and `addedAtHeight` never change. `ingress` and `egress` can be updated via `setIpAddresses`. `validatorAddress` can be changed via `transferValidatorOwnership`.
3. **Delete-once**: `deactivatedAtHeight` can only transition from 0 to a non-zero value, never back.
4. **Unique active addresses**: No two active validators share the same `validatorAddress`. Deactivated addresses may be reused.
5. **Unique public keys**: No two validators (including deactivated) share the same `publicKey`.
6. **Non-zero public keys**: All validators have a non-zero `publicKey`.
7. **Monotonic index**: Validator `index` equals its position in `validatorsArray`.
8. **Historical consistency**: For any height H, the active set is `{ v | v.addedAtHeight <= H && (v.deactivatedAtHeight == 0 || v.deactivatedAtHeight > H) }`. Validators with `addedAtHeight == deactivatedAtHeight` are never active.
9. **Signature binding**: The signature message includes `chainId`, `contractAddress`, `validatorAddress`, `ingress`, and `egress`, preventing cross-chain, cross-contract, and parameter replay.
10. **Initialized once**: The `initialized` flag can only transition from false to true, never back.
11. **Atomic rotation**: `rotateValidator` deactivates the old entry and appends a new entry in the same block height.