---
id: TIP-1017
title: Subblocks v2 - Builder Delegation
description: Separates subblock builder identity from validator identity with many-to-one delegation, ECDSA signing, builder p2p key registration, and expiring nonce support.
authors: Mallesh Pai
status: Draft
related: Subblock Specification, TIP-1009
protocolVersion: TBD
---

# TIP-1017: Subblocks v2 - Builder Delegation

## Abstract

This TIP introduces major changes to the subblock system:

1. **Builder Delegation**: Validators delegate subblock production to a builder identified by an ECDSA address (secp256k1). Multiple validators can delegate to the same builder, who accumulates their combined gas budget.

2. **Separate Signing Identity**: Builders sign subblocks with their own ECDSA key, separate from the validator's consensus key. Multiple physical machines share this ECDSA key (via HSM/KMS) for high availability.

3. **Builder P2P Keys**: Each physical builder machine has its own ed25519 key used exclusively for commonware p2p authentication. Builder p2p keys are registered under a builder in the SubblockRegistry (max 4 per builder).

4. **Nonce Key Format**: The nonce key format changes to `0x5b | builder_address | nonce`, embedding the builder's 20-byte ECDSA address directly in the transaction.

5. **Expiring Nonces in Subblocks**: Subblock transactions can use expiring nonces by setting the nonce portion to all 1s (`0xFFFF...`).

## Motivation

The current subblock design has several limitations:

1. **Validator coupling**: The validator's consensus key must also sign subblocks, meaning validators cannot delegate subblock production to separate infrastructure without sharing their consensus key.

2. **One-to-one only**: Each validator must run their own subblock builder; there is no way to delegate to a shared builder.

3. **No expiring nonces**: Subblock transactions require sequential 2D nonces, preventing use of expiring nonces (TIP-1009).

4. **No high availability**: A single builder machine failure takes down subblock production for that validator. There is no mechanism for multiple machines to operate under a shared identity.

This TIP addresses these issues by:

- Allowing validators to delegate to builders identified by ECDSA address
- Supporting many-to-one delegation where multiple validators share a builder
- Using the builder's own ECDSA key for subblock signing (separate from consensus key)
- Supporting multiple physical machines per builder via registered p2p keys (ed25519 for p2p auth, shared ECDSA key for signing)
- Enabling expiring nonces within subblock transactions

---

# Specification

## 1. Subblock Registry

A new Subblock Registry precompile stores builder configurations, validator delegations, and builder p2p key registrations.

### 1.1 Data Structures

```solidity
struct BuilderConfig {
    address feeRecipient;  // where subblock fees are sent
    address feeToken;      // preferred TIP-20 token for fee payment
}
```

**Note on fee token**: The builder's fee token is stored in `SubblockRegistry`, separate from `TipFeeManager.validatorTokens`. This allows:
- **Subblock fees** (for txs in builder's subblocks): `SubblockRegistry.configOf(builder).feeToken`
- **Proposer fees** (when validator is block proposer): `TipFeeManager.validatorTokens[validator]`

When processing fees for a subblock transaction:
1. Resolve the user's fee token using standard Tempo resolution (tx preference → user preference → inference → PathUSD)
2. Extract `builder_address` from nonce key (bytes 1-20)
3. Look up `config = SubblockRegistry.configOf(builder)`
4. If registered and `config.feeToken` differs, attempt to swap via Fee AMM if liquidity available
5. If no liquidity or unregistered, fees are paid directly in the user's resolved fee token
6. Fees are sent to `config.feeRecipient`

### 1.2 Storage

```solidity
// Validator → builder they delegate to (zero = not delegated)
mapping(address => address) public delegatedBuilder;

// Builder address → their configuration
mapping(address => BuilderConfig) public builderConfig;

// Builder address → number of validators delegating to them (gas weight)
mapping(address => uint256) public gasWeight;

// Builder address → registered p2p ed25519 pubkeys (max 4)
mapping(address => bytes32[]) public p2pKeys;

// P2P ed25519 pubkey → owning builder address (reverse lookup)
mapping(bytes32 => address) public p2pKeyOwner;
```

### 1.3 Interface

```solidity
interface ISubblockRegistry {
    // ========== Validator Functions ==========

    /// @notice Delegates the caller's subblock production to a builder.
    /// @param builder The builder's ECDSA address.
    /// @dev Only callable by validators in the ValidatorConfig set.
    /// @dev Clears any existing delegation first (atomically updates gasWeight).
    /// @dev Increments the builder's gasWeight.
    /// @dev Requires builderConfig[builder].feeRecipient != address(0).
    function delegateToBuilder(address builder) external;

    /// @notice Clears the caller's delegation.
    /// @dev Only callable by validators with an existing delegation.
    /// @dev Decrements the previous builder's gasWeight.
    function clearDelegation() external;

    // ========== Builder Functions ==========

    /// @notice Sets the caller's builder configuration.
    /// @param feeRecipient Where subblock fees are sent. Must be non-zero.
    /// @param feeToken Preferred TIP-20 token for fee payment. Zero means no swap.
    /// @dev The caller (msg.sender) is the builder. No signature needed.
    function setBuilderConfig(address feeRecipient, address feeToken) external;

    /// @notice Clears the caller's builder configuration.
    /// @dev Force-clears ALL delegations pointing to this builder.
    /// @dev Decrements gasWeight to zero.
    /// @dev Removes all registered p2p keys.
    function clearBuilderConfig() external;

    /// @notice Registers an ed25519 p2p key under the caller's builder identity.
    /// @param p2pPubkey The ed25519 public key for commonware p2p authentication.
    /// @dev Max 4 p2p keys per builder. Reverts if limit exceeded.
    /// @dev Reverts if p2pPubkey is already registered to any builder.
    /// @dev Requires caller to have an active BuilderConfig.
    function registerP2pKey(bytes32 p2pPubkey) external;

    /// @notice Removes an ed25519 p2p key from the caller's builder identity.
    /// @param p2pPubkey The ed25519 public key to remove.
    /// @dev Reverts if p2pPubkey is not registered to the caller.
    function removeP2pKey(bytes32 p2pPubkey) external;

    // ========== View Functions ==========

    /// @notice Returns the builder a validator has delegated to.
    /// @param validator The validator address.
    /// @return The builder's ECDSA address, or zero if not delegated.
    function builderOf(address validator) external view returns (address);

    /// @notice Returns a builder's configuration.
    /// @param builder The builder's ECDSA address.
    /// @return The BuilderConfig struct (zero values if not configured).
    function configOf(address builder) external view returns (BuilderConfig memory);

    /// @notice Returns a builder's fee recipient.
    /// @param builder The builder's ECDSA address.
    /// @return The fee recipient, or zero if not configured.
    function feeRecipientFor(address builder) external view returns (address);

    /// @notice Returns a builder's preferred fee token.
    /// @param builder The builder's ECDSA address.
    /// @return The TIP-20 token address, or zero if not configured.
    function feeTokenFor(address builder) external view returns (address);

    /// @notice Returns a builder's gas weight (number of delegating validators).
    /// @param builder The builder's ECDSA address.
    /// @return The gas weight.
    function gasWeightOf(address builder) external view returns (uint256);

    /// @notice Returns the p2p keys registered to a builder.
    /// @param builder The builder's ECDSA address.
    /// @return Array of ed25519 public keys.
    function p2pKeysOf(address builder) external view returns (bytes32[] memory);

    /// @notice Returns the builder that owns a p2p key.
    /// @param p2pPubkey The ed25519 public key.
    /// @return The builder's ECDSA address, or zero if not registered.
    function builderOfP2pKey(bytes32 p2pPubkey) external view returns (address);
}
```

### 1.4 Behavior

**Registry state snapshot:** All registry lookups (gasWeight, feeRecipient, p2p key ownership) during subblock validation and execution use the **post-state of the parent block**. Mutations within the current block do not affect that block's subblock validity or fee routing.

**Delegation:**
- Only addresses in the `ValidatorConfig` validator set can call `delegateToBuilder()`
- The SubblockRegistry verifies the caller is a validator by querying `ValidatorConfig`: a non-zero `publicKey` for the caller's address confirms membership
- When delegating, any existing delegation is cleared first (atomically updates gasWeight)
- On-chain delegation changes take effect immediately in the next block

**Builder configuration:**
- `setBuilderConfig()` is called by the builder directly (`msg.sender` is the builder's ECDSA address). No signature argument is needed since the transaction itself proves ownership.
- `feeRecipient` MUST be non-zero before validators can delegate to a builder
- If `feeToken` is zero, no swap is attempted (user's token is used)

**Clearing builder config:**
- `clearBuilderConfig()` force-clears ALL delegations pointing to the calling builder
- `gasWeight` is decremented to zero
- All registered p2p keys are removed
- This prevents orphaned delegations pointing to a non-existent builder

**P2P keys:**
- Each builder can register up to 4 ed25519 p2p keys (one per physical machine)
- `registerP2pKey()` reverts if the key is already registered to any builder
- `registerP2pKey()` requires the caller to have an active `BuilderConfig`
- `removeP2pKey()` reverts if the key is not owned by the caller

**Gas weight:**
- `gasWeight[builder]` is the count of validators currently delegating to that builder
- Incremented when a validator calls `delegateToBuilder(builder)`
- Decremented when a validator calls `clearDelegation()` or delegates to a different builder
- Used to compute the builder's total gas budget

**Validator set changes:**
- The subblock builder is separate infrastructure from the validator node. A validator being temporarily "down" or offline does NOT affect their builder's ability to produce subblocks.
- `gasWeight[builder]` always reflects the number of validators **in the set** delegating to that builder
- When a validator is **removed from ValidatorConfig** (exits the validator set):
  - Their delegation MUST be cleared
  - `gasWeight` for their builder is decremented
  - This can be done lazily (during next delegation change) or eagerly (via callback from ValidatorConfig)
- This ensures gas budgets accurately reflect the current validator set

### 1.5 Precompile Address

```
SUBBLOCK_REGISTRY_ADDRESS = 0x0b10c0000000000000000000000000000000000X  // TBD
```

### 1.6 Relationship to ValidatorConfig

The SubblockRegistry is a **separate precompile** from ValidatorConfig but **depends on it** for validator set membership:

```
┌─────────────────────┐         ┌─────────────────────┐
│   ValidatorConfig   │◄────────│   SubblockRegistry  │
│                     │  reads  │                     │
│  (validator set)    │         │ - delegatedBuilder  │
│                     │         │ - builderConfig     │
│                     │         │ - gasWeight         │
│                     │         │ - p2pKeys           │
└─────────────────────┘         └─────────────────────┘
     Source of truth              Builder delegation
     for validator set            and p2p key config
```

- ValidatorConfig defines **who is in the validator set** (used for consensus)
- SubblockRegistry tracks **builder delegations and p2p keys** (separate from consensus)

### 1.7 P2P Peer Set

Builder p2p keys whose owning builder has `gasWeight[builderOfP2pKey(p2pPubkey)] > 0` are included in the epoch-authorized peer set alongside validators. The DKG Manager reads active builder p2p keys from SubblockRegistry and adds them to the commonware p2p oracle, allowing builder machines to join the authenticated network.

**Key distinction:**
- Builder p2p keys (ed25519) are authorized for **subblock delivery only**, not consensus participation
- P2P peer set updates occur at **epoch boundaries**, not per-block
- The DKG Manager snapshots the builder p2p key set at the start of each epoch

---

## 2. Nonce Key Format

### 2.1 Subblock Nonce Key

Subblock transactions use the following nonce key format (big-endian, byte 0 = MSB, matching `U256::to_be_bytes()`):

```
32 bytes total:
┌──────────────────┬──────────────────────────────────┬─────────────────────┐
│ 0x5b (1 byte)    │ builder_address (20 bytes)        │ nonce (11 bytes)    │
├──────────────────┼──────────────────────────────────┼─────────────────────┤
│ byte 0 (MSB)     │ bytes 1-20                       │ bytes 21-31 (LSB)   │
└──────────────────┴──────────────────────────────────┴─────────────────────┘
```

- **Byte 0 (MSB)**: `0x5b` prefix identifying this as a subblock transaction
- **Bytes 1-20**: Builder's 20-byte ECDSA address
- **Bytes 21-31**: 11-byte nonce value (2^88 possible values)

### 2.2 V1 vs V2 Nonce Key Discrimination

Both V1 and V2 nonce keys use the `0x5b` prefix. The version is determined by **fork activation height**, not by the nonce key format:

| Version | Bytes 1-15 | Bytes 16-20 | Bytes 21-31 |
|---------|------------|-------------|-------------|
| V1 | PartialValidatorKey (15 bytes) | nonce high bytes | nonce low bytes |
| V2 | builder_address[0..15] | builder_address[15..20] | nonce (11 bytes) |

Before activation height: V1 interpretation. After activation height: V2 interpretation.

### 2.3 Nonce Key Construction

```
nonceKey = (0x5b << 248) | (builder_address << 88) | nonce
```

### 2.4 Builder Extraction

```
builder_address = address(nonceKey[1..21])  // 20 bytes
```

The extracted address is verified against the `builder` field in the SubBlock/SubBlockMetadata.

### 2.5 Nonce Extraction

```solidity
function extractNonce(uint256 nonceKey) pure returns (uint88) {
    return uint88(nonceKey);
}
```

### 2.6 Subblock Transaction Detection

```solidity
function isSubblockTx(uint256 nonceKey) pure returns (bool) {
    return uint8(nonceKey >> 248) == 0x5b;
}
```

---

## 3. Expiring Nonces in Subblocks

### 3.1 Motivation

TIP-1009 introduced expiring nonces for parallel transaction submission without sequential ordering. This TIP extends that support to subblock transactions.

### 3.2 Detection

A subblock transaction uses expiring nonce semantics if:
1. The nonce key has `0x5b` prefix (byte 0)
2. The nonce portion (bytes 21-31) is all 1s: `0xFFFFFFFFFFFFFFFFFFFFFF` (max uint88, 11 bytes)

```solidity
uint88 constant EXPIRING_NONCE_MARKER = type(uint88).max;  // 0xFFFFFFFFFFFFFFFFFFFFFF

function isSubblockExpiringNonce(uint256 nonceKey) pure returns (bool) {
    return isSubblockTx(nonceKey) && extractNonce(nonceKey) == EXPIRING_NONCE_MARKER;
}
```

### 3.3 Nonce Key Format (Expiring)

```
32 bytes total:
┌──────────────────┬──────────────────────────────────┬─────────────────────┐
│ 0x5b (1 byte)    │ builder_address (20 bytes)        │ 0xFFF...FF (11 bytes)│
├──────────────────┼──────────────────────────────────┼─────────────────────┤
│ byte 0 (MSB)     │ bytes 1-20                       │ bytes 21-31 = max   │
└──────────────────┴──────────────────────────────────┴─────────────────────┘
```

### 3.4 Replay Protection

Subblock expiring nonce transactions follow TIP-1009 semantics:
- `validBefore` field is required
- `nonce` field must be `0`
- Replay protection via transaction hash + **same circular buffer** as TIP-1009
- Same validity window (30 seconds max)

The only difference from standard expiring nonces is the nonce key format, which routes the transaction to a specific builder. The replay protection shares the same `expiringNonceSeen` and `expiringNonceRing` storage as regular expiring nonces — no separate buffer is needed since the transaction hash is globally unique.

### 3.5 Nonce Key Construction (Expiring)

```
expiringNonceKey = (0x5b << 248) | (builder_address << 88) | EXPIRING_NONCE_MARKER
```

---

## 4. Signed Subblock Structure

### 4.1 SubBlock

```rust
struct SubBlock {
    version: SubBlockVersion,    // V2 for this spec
    parent_hash: B256,           // Block hash this subblock builds on
    builder: Address,            // Builder's ECDSA address
    chain_id: u64,               // Chain ID for cross-chain replay protection
    transactions: Vec<Transaction>,
}
```

### 4.2 SignedSubBlock

```rust
struct SignedSubBlock {
    subblock: SubBlock,
    signature: Bytes,  // ECDSA signature (65 bytes: r, s, v)
}
```

### 4.3 Signature Computation

```
signature_hash = keccak256(0x78 || RLP(subblock))
signature = ecdsa_sign(builder_private_key, signature_hash)
```

### 4.4 Signature Verification

```
hash = keccak256(0x78 || RLP(subblock))
recovered_address = ecrecover(hash, signature)
valid = (recovered_address == subblock.builder)
```

### 4.5 Version

This TIP introduces `SubBlockVersion::V2`. Nodes MUST reject V1 subblocks after activation.

---

## 5. Subblock Metadata

### 5.1 SubBlockMetadata

The proposer includes metadata about included subblocks in a system transaction:

```rust
struct SubBlockMetadataEntry {
    version: SubBlockVersion,   // V2
    builder: Address,           // Builder's ECDSA address
    fee_recipient: Address,     // Resolved from registry at parent block post-state
    tx_start_index: u32,        // Index of first tx in block
    tx_count: u32,              // Number of transactions
    signature: Bytes,           // ECDSA signature (65 bytes: r, s, v)
}

struct SubBlockMetadata {
    entries: Vec<SubBlockMetadataEntry>,
}
```

**Note:** `fee_recipient` is resolved from `SubblockRegistry.configOf(builder).feeRecipient` using the parent block's post-state and embedded in the metadata. This ensures all nodes use the same fee recipient without re-querying the registry during execution.

### 5.2 Metadata Validation

During block execution, the SubBlockMetadata system transaction is processed:

1. For each entry:
   a. Recover the signer from the ECDSA signature via `ecrecover` and verify it matches `entry.builder`
   b. Verify transactions in range have nonce key prefix matching `entry.builder` address
   c. Verify `gasWeight[builder] > 0` at parent block post-state (at least one validator in the set delegates to this builder)

2. Verify ranges are non-overlapping and within block bounds

### 5.3 Gas Budget Enforcement

Each builder's subblock is limited by their accumulated gas budget:

```
per_validator_gas = (block_gas_limit / TEMPO_SHARED_GAS_DIVISOR) / num_validators
builder_gas_budget = per_validator_gas × gasWeight[builder]
```

The metadata includes the `builder` address. During validation:
1. Look up `gasWeight[builder]` from SubblockRegistry at parent block post-state
2. Compute builder's gas budget as `per_validator_gas × gasWeight`
3. Verify subblock's total gas usage does not exceed budget

---

## 6. Fee Routing

### 6.1 Fee Recipient Resolution

For subblock transactions (nonce key has `0x5b` prefix):

1. Extract `builder_address` from nonce key (bytes 1-20)
2. Use `fee_recipient` from SubBlockMetadata entry (pre-resolved from registry at parent block post-state)
3. If `fee_recipient` is zero (builder config cleared between parent and current block), fees go to the block proposer

### 6.2 Fee Token Resolution

The user's fee token is resolved using standard Tempo resolution:
1. Transaction's explicit `fee_token` field (if set)
2. User's default fee token preference (from user config)
3. Inference from transaction context
4. PathUSD (default)

### 6.3 Fee Token Swap

If `user_fee_token != builder_fee_token` and the builder has a token preference:
- If sufficient AMM liquidity exists, swap to `builder_fee_token`
- If insufficient liquidity, the fee recipient receives `user_fee_token` directly

The transaction is **never invalidated** due to missing AMM liquidity.

### 6.4 Fee Failure

If a subblock transaction cannot pay fees (e.g., user emptied their account in the main block), the transaction becomes a **noop** but the **nonce is still incremented**. The block remains valid. This matches V1 behavior.

---

## 7. Transaction Routing

### 7.1 Builder Endpoint

Builders MUST expose an RPC endpoint for receiving subblock transactions from users. Users submit transactions to the builder whose address matches their nonce key.

### 7.2 Subblock Delivery via P2P

Builder machines join the authenticated commonware p2p network using their ed25519 p2p keys. They send signed subblocks (signed with the builder's shared ECDSA key) directly to the next proposer via p2p, the same mechanism used in V1.

The proposer stores received subblocks and selects them for inclusion during block building.

### 7.3 Builder P2P Authorization

Builder p2p keys whose owning builder has `gasWeight > 0` are added to the epoch-authorized peer set. When a builder's `gasWeight` drops to zero (all validators undelegated), their p2p keys are removed from the authorized set at the next epoch boundary.

Builder p2p keys are authorized for **subblock delivery only**, not consensus participation.

### 7.4 High Availability Architecture

Multiple physical machines operate under a single builder identity:
- All machines share the same builder ECDSA key (via HSM/KMS) for subblock signing
- Each machine has its own ed25519 p2p key registered in the SubblockRegistry
- A load balancer fans out every incoming transaction to all builder machines
- Each machine independently builds subblocks; the proposer deduplicates by selecting the best one

---

## 8. End-to-End Flow

### 8.1 Setup (Once per Builder)

```
1. Builder generates an ECDSA keypair (secp256k1)
2. Builder calls SubblockRegistry.setBuilderConfig(feeRecipient, feeToken)
   (called from builder's ECDSA address, no signature arg needed)
3. For each physical machine:
   a. Generate an ed25519 keypair for p2p identity
   b. Builder calls SubblockRegistry.registerP2pKey(p2pPubkey)
   c. Start commonware p2p node with the machine's ed25519 key
```

### 8.2 Setup (Once per Validator)

```
1. Validator selects a builder to delegate to (by ECDSA address)
2. Validator calls SubblockRegistry.delegateToBuilder(builderAddress)
3. Registry increments builder's gasWeight
```

### 8.3 Transaction Creation (User)

```
1. User selects a builder by ECDSA address
2. User constructs nonce key: 0x5b | builder_address | nonce
   - For sequential: nonce = next available value
   - For expiring: nonce = 0xFFF...FF (max uint88)
3. User signs transaction with ROOT EOA key (no keychain)
4. User submits transaction to builder's RPC endpoint
```

### 8.4 Subblock Building (Builder)

```
1. Builder collects transactions matching their address in nonce key
2. Builder validates each transaction (nonce, balance, execution)
3. Builder orders transactions, respects gas budget
4. Builder creates SubBlock with parent_hash = current chain tip, chain_id
5. Builder signs with ECDSA (shared key) → SignedSubBlock
6. Builder machine sends to next proposer via commonware p2p
```

### 8.5 Block Building (Proposer)

```
1. Proposer receives SignedSubBlocks from builder machines via p2p
2. For each subblock (using parent block post-state for all lookups):
   a. Recover signer via ecrecover, verify matches subblock.builder
   b. Verify chain_id matches
   c. Verify all txs have nonce key builder_address matching subblock.builder
   d. Verify parent_hash matches current tip
   e. Verify gasWeight[builder] > 0
   f. Compute builder's gas budget from gasWeight
   g. Verify total gas does not exceed budget
   h. Execute transactions, verify validity
3. Select valid subblocks (see Section 10.3 for conflict resolution)
4. Resolve fee_recipient for each builder from registry at parent post-state
5. Build SubBlockMetadata with version, builder, fee_recipient, tx_start_index,
   tx_count, and signature for each
6. Append SubBlockMetadata system transaction at end of block
```

### 8.6 Block Execution (All Nodes)

```
1. Execute block transactions in order
2. For each 0x5b transaction:
   a. Extract builder_address from nonce key (bytes 1-20)
   b. Determine if expiring nonce (nonce = max uint88)
   c. If expiring: use TIP-1009 replay protection
   d. Else: use 2D nonce semantics
   e. Use fee_recipient from SubBlockMetadata entry
   f. Deduct fees, credit to fee recipient
3. Process SubBlockMetadata system transaction:
   a. Verify ECDSA signatures via ecrecover for each entry
   b. Verify tx ranges match actual transactions
   c. If any verification fails, block is invalid
```

---

## 9. Gas Accounting

### 9.1 Per-Validator Gas Budget

Gas budgets are computed per-validator:

```
shared_gas_limit = block_gas_limit / TEMPO_SHARED_GAS_DIVISOR
per_validator_gas = shared_gas_limit / num_validators
```

### 9.2 Builder Gas Budget

A builder's gas budget is the sum of per-validator gas for all validators in the set delegating to them:

```
builder_gas_budget = per_validator_gas × gasWeight[builder]
```

Since delegations are cleaned up when validators leave the set (see Section 1.4), `gasWeight` accurately reflects the builder's current gas allocation.

### 9.3 Gas Incentive Lane

Unused gas from subblocks becomes available for the gas incentive lane:

```
incentive_gas = Σ (per_validator_gas - subblock_gas_used)
```

The gas incentive lane is **only available to the proposer if they include subblocks**. This creates a direct incentive for proposers to include subblocks: if a proposer omits subblocks, they forfeit access to the incentive gas pool.

---

## 10. Subblock Lifecycle

### 10.1 Subblock Validity

A signed subblock is valid only if (all lookups at parent block post-state):
- `parent_hash` matches the current chain tip
- `chain_id` matches the chain's ID
- The ECDSA signature recovers to `subblock.builder` via `ecrecover`
- `gasWeight[builder] > 0` (at least one validator in the set delegates to this builder)
- All transactions have nonce key prefix `0x5b` with `builder_address` matching `subblock.builder`
- Total gas does not exceed the builder's computed gas budget

### 10.2 Subblock Expiry

Subblocks expire immediately when `parent_hash` becomes stale. Subblocks have a 1-block lifetime.

### 10.3 Conflicting Subblocks

If a builder submits multiple subblocks for the same `parent_hash`, the proposer selects the one with the higher total `gas_limit` sum (static check, not gas used). Ties are broken by selecting the subblock with the **lower `signature_hash`** (lexicographic comparison of `keccak256(0x78 || RLP(subblock))`).

### 10.4 Deduplication

Nodes deduplicate received subblocks by `(builder, parent_hash)`. Only the highest-`gas_limit`-sum subblock is retained per builder per parent.

---

# Invariants

## Must Hold

| ID | Invariant |
|----|-----------|
| **S1** | Delegation requirement: Only validators in the set can call `delegateToBuilder()` |
| **S2** | Gas weight consistency: `gasWeight[builder]` equals count of validators in the set delegating to that builder |
| **S3** | Nonce key format: All 0x5b transactions have builder address in bytes 1-20 |
| **S4** | Signature validity: Subblock ECDSA signatures recover to the declared `builder` address via `ecrecover` |
| **S5** | Builder match: All transactions in a subblock have nonce key builder_address matching `subblock.builder` |
| **S6** | Range validity: Metadata tx ranges are non-overlapping, ordered, and within bounds |
| **S7** | Fee routing: Fees are sent to `fee_recipient` from SubBlockMetadata (resolved from registry at parent post-state) |
| **S8** | Root-only signing: 0x5b transactions reject keychain signatures |
| **S9** | Gas budget: Each builder's subblock does not exceed their computed gas budget |
| **S10** | Immediate effect: Delegation and config changes take effect in the next block |
| **S11** | Expiring nonce detection: Nonce = max uint88 triggers TIP-1009 semantics |
| **S12** | P2P key cap: Each builder can register at most 4 p2p keys |
| **S13** | P2P key uniqueness: Each ed25519 p2p pubkey is registered to at most one builder |
| **S14** | State snapshot: All subblock validation and fee routing uses parent block post-state |
| **S15** | clearBuilderConfig atomicity: Clearing builder config also clears all delegations to that builder and all p2p keys |

## Test Cases

1. **Happy path**: Validator delegates to builder, user submits tx, builder creates subblock, proposer includes it
2. **Many-to-one delegation**: Multiple validators delegate to same builder, builder gets combined gas budget
3. **Signature verification**: Invalid ECDSA signature causes block rejection
4. **Builder mismatch**: Tx with wrong builder address in nonce key rejected from subblock
5. **Overlapping ranges**: Block with overlapping metadata ranges is invalid
6. **Keychain signature**: 0x5b tx with keychain signature is rejected
7. **Unregistered builder**: Delegation rejected if builder has no feeRecipient configured
8. **Builder rotation**: Validator changes delegation, old builder loses gas weight
9. **Gas budget exceeded**: Subblock exceeding computed gas budget is rejected
10. **Conflicting subblocks**: Higher gas_limit sum wins; equal gas_limit breaks tie by lower signature_hash
11. **Stale parent hash**: Subblock with old parent_hash rejected
12. **Validator exits set**: Validator removed from ValidatorConfig, their delegation cleared, builder's gasWeight decremented
13. **Expiring nonce subblock**: Tx with nonce = max uint88 uses TIP-1009 replay protection
14. **Fee token swap with liquidity**: If AMM liquidity exists, builder receives their preferred token
15. **Fee token swap without liquidity**: If no AMM liquidity, fee recipient receives user's fee token
16. **Fee failure**: Tx that cannot pay fees becomes noop, nonce increments, block remains valid
17. **P2P key registration**: Builder registers 4 p2p keys; 5th registration reverts
18. **P2P key uniqueness**: Registering a p2p key already owned by another builder reverts
19. **clearBuilderConfig cascade**: Clearing builder config removes all delegations and p2p keys
20. **Parent post-state snapshot**: Registry mutation in current block does not affect current block's subblock validation
21. **Chain ID mismatch**: Subblock with wrong chain_id rejected
22. **Proposer incentive**: Proposer omitting subblocks cannot access gas incentive lane

---

# Design Rationale

## ECDSA for Builder Signing, ed25519 for P2P

Builders need multiple physical machines for high availability. Each machine needs a unique identity for commonware p2p authentication (ed25519), but subblock signing must use a single shared identity. ECDSA with a shared key via HSM/KMS is a well-understood operational pattern.

- **ECDSA (secp256k1)**: Builder signing identity. Shared across machines via HSM/KMS. Used for subblock signing and `ecrecover` verification. The builder's address is the on-chain identity.
- **ed25519**: Per-machine p2p identity. Each physical machine has its own ed25519 key, registered as a builder p2p key. Used exclusively for commonware p2p authentication.

## Root-Only Signing for Subblock Transactions

Subblock transactions (0x5b prefix) require root EOA signatures and reject keychain (access key) signatures. This is intentional due to a race condition with key revocation:

1. User signs a 0x5b tx with an access key, submits to builder
2. Builder validates signature against current keychain state, includes in subblock
3. In the same block, a main block tx revokes that access key
4. Block execution order: main txs execute first, then subblock txs
5. When the subblock tx executes, the key is already revoked

The problem: signature validation happens at subblock validation time (before block building), not during execution. The subblock tx would still execute even though the key was revoked in the same block.

This violates user expectations. When a user revokes an access key, they expect immediate effect. Allowing keychain signatures for subblock txs would create a window where revoked keys can still authorize transactions.

**Alternative considered**: Re-validate keychain signatures during execution. This was rejected because:
- Adds execution-time overhead for every subblock tx
- Creates griefing vector: users could intentionally revoke keys to cause builder's subblock to fail
- Complicates the execution model

Root-only signing is the simplest solution that maintains user expectations around key revocation.

---

# Implementation Notes

## Relationship to Current Implementation

The current V1 implementation stores subblock-related configuration as follows:

| Data | V1 Location | TIP-1017 (V2) Location |
|------|-------------|------------------------|
| Fee recipient address | CLI arg (`--consensus.fee-recipient`) | `SubblockRegistry.configOf(builder).feeRecipient` |
| Subblock signing key | CLI arg (`--consensus.signing-key`), ed25519 | Builder's own ECDSA key (secp256k1) |
| Subblock fee token | `TipFeeManager.validatorTokens[validator]` | `SubblockRegistry.configOf(builder).feeToken` |
| Proposer fee token | `TipFeeManager.validatorTokens[validator]` | Unchanged (remains in `TipFeeManager`) |
| P2P identity | Validator ed25519 key | Builder p2p ed25519 key (registered per machine) |
| Builder identity | PartialValidatorKey (15 bytes of validator ed25519 pubkey) | Builder ECDSA address (20 bytes) |
| Nonce key identity field | 15-byte PartialValidatorKey (bytes 1-15) | 20-byte builder address (bytes 1-20) |

Key changes from V1:
1. **ECDSA signing**: Builder signs with ECDSA (ecrecover), not ed25519
2. **Separate builder identity**: Builder address is independent from validator identity
3. **Many-to-one delegation**: Validators can share a builder, accumulating gas budgets
4. **Builder configures fee routing**: The builder (not validator) sets fee recipient and token preferences
5. **Builder p2p keys**: Per-machine ed25519 keys for p2p, registered under a builder (max 4)
6. **Expiring nonce support**: Subblock txs can use expiring nonces by setting nonce = max uint88
7. **chain_id field**: SubBlock includes chain_id for cross-chain replay protection

## Open Implementation Questions

- **Lazy vs eager cleanup**: When a validator leaves the set, their delegation can be cleaned up lazily (during next delegation change) or eagerly (via callback from ValidatorConfig). The choice affects gas costs and complexity.

---

# Migration

## Activation

This TIP activates at a specific block height. V1 vs V2 subblock discrimination is by **fork activation height**: both versions use the `0x5b` nonce key prefix, but the interpretation of the identity bytes changes. After activation:

- SubBlockVersion::V1 subblocks are rejected
- The V1 nonce key format (`0x5b | partial_validator_key[15] | nonce[16]`) is no longer valid
- The V2 nonce key format (`0x5b | builder_address[20] | nonce[11]`) is required
- Validators must delegate to a builder before their subblock gas is usable

## Migration Steps

1. **Pre-activation**: Builders call `setBuilderConfig(feeRecipient, feeToken)` to configure fee routing
2. **Pre-activation**: Builders call `registerP2pKey(p2pPubkey)` for each physical machine
3. **Pre-activation**: Validators call `delegateToBuilder(builderAddress)` to delegate their gas budget
4. **Activation block**: Protocol switches to V2 subblock validation
5. **Post-activation**: V1 subblocks and old nonce key formats are rejected

Validators who want to build their own subblocks should create a builder identity and self-delegate:
```solidity
// From the builder's ECDSA address:
SubblockRegistry.setBuilderConfig(myFeeRecipient, preferredFeeToken);
SubblockRegistry.registerP2pKey(myP2pPubkey);

// From the validator's address:
SubblockRegistry.delegateToBuilder(builderAddress);
```
