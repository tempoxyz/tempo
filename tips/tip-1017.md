---
id: TIP-1017
title: Protocol-Enshrined Subaccounts
description: Extends Access Keys with sub-balance isolation, deterministic subaccount addresses, and auto-funding to enable secure app-specific account partitions with global passkey UX.
authors: Tempo AI (on behalf of Georgios Konstantopoulos, Dan Robinson, Tanishk Goyal, Jake)
status: Draft
related: TIP-1011, AccountKeychain, IAccountKeychain.sol
protocolVersion: TBD (requires hardfork)
---

# TIP-1017: Protocol-Enshrined Subaccounts

## Abstract

This TIP introduces protocol-level subaccount primitives that partition a single Tempo account into isolated, app-specific compartments. Each Access Key can optionally operate as a **subaccount** with its own token balances, deterministic address, and auto-funding rules — all enforced natively by the protocol. This enables users to authenticate once with a global passkey while limiting the blast radius of any compromised or malicious application to only the funds in that app's subaccount.

## Motivation

### The Global Passkey Security Problem

Tempo and Porto accounts use WebAuthn passkeys bound to a single relying party domain (e.g., `tempo.xyz`). When a user authenticates on any third-party app via Porto's iframe, the same passkey signs permission grants for the user's **entire** account. This creates a fundamental tension:

**Security risk**: A phishing site that tricks a user into signing a broad permission grant can drain the entire account. Even with spend-limit scopes (TIP-1011), users routinely rubber-stamp permission dialogs, and scopes are hard to reason about — especially with auto fee-token conversion making total costs unpredictable.

**Current workaround — separate accounts**: Users could create separate accounts per app, but this has terrible UX:
- Each account needs its own address, making portfolio management fragmented
- Users must manually fund each account
- No unified view of total holdings
- Bridging and cross-chain operations become complex
- Tax and accounting are painful

**Current workaround — scoped Access Keys**: TIP-1011 adds destination scoping and periodic spend limits, but scopes only limit *what* the key can do, not *what funds* it can access. A key scoped to `transfer()` on any address can still drain the account up to its spend limit. There is no fund isolation.

### What Subaccounts Solve

Subaccounts provide **blast-radius containment**: even if an Access Key is fully compromised, the attacker can only access funds explicitly deposited into that key's subaccount. The root account balance is never at risk.

Combined with TIP-1011's destination scoping and periodic limits, subaccounts create defense-in-depth:

| Layer | What it limits | Enforced by |
|-------|---------------|-------------|
| **Expiry** | Time window | AccountKeychain |
| **Destination scoping** | Which contracts | TIP-1011 |
| **Spend limits** | How much per period | TIP-1011 |
| **Sub-balance isolation** | Which funds are at risk | **This TIP** |

---

# Specification

## Overview

This TIP adds four primitives to the AccountKeychain precompile:

1. **Sub-balances**: Per-key token balance tracking
2. **Subaccount addresses**: Deterministic address derivation from `(account, keyId)`
3. **Sub-balance enforcement**: Transactions signed by a subaccount key debit the sub-balance, not the root balance
4. **Auto-funding**: Optional rules to automatically refill sub-balances from the root account

## Extended Data Structures

### SubaccountConfig

A new struct stored per-key that controls subaccount behavior:

```solidity
struct SubaccountConfig {
    bool enabled;           // Whether this key operates as a subaccount
    AutoFundRule[] autoFund; // Auto-funding rules (may be empty)
}

struct AutoFundRule {
    address token;         // TIP-20 token address
    uint256 minBalance;    // Trigger auto-fund when sub-balance drops below this
    uint256 refillAmount;  // Amount to transfer from root to subaccount
}
```

### Extended KeyAuthorization

```solidity
struct KeyAuthorization {
    TokenLimit[] spendingLimits;     // Existing (TIP-1011)
    uint64 expiry;                   // Existing
    address[] allowedDestinations;   // Existing (TIP-1011)
    SubaccountConfig subaccount;     // NEW: subaccount configuration
    uint256 maxFeePerTransaction;    // NEW: optional fee cap in fee-token units (0 = no cap)
}
```

The `subaccount` field uses RLP trailing field semantics: omitting it is equivalent to `SubaccountConfig { enabled: false, autoFund: [] }`, preserving backward compatibility with pre-TIP-1017 key authorizations.

## Interface Changes

### New Functions in IAccountKeychain

```solidity
/// @notice Returns the deterministic subaccount address for a given account and key.
/// @dev The subaccount address is derived as:
///      address(uint160(uint256(keccak256(abi.encodePacked(
///          bytes1(0xff), account, keyId
///      )))))
///      Uses the 0xff prefix for collision resistance with regular account addresses.
/// @param account The root account address
/// @param keyId The access key identifier
/// @return The deterministic subaccount address
function getSubaccountAddress(address account, address keyId) 
    external pure returns (address);

/// @notice Returns the sub-balance of a token for a specific key's subaccount.
/// @param account The root account address
/// @param keyId The access key identifier
/// @param token The TIP-20 token address
/// @return The sub-balance amount
function getSubBalance(address account, address keyId, address token) 
    external view returns (uint256);

/// @notice Deposits tokens from the root account balance into a key's subaccount.
/// @dev MUST only be called in transactions signed by the Root Key.
///      Debits the root account's token balance and credits the subaccount's sub-balance.
///      Emits SubaccountDeposit.
/// @param keyId The access key identifier
/// @param token The TIP-20 token address
/// @param amount The amount to deposit
function depositToSubaccount(address keyId, address token, uint256 amount) external;

/// @notice Withdraws tokens from a key's subaccount back to the root account.
/// @dev MUST only be called in transactions signed by the Root Key.
///      Debits the subaccount's sub-balance and credits the root account's token balance.
///      Emits SubaccountWithdrawal.
/// @param keyId The access key identifier
/// @param token The TIP-20 token address
/// @param amount The amount to withdraw
function withdrawFromSubaccount(address keyId, address token, uint256 amount) external;

/// @notice Returns the subaccount configuration for a key.
/// @param account The root account address
/// @param keyId The access key identifier
/// @return config The subaccount configuration
function getSubaccountConfig(address account, address keyId) 
    external view returns (SubaccountConfig memory config);

/// @notice Updates auto-funding rules for a key's subaccount.
/// @dev MUST only be called in transactions signed by the Root Key.
/// @param keyId The access key identifier
/// @param rules The new auto-funding rules (replaces existing rules)
function updateAutoFundRules(address keyId, AutoFundRule[] calldata rules) external;
```

### New Events

```solidity
/// @notice Emitted when tokens are deposited into a subaccount
event SubaccountDeposit(
    address indexed account, 
    address indexed keyId, 
    address indexed token, 
    uint256 amount
);

/// @notice Emitted when tokens are withdrawn from a subaccount
event SubaccountWithdrawal(
    address indexed account, 
    address indexed keyId, 
    address indexed token, 
    uint256 amount
);

/// @notice Emitted when auto-funding is triggered
event SubaccountAutoFunded(
    address indexed account, 
    address indexed keyId, 
    address indexed token, 
    uint256 amount
);
```

### New Errors

```solidity
error SubaccountNotEnabled();
error InsufficientSubBalance();
error InsufficientRootBalance();
```

## Semantic Behavior

### Sub-Balance Enforcement

When a transaction is signed by an Access Key with `subaccount.enabled = true`:

```
function enforceSubBalance(account, keyId, token, amount):
    config = getSubaccountConfig(account, keyId)
    
    if !config.enabled:
        // Not a subaccount key — use root balance (existing behavior)
        return SKIP
    
    subBal = getSubBalance(account, keyId, token)
    
    if amount > subBal:
        revert InsufficientSubBalance()
    
    subBalances[account][keyId][token] -= amount
```

#### Blocked Operations for Subaccount Keys

When `subaccount.enabled = true`, the protocol MUST block `approve()`, `permit()`, `increaseAllowance()`, and `decreaseAllowance()` calls where `msg.sender == tx.origin` (i.e., the account itself is calling). Subaccount keys MUST NOT set allowances on the root account.

This prevents a bypass where a subaccount key grants an allowance to an attacker who then calls `transferFrom` from outside the subaccount context, circumventing sub-balance enforcement.

**Integration point**: The protocol calls `enforceSubBalance` during ALL TIP-20 balance-debiting operations, *in addition to* the existing spending limit checks from TIP-1011. Enforcement applies to: `transfer`, `transferWithMemo`, `transferFrom` (when `from == tx.origin`), `burn`, and `startReward`. This is a **consensus-critical rule**: any TIP-20 operation that debits the account's balance MUST be subject to sub-balance enforcement when the signing key has `subaccount.enabled = true`. The enforcement order is:

1. Check key expiry
2. Check destination scoping (TIP-1011)
3. Execute auto-funding (capped by spending limits)
4. Check spending limits (TIP-1011)
5. **Check and debit sub-balance (this TIP)**
6. Execute the TIP-20 operation

Both spending limits and sub-balance checks must pass. Spending limits track cumulative spend per period; sub-balances track actual available funds.

### Auto-Funding Logic

Before executing a subaccount transaction, the protocol checks auto-fund rules:

```
function maybeAutoFund(account, keyId):
    config = getSubaccountConfig(account, keyId)
    
    for rule in config.autoFund:
        subBal = getSubBalance(account, keyId, rule.token)
        
        if subBal < rule.minBalance:
            rootBal = tip20Balance(account, rule.token)
            remainingSpendLimit = getRemainingSpendLimit(account, keyId, rule.token)
            fundAmount = min(rule.refillAmount, remainingSpendLimit, rootBal)
            
            if fundAmount > 0:
                tip20Balance(account, rule.token) -= fundAmount
                subBalances[account][keyId][rule.token] += fundAmount
                emit SubaccountAutoFunded(account, keyId, rule.token, fundAmount)
```

**Timing**: Auto-funding runs **before** transaction execution but **after** transaction validation. If the root account has insufficient balance, auto-funding is silently skipped (no revert) — the transaction may still succeed if the existing sub-balance is sufficient.

**Spending limit integration**: Auto-fund transfers MUST count against the key's spending limits (TIP-1011). If the auto-fund amount would exceed the remaining spending limit, auto-fund is capped at the remaining spending limit. The refill formula is: `min(refillAmount, remainingSpendLimit, rootBalance)`.

**Maximum rules**: A maximum of 4 auto-fund rules per key is protocol-enforced. Attempting to authorize a key or call `updateAutoFundRules` with more than 4 rules MUST revert.

**Root key behavior**: Auto-funding only triggers on Access Key transactions, never on Root Key transactions.

### Subaccount Address Derivation

The deterministic subaccount address allows third parties to send funds directly to a subaccount:

```
subaccountAddr = address(uint160(uint256(keccak256(
    abi.encodePacked(bytes1(0xff), account, keyId)
))))
```

**Registry**: When a key is authorized with `subaccount.enabled = true`, the protocol MUST write a registry entry: `subaccount_registry[derivedAddr] = (account, keyId)`. Only addresses present in this registry receive subaccount routing for inbound transfers. Transfers to unregistered derived addresses create normal accounts.

**Receiving funds**: When a TIP-20 transfer targets a subaccount address, the protocol:
1. Looks up `subaccount_registry[targetAddr]` to resolve the `(account, keyId)` pair
2. If the address is registered, credits the sub-balance instead of creating a new account
3. If the address is not registered, treats it as a normal transfer (creates a new account)

**Sending funds**: When a subaccount key signs a `transfer(to, amount)`:
- `msg.sender` = root account address (unchanged EVM semantics)
- Funds are debited from the sub-balance
- Contracts can call `getTransactionKey()` to identify the originating subaccount

### Interaction with `msg.sender`

This TIP does **not** change EVM `msg.sender` semantics. The root account address remains `msg.sender` for all transactions. This is a deliberate design choice:

1. **Compatibility**: Changing `msg.sender` would break existing contract patterns (token allowances, access control, etc.)
2. **Composability**: DeFi protocols (DEXes, lending) work correctly because balances remain associated with the root account address
3. **Introspection**: Contracts that need to differentiate subaccounts use `getTransactionKey()` which is already available

Applications that want app-specific `msg.sender` isolation should use EIP-7702 with separate EOAs — subaccounts solve the fund isolation problem without requiring identity isolation.

### Interaction with Spending Limits

Sub-balances and spending limits are independent but complementary:

| Scenario | Spending Limit | Sub-Balance | Result |
|----------|---------------|-------------|--------|
| Limit: 100 USDC/day, Sub-bal: 50 USDC | Spend 50 | ✅ within limit | ✅ sufficient | ✅ succeeds |
| Limit: 100 USDC/day, Sub-bal: 50 USDC | Spend 80 | ✅ within limit | ❌ insufficient | ❌ reverts |
| Limit: 30 USDC/day, Sub-bal: 100 USDC | Spend 50 | ❌ exceeds limit | ✅ sufficient | ❌ reverts |
| No limit enforced, Sub-bal: 100 USDC | Spend 100 | ✅ no limit | ✅ sufficient | ✅ succeeds |

### Gas Payment

Subaccount transactions pay gas from the **root account balance**, not the sub-balance. This is because:
- Gas is paid in the fee token, which may differ from sub-balance tokens
- Requiring sub-balance gas funding would degrade UX
- The root account already authorized the key, implicitly accepting gas costs

If gas sponsorship is used (fee payer), no gas is charged to either root or sub-balance.

**Fee cap**: `KeyAuthorization` MUST include an optional `maxFeePerTransaction: Option<U256>` field (in fee-token units). When set, the protocol rejects transactions whose fee exceeds this cap. This prevents a compromised key from draining the root account via gas fees.

## Precompile Storage Changes

New storage mappings in the AccountKeychain precompile (additive, no migration required):

| Mapping | Type | Description |
|---------|------|-------------|
| `sub_balances[account][keyId][token]` | `uint256` | Sub-balance for a token |
| `subaccount_enabled[account][keyId]` | `bool` | Whether subaccount mode is enabled |
| `auto_fund_rules_len[account][keyId]` | `uint64` | Number of auto-fund rules |
| `auto_fund_rules[account][keyId][index].token` | `address` | Auto-fund rule token |
| `auto_fund_rules[account][keyId][index].minBalance` | `uint256` | Auto-fund trigger threshold |
| `auto_fund_rules[account][keyId][index].refillAmount` | `uint256` | Auto-fund refill amount |
| `subaccount_registry[address]` | `(address, address)` | Maps derived subaccount address to `(account, keyId)` pair |

## Encoding

### KeyAuthorization RLP Extension

```
KeyAuthorization := RLP([
    spendingLimits: [TokenLimit, ...],
    expiry: uint64,
    allowedDestinations: [address, ...],     // TIP-1011
    subaccountConfig: SubaccountConfig,      // NEW (trailing, optional)
    maxFeePerTransaction: uint256            // NEW (trailing, optional; 0 = no cap)
])

SubaccountConfig := RLP([
    enabled: bool,
    autoFundRules: [AutoFundRule, ...]
])

AutoFundRule := RLP([
    token: address,
    minBalance: uint256,
    refillAmount: uint256
])
```

Trailing field semantics: if `subaccountConfig` is absent, decode as `{ enabled: false, autoFundRules: [] }`.

## Gas Costs

| Operation | Gas Cost | Notes |
|-----------|----------|-------|
| `depositToSubaccount` | ~10,000 | 2 SSTORE (root balance update + sub-balance update) |
| `withdrawFromSubaccount` | ~10,000 | 2 SSTORE |
| Sub-balance check per tx | ~2,100 | 1 SLOAD |
| Sub-balance debit per tx | ~5,000 | 1 SSTORE (non-zero to non-zero) |
| Auto-fund trigger | ~15,000 | 1 SLOAD + 2 SSTORE |
| `authorizeKey` with subaccount config | +250,000 per auto-fund rule | New state creation (0→non-zero) |
| `getSubBalance` (view) | ~2,100 | 1 SLOAD |
| `getSubaccountAddress` (pure) | ~100 | Hash computation only |

---

# Backward Compatibility

This TIP requires a **hardfork** due to changes in transaction encoding and new precompile behavior.

## RLP Encoding Changes

### KeyAuthorization (trailing field addition)

`SubaccountConfig` is appended as a trailing RLP field to `KeyAuthorization`. Existing key authorizations (without the field) decode with `subaccount.enabled = false`, preserving backward compatibility.

Old nodes cannot decode transactions containing `SubaccountConfig`. New nodes handle both formats via version-tolerant decoding.

## Precompile Storage Changes

All new storage mappings are additive. Existing keys have no sub-balance entries, which default to zero. No database migration is required.

## Behavioral Changes

Pre-fork keys continue to work identically: they have no sub-balance enforcement, and TIP-20 transfers debit the root balance as before. Sub-balance enforcement only activates for keys authorized with `subaccount.enabled = true` post-fork.

## Hardfork-Gated Features

1. **RLP decoding**: Accept `SubaccountConfig` in `KeyAuthorization`
2. **Sub-balance enforcement**: Check sub-balance on TIP-20 transfers for subaccount keys
3. **Auto-funding logic**: Run auto-fund checks before subaccount transaction execution
4. **Subaccount address resolution**: Recognize subaccount addresses in TIP-20 transfer targets
5. **New precompile interface methods**: `depositToSubaccount`, `withdrawFromSubaccount`, `getSubBalance`, `getSubaccountAddress`, `getSubaccountConfig`, `updateAutoFundRules`

---

## Consensus-Critical Definitions

- `balanceOf(account)` returns the ROOT partition balance only (not including sub-balances). Sub-balances are separate and queryable via `getSubBalance()`.
- `depositToSubaccount` debits the TIP-20 `balanceOf` of the root account and credits the sub-balance (which is NOT reflected in `balanceOf`).
- Sub-balances are internal accounting within the AccountKeychain precompile. They are NOT visible via standard TIP-20 `balanceOf`.

---

# Invariants

1. **Balance conservation**: For any token, the sum of the root balance and all sub-balances for an account MUST equal the total tokens held by that account. `depositToSubaccount` and `withdrawFromSubaccount` MUST be zero-sum operations.

2. **Sub-balance isolation**: A transaction signed by an Access Key with `subaccount.enabled = true` MUST NOT debit the root account's token balance (except for gas). It MUST only debit from the key's sub-balance.

3. **Root key supremacy**: Only Root Key transactions may call `depositToSubaccount`, `withdrawFromSubaccount`, and `updateAutoFundRules`.

4. **Auto-fund safety**: Auto-funding MUST NOT overdraw the root balance. If the root balance is insufficient for the full `refillAmount`, the protocol MUST fund up to the available root balance.

5. **Subaccount address uniqueness**: `getSubaccountAddress(account, keyId)` MUST return a unique address for each unique `(account, keyId)` pair.

6. **Non-subaccount backward compatibility**: Keys authorized without `subaccount.enabled = true` MUST behave identically to pre-TIP-1017 keys: no sub-balance checks, TIP-20 transfers debit root balance.

7. **Revoked key isolation**: When a key is revoked, its sub-balance MUST remain intact. The Root Key can withdraw remaining sub-balance via `withdrawFromSubaccount`.

8. **Spending limit independence**: Sub-balance checks and spending limit checks (TIP-1011) are independent. Both MUST pass for a transaction to succeed.

9. **Approve isolation**: Subaccount-enabled keys MUST NOT be able to set allowances on the root account.

10. **Auto-fund spending limit integration**: Auto-fund amounts MUST count against the key's spending limits.

11. **Gas fee cap**: If `maxFeePerTransaction` is set, transactions whose fee exceeds the cap MUST be rejected at validation time.

12. **Registry consistency**: A subaccount address MUST be registered if and only if the corresponding key has `subaccount.enabled = true` and has not been revoked.

## Test Cases

1. **Deposit and withdraw**: Verify root→subaccount and subaccount→root transfers conserve total balance
2. **Sub-balance enforcement**: Verify subaccount key cannot spend more than sub-balance
3. **Root balance isolation**: Verify subaccount key transaction does not affect root balance
4. **Auto-funding**: Verify sub-balance is refilled when below threshold before tx execution
5. **Auto-fund insufficient root**: Verify partial auto-fund when root balance < refillAmount
6. **Auto-fund skip**: Verify no revert when auto-fund cannot fulfill
7. **Subaccount address derivation**: Verify deterministic address matches expected computation
8. **Direct deposit to subaccount address**: Verify TIP-20 transfer to subaccount address credits sub-balance
9. **Non-subaccount key**: Verify keys without subaccount flag use root balance (backward compat)
10. **Revoked key withdrawal**: Verify root can withdraw sub-balance of revoked key
11. **Combined limits**: Verify spending limit + sub-balance both enforced independently
12. **Gas from root**: Verify gas is always paid from root balance, not sub-balance
13. **Multiple subaccounts**: Verify independent sub-balance tracking across multiple keys
14. **Subaccount + destination scoping**: Verify TIP-1011 destination scoping works alongside sub-balance
15. **Approve blocked**: Verify subaccount key calling `approve()` on root account reverts
16. **transferFrom enforcement**: Verify sub-balance checked when `transferFrom(root, ...)` is called by root-signed subaccount tx
17. **Auto-fund spend limit cap**: Verify auto-fund is capped at remaining spending limit
18. **Auto-fund max rules**: Verify authorizing key with >4 auto-fund rules reverts
19. **Gas fee cap**: Verify transaction with fee exceeding `maxFeePerTransaction` is rejected
20. **Registry routing**: Verify inbound transfer to unregistered derived address creates normal account
21. **balanceOf isolation**: Verify `balanceOf(account)` does not include sub-balances

## References

- [TIP-1011: Enhanced Access Key Permissions](./tip-1011.md)
- [AccountKeychain Reference Implementation](./ref-impls/src/AccountKeychain.sol)
- [IAccountKeychain Interface](./ref-impls/src/interfaces/IAccountKeychain.sol)
- [Porto Account Contracts — GuardedExecutor](https://github.com/ithacaxyz/account/blob/main/src/GuardedExecutor.sol)
- [ithacaxyz/account PR #232 — Subaccount exploration](https://github.com/ithacaxyz/account/pull/232)
