---
id: TIP-1017
title: Subblocks v2 - Builder Delegation
description: Separates subblock builder identity from validator identity with many-to-one delegation, standard ECDSA signing, and expiring nonce support.
authors: Mallesh Pai
status: Draft
related: Subblock Specification, TIP-1009
protocolVersion: TBD
---

# TIP-1017: Subblocks v2 - Builder Delegation

## Abstract

This TIP introduces major changes to the subblock system:

1. **Builder Delegation**: Validators can delegate subblock production to a builder identified by an Ethereum address. Multiple validators can delegate to the same builder, who accumulates their combined gas budget.

2. **ECDSA Signing**: Builders sign subblocks with their Ethereum key (ECDSA) instead of ed25519, since subblock signing is not part of consensus.

3. **Nonce Key Format**: The nonce key format changes to `0x5b | builder_address | nonce`, embedding the builder identity directly in the transaction.

4. **Expiring Nonces in Subblocks**: Subblock transactions can use expiring nonces by setting the nonce portion to all 1s (`0xFFFF...`).

## Motivation

The current subblock design has several limitations:

1. **Validator coupling**: The validator's consensus key must also sign subblocks, meaning validators cannot delegate subblock production to separate infrastructure without sharing their consensus key.

2. **One-to-one only**: Each validator must run their own subblock builder; there's no way to delegate to a shared builder.

3. **No expiring nonces**: Subblock transactions require sequential 2D nonces, preventing use of expiring nonces (TIP-1009).

This TIP addresses these issues by:

- Allowing validators to delegate to builders identified by Ethereum address
- Supporting many-to-one delegation where multiple validators share a builder
- Using ECDSA for subblock signing (not consensus-critical)
- Enabling expiring nonces within subblock transactions

---

# Specification

## 1. Subblock Registry

A new Subblock Registry precompile stores builder configurations and validator delegations.

### 1.1 Data Structures

```solidity
struct BuilderConfig {
    address feeRecipient;  // where subblock fees are sent
    address feeToken;      // preferred TIP-20 token for fee payment
}
```

**Note on fee token**: The builder's fee token is stored in `SubblockRegistry`, separate from `TipFeeManager.validatorTokens`. This allows:
- **Subblock fees** (for txs in builder's subblocks): `SubblockRegistry.configOf(builder).feeToken`
- **Proposer fees** (when validator is block proposer): `TipFeeManager.validatorTokens[validator]`

When processing fees for a subblock transaction:
1. Resolve the user's fee token using standard Tempo resolution (tx preference → user preference → inference → PathUSD)
2. Extract `builder` from nonce key (bytes 11-30)
3. Look up `config = SubblockRegistry.configOf(builder)`
4. If registered and `config.feeToken` differs, attempt to swap via Fee AMM if liquidity available
5. If no liquidity or unregistered, fees are paid directly in the user's resolved fee token
6. Fees are sent to `config.feeRecipient` (or `builder` if no config set)

### 1.2 Storage

```solidity
// Validator → builder they delegate to (zero = not delegated)
mapping(address => address) public delegatedBuilder;

// Builder → their configuration
mapping(address => BuilderConfig) public builderConfig;

// Builder → number of validators delegating to them (gas weight)
mapping(address => uint256) public gasWeight;
```

### 1.3 Interface

```solidity
interface ISubblockRegistry {
    // ========== Validator Functions ==========

    /// @notice Delegates the caller's subblock production to a builder.
    /// @param builder The builder's Ethereum address.
    /// @dev Only callable by active validators (per ValidatorConfig).
    /// @dev Clears any existing delegation first.
    /// @dev Increments the builder's gasWeight.
    function delegateToBuilder(address builder) external;

    /// @notice Clears the caller's delegation.
    /// @dev Only callable by validators with an existing delegation.
    /// @dev Decrements the previous builder's gasWeight.
    function clearDelegation() external;

    // ========== Builder Functions ==========

    /// @notice Sets the caller's builder configuration.
    /// @param feeRecipient Where subblock fees are sent.
    /// @param feeToken Preferred TIP-20 token for fee payment.
    /// @dev Anyone can call this to configure themselves as a builder.
    function setBuilderConfig(address feeRecipient, address feeToken) external;

    /// @notice Clears the caller's builder configuration.
    function clearBuilderConfig() external;

    // ========== View Functions ==========

    /// @notice Returns the builder a validator has delegated to.
    /// @param validator The validator address.
    /// @return The builder address, or zero if not delegated.
    function builderOf(address validator) external view returns (address);

    /// @notice Returns a builder's configuration.
    /// @param builder The builder address.
    /// @return The BuilderConfig struct (zero values if not configured).
    function configOf(address builder) external view returns (BuilderConfig memory);

    /// @notice Returns a builder's fee recipient.
    /// @param builder The builder address.
    /// @return The fee recipient, or the builder address itself if not configured.
    function feeRecipientFor(address builder) external view returns (address);

    /// @notice Returns a builder's preferred fee token.
    /// @param builder The builder address.
    /// @return The TIP-20 token address, or zero if not configured.
    function feeTokenFor(address builder) external view returns (address);

    /// @notice Returns a builder's gas weight (number of delegating validators).
    /// @param builder The builder address.
    /// @return The gas weight.
    function gasWeightOf(address builder) external view returns (uint256);
}
```

### 1.4 Behavior

**Delegation:**
- Only addresses in the `ValidatorConfig` validator set can call `delegateToBuilder()`
- The SubblockRegistry queries `ValidatorConfig.validators(msg.sender)` to verify the caller is a validator
- When delegating, any existing delegation is cleared first (atomically updates gasWeight)
- Changes take effect immediately in the next block

**Builder configuration:**
- Anyone can call `setBuilderConfig()` to configure themselves as a builder
- No registration is required before validators can delegate
- If `feeRecipient` is zero, fees go directly to the builder address
- If `feeToken` is zero, no swap is attempted (user's token is used)

**Gas weight:**
- `gasWeight[builder]` is the count of validators currently delegating to that builder
- Incremented when a validator calls `delegateToBuilder(builder)`
- Decremented when a validator calls `clearDelegation()` or delegates to a different builder
- Used to compute the builder's total gas budget

**Validator set changes:**
- The subblock builder is separate infrastructure from the validator node. A validator being temporarily "down" or offline does NOT affect their builder's ability to produce subblocks.
- `gasWeight[builder]` always reflects the number of validators **in the consensus set** delegating to that builder.
- When a validator is **removed from ValidatorConfig** (exits the validator set):
  - Their delegation MUST be cleared
  - `gasWeight` for their builder is decremented
  - This can be done lazily (during next delegation change) or eagerly (via callback from ValidatorConfig)
- This ensures gas budgets accurately reflect the current validator set.

### 1.5 Precompile Address

```
SUBBLOCK_REGISTRY_ADDRESS = 0x0b10c0000000000000000000000000000000000X  // TBD
```

### 1.6 Relationship to ValidatorConfig

The SubblockRegistry is a **separate precompile** from ValidatorConfig but **depends on it** for validator set membership:

```
┌─────────────────────┐         ┌─────────────────────┐
│   ValidatorConfig   │◄────────│   SubblockRegistry  │
│                     │  reads  │                     │
│ - validatorAddress  │         │ - delegatedBuilder  │
│ - publicKey (ed25519)│        │ - builderConfig     │
│ - active            │         │ - gasWeight         │
│ - index             │         │                     │
└─────────────────────┘         └─────────────────────┘
     Source of truth              Builder delegation
     for validator set            configuration
```

- `ValidatorConfig.publicKey`: Used for **consensus signing** (block proposals, attestations)
- Builder's Ethereum address: Used for **subblock signing** (ECDSA, not consensus-critical)

---

## 2. Nonce Key Format

### 2.1 Subblock Nonce Key

Subblock transactions use the following nonce key format:

```
32 bytes total:
┌──────────────────┬───────────────────────────┬─────────────────────┐
│ 0x5b (1 byte)    │ builder_address (20 bytes)│ nonce (11 bytes)    │
├──────────────────┼───────────────────────────┼─────────────────────┤
│ byte 31 (MSB)    │ bytes 11-30               │ bytes 0-10          │
└──────────────────┴───────────────────────────┴─────────────────────┘
```

- **Byte 31 (MSB)**: `0x5b` prefix identifying this as a subblock transaction
- **Bytes 11-30**: The 20-byte builder Ethereum address
- **Bytes 0-10**: 11-byte nonce value (2^88 possible values)

### 2.2 Nonce Key Construction

```solidity
function buildSubblockNonceKey(address builder, uint88 nonce) pure returns (uint256) {
    return (uint256(0x5b) << 248) | (uint256(uint160(builder)) << 88) | uint256(nonce);
}
```

### 2.3 Builder Extraction

```solidity
function extractBuilder(uint256 nonceKey) pure returns (address) {
    require(uint8(nonceKey >> 248) == 0x5b, "Not a subblock nonce key");
    return address(uint160(nonceKey >> 88));
}
```

### 2.4 Nonce Extraction

```solidity
function extractNonce(uint256 nonceKey) pure returns (uint88) {
    return uint88(nonceKey);
}
```

### 2.5 Subblock Transaction Detection

```solidity
function isSubblockTx(uint256 nonceKey) pure returns (bool) {
    return uint8(nonceKey >> 248) == 0x5b;
}
```

---

## 3. Expiring Nonces in Subblocks

### 3.1 Motivation

TIP-1009 introduced expiring nonces for parallel transaction submission without sequential ordering. This TIP extends that support to subblock transactions.

### 3.2 Detection

A subblock transaction uses expiring nonce semantics if:
1. The nonce key has `0x5b` prefix (bytes 31)
2. The nonce portion (bytes 0-10) is all 1s: `0x7FFFFFFFFFFFFF` (max uint88)

```solidity
uint88 constant EXPIRING_NONCE_MARKER = type(uint88).max;  // 0x7FFFFFFFFFFFFF

function isSubblockExpiringNonce(uint256 nonceKey) pure returns (bool) {
    return isSubblockTx(nonceKey) && extractNonce(nonceKey) == EXPIRING_NONCE_MARKER;
}
```

### 3.3 Nonce Key Format (Expiring)

```
32 bytes total:
┌──────────────────┬───────────────────────────┬─────────────────────┐
│ 0x5b (1 byte)    │ builder_address (20 bytes)│ 0x7FF...FF (11 bytes)│
├──────────────────┼───────────────────────────┼─────────────────────┤
│ byte 31 (MSB)    │ bytes 11-30               │ bytes 0-10 = max    │
└──────────────────┴───────────────────────────┴─────────────────────┘
```

### 3.4 Replay Protection

Subblock expiring nonce transactions follow TIP-1009 semantics:
- `validBefore` field is required
- `nonce` field must be `0`
- Replay protection via transaction hash + **same circular buffer** as TIP-1009
- Same validity window (30 seconds max)

The only difference from standard expiring nonces is the nonce key format, which routes the transaction to a specific builder. The replay protection shares the same `expiringNonceSeen` and `expiringNonceRing` storage as regular expiring nonces—no separate buffer is needed since the transaction hash is globally unique.

### 3.5 Nonce Key Construction (Expiring)

```solidity
function buildSubblockExpiringNonceKey(address builder) pure returns (uint256) {
    return buildSubblockNonceKey(builder, EXPIRING_NONCE_MARKER);
}
```

---

## 4. Signed Subblock Structure

### 4.1 SubBlock

```rust
struct SubBlock {
    version: SubBlockVersion,  // V2 for this spec
    parent_hash: B256,         // Block hash this subblock builds on
    builder: Address,          // Builder's Ethereum address
    transactions: Vec<Transaction>,
}
```

### 4.2 SignedSubBlock

```rust
struct SignedSubBlock {
    subblock: SubBlock,
    signature: Bytes,  // ECDSA signature from builder's Ethereum key
}
```

### 4.3 Signature Computation

```
signature_hash = keccak256(0x78 || RLP(subblock))
signature = ecdsa_sign(builder_private_key, signature_hash)
```

The signature is a standard Ethereum signature (v, r, s) that recovers to the builder's address.

### 4.4 Signature Verification

```solidity
function verifySubblockSignature(SignedSubBlock calldata signed) view returns (bool) {
    bytes32 hash = keccak256(abi.encodePacked(hex"78", rlpEncode(signed.subblock)));
    address recovered = ecrecover(hash, v, r, s);
    return recovered == signed.subblock.builder;
}
```

### 4.5 Version

This TIP introduces `SubBlockVersion::V2`. Nodes MUST reject V1 subblocks after activation.

---

## 5. Subblock Metadata

### 5.1 SubBlockMetadata

The proposer includes metadata about included subblocks in a system transaction:

```rust
struct SubBlockMetadataEntry {
    builder: Address,        // Builder's Ethereum address
    tx_start_index: u32,     // Index of first tx in block
    tx_count: u32,           // Number of transactions
    signature: Bytes,        // ECDSA signature
}

struct SubBlockMetadata {
    entries: Vec<SubBlockMetadataEntry>,
}
```

### 5.2 Metadata Validation

During block execution, the SubBlockMetadata system transaction is processed:

1. For each entry:
   a. Recover signer from signature
   b. Verify signer matches `entry.builder`
   c. Verify transactions in range have matching builder in nonce key
   d. Verify builder has at least one active validator delegating to them

2. Verify ranges are non-overlapping and within block bounds

### 5.3 Gas Budget Enforcement

Each builder's subblock is limited by their accumulated gas budget:

```
per_validator_gas = (block_gas_limit / TEMPO_SHARED_GAS_DIVISOR) / num_active_validators
builder_gas_budget = per_validator_gas × (number of active validators delegating to builder)
```

The metadata includes the `builder` address. During validation:
1. Look up all validators delegating to this builder
2. Count only **active** validators (per ValidatorConfig)
3. Compute builder's gas budget as the sum of their per-validator allocations
4. Verify subblock's total gas usage does not exceed budget

---

## 6. Fee Routing

### 6.1 Fee Recipient Resolution

For subblock transactions (nonce key has `0x5b` prefix):

1. Extract `builder` from nonce key (bytes 11-30)
2. Look up `config = SubblockRegistry.configOf(builder)`
3. If `config.feeRecipient != address(0)`: use `config.feeRecipient`
4. Else: use `builder` as fee recipient

### 6.2 Fee Token Resolution

The user's fee token is resolved using standard Tempo resolution:
1. Transaction's explicit `fee_token` field (if set)
2. User's default fee token preference (from user config)
3. Inference from transaction context
4. PathUSD (default)

### 6.3 Fee Token Swap

If `user_fee_token != builder_fee_token` and the builder has a token preference:
- If sufficient AMM liquidity exists, swap to `builder_fee_token`
- If insufficient liquidity, the fee recipient receives `user_fee_token` directly

The transaction is **never invalidated** due to missing AMM liquidity.

### 6.4 Unregistered Builders

If the builder has no configuration in SubblockRegistry:
- `feeRecipientFor(builder)` returns the builder address itself
- `feeTokenFor(builder)` returns zero (no swap attempted)
- Fees are paid directly in the user's resolved fee token

---

## 7. Transaction Routing

### 7.1 Builder Endpoint

Builders MUST expose an RPC endpoint for receiving subblock transactions. Users submit transactions to the builder whose address matches the builder in their nonce key.

### 7.2 Subblock Submission Endpoint

All validators MUST expose an endpoint for receiving signed subblocks from builders:

```
POST /subblocks/submit
Content-Type: application/octet-stream
Body: RLP-encoded SignedSubBlock
```

Validators store received subblocks and propagate them internally. When a validator becomes proposer, they select subblocks for inclusion.

### 7.3 No P2P Gossip for Subblocks

Signed subblocks are NOT propagated via p2p gossip. The dedicated submission endpoint is the only ingress path for subblocks.

---

## 8. End-to-End Flow

### 8.1 Setup (Once per Builder)

```
1. Builder (optionally) calls SubblockRegistry.setBuilderConfig({
       feeRecipient: <where fees go>,
       feeToken: <preferred TIP-20 token>
   })
2. Builder advertises their Ethereum address to validators
```

### 8.2 Setup (Once per Validator)

```
1. Validator selects a builder to delegate to
2. Validator calls SubblockRegistry.delegateToBuilder(builder)
3. Registry increments builder's gasWeight
```

### 8.3 Transaction Creation (User)

```
1. User selects a builder by Ethereum address
2. User constructs nonce key: 0x5b | builder | nonce
   - For sequential: nonce = next available value
   - For expiring: nonce = 0x7FF...FF (max uint88)
3. User signs transaction with ROOT EOA key (no keychain)
4. User submits transaction to builder's RPC endpoint
```

### 8.4 Subblock Building (Builder)

```
1. Builder collects transactions matching their address in nonce key
2. Builder validates each transaction (nonce, balance, execution)
3. Builder orders transactions, respects gas budget
4. Builder creates SubBlock with parent_hash = current chain tip
5. Builder signs with ECDSA → SignedSubBlock
6. Builder submits to validators' subblock endpoint
```

### 8.5 Block Building (Proposer)

```
1. Proposer receives SignedSubBlocks from validators' internal propagation
2. For each subblock:
   a. Recover signer from signature, verify matches subblock.builder
   b. Verify all txs have matching builder in nonce key
   c. Verify parent_hash matches current tip
   d. Verify builder has active delegating validators
   e. Compute builder's gas budget from active delegators
   f. Verify total gas does not exceed budget
   g. Execute transactions, verify validity
3. Select valid subblocks
4. Build SubBlockMetadata with tx_start_index/tx_count for each
5. Append SubBlockMetadata system transaction at end of block
```

### 8.6 Block Execution (All Nodes)

```
1. Execute block transactions in order
2. For each 0x5b transaction:
   a. Extract builder from nonce key (bytes 11-30)
   b. Determine if expiring nonce (nonce = max uint88)
   c. If expiring: use TIP-1009 replay protection
   d. Else: use 2D nonce semantics
   e. Look up fee recipient and token from registry
   f. Deduct fees, credit to fee recipient
3. Process SubBlockMetadata system transaction:
   a. Recover signers for each entry
   b. Verify tx ranges match actual transactions
   c. If any verification fails, block is invalid
```

---

## 9. Gas Accounting

### 9.1 Per-Validator Gas Budget

Gas budgets are computed per-validator:

```
shared_gas_limit = block_gas_limit / TEMPO_SHARED_GAS_DIVISOR
per_validator_gas = shared_gas_limit / num_active_validators
```

### 9.2 Builder Gas Budget

A builder's gas budget is the sum of per-validator gas for all validators in the consensus set delegating to them:

```
builder_gas_budget = per_validator_gas × gasWeight[builder]
```

Since delegations are cleaned up when validators leave the set (see Section 1.4), `gasWeight` accurately reflects the builder's current gas allocation.

---

## 10. Subblock Lifecycle

### 10.1 Subblock Validity

A signed subblock is valid only if:
- `parent_hash` matches the current chain tip
- The signature recovers to `subblock.builder`
- `gasWeight[builder] > 0` (at least one validator in the set delegates to this builder)
- All transactions have nonce key prefix `0x5b` with matching `builder`
- Total gas does not exceed the builder's computed gas budget

### 10.2 Subblock Expiry

Subblocks expire immediately when `parent_hash` becomes stale. Subblocks have a 1-block lifetime.

### 10.3 Conflicting Subblocks

If a builder submits multiple subblocks for the same `parent_hash`, the proposer selects the one with higher total gas used (maximizing fees).

### 10.4 Deduplication

Validators deduplicate received subblocks by `(builder, parent_hash)`. Only the most recent (or highest-gas) subblock is retained.

---

# Invariants

## Must Hold

| ID | Invariant |
|----|-----------|
| **S1** | Delegation requirement: Only validators in the consensus set can call `delegateToBuilder()` |
| **S2** | Gas weight consistency: `gasWeight[builder]` equals count of validators in the set delegating to that builder |
| **S3** | Nonce key format: All 0x5b transactions have builder address in bytes 11-30 |
| **S4** | Signature validity: Subblock signatures recover to the declared `builder` address |
| **S5** | Builder match: All transactions in a subblock have matching builder in their nonce key |
| **S6** | Range validity: Metadata tx ranges are non-overlapping, ordered, and within bounds |
| **S7** | Fee routing: Fees are sent to `feeRecipientFor(builder)` |
| **S8** | Root-only signing: 0x5b transactions reject keychain signatures |
| **S9** | Gas budget: Each builder's subblock does not exceed their computed gas budget |
| **S10** | Immediate effect: Delegation and config changes take effect in the next block |
| **S11** | Expiring nonce detection: Nonce = max uint88 triggers TIP-1009 semantics |

## Test Cases

1. **Happy path**: Validator delegates to builder, user submits tx, builder creates subblock, proposer includes it
2. **Many-to-one delegation**: Multiple validators delegate to same builder, builder gets combined gas budget
3. **Signature verification**: Invalid ECDSA signature causes block rejection
4. **Builder mismatch**: Tx with wrong builder in nonce key rejected from subblock
5. **Overlapping ranges**: Block with overlapping metadata ranges is invalid
6. **Keychain signature**: 0x5b tx with keychain signature is rejected
7. **Unregistered builder**: Fees go directly to builder address in user's fee token
8. **Builder rotation**: Validator changes delegation, old builder loses gas weight
9. **Gas budget exceeded**: Subblock exceeding computed gas budget is rejected
10. **Conflicting subblocks**: Higher-gas subblock selected over lower-gas
11. **Stale parent hash**: Subblock with old parent_hash rejected
12. **Validator exits set**: Validator removed from ValidatorConfig, their delegation cleared, builder's gasWeight decremented
13. **Expiring nonce subblock**: Tx with nonce = max uint88 uses TIP-1009 replay protection
14. **Fee token swap with liquidity**: If AMM liquidity exists, builder receives their preferred token
15. **Fee token swap without liquidity**: If no AMM liquidity, fee recipient receives user's fee token

---

# Design Rationale

## Root-Only Signing for Subblock Transactions

Subblock transactions (0x5b prefix) require root EOA signatures and reject keychain (access key) signatures. This is intentional due to a race condition with key revocation:

1. User signs a 0x5b tx with an access key, submits to builder
2. Builder validates signature against current keychain state, includes in subblock
3. In the same block, a main block tx revokes that access key
4. Block execution order: main txs execute first, then subblock txs
5. When the subblock tx executes, the key is already revoked

The problem: signature validation happens at subblock validation time (before block building), not during execution. The subblock tx would still execute even though the key was revoked in the same block.

This violates user expectations. When a user revokes an access key, they expect immediate effect. Allowing keychain signatures for subblock txs would create a window where revoked keys can still authorize transactions.

**Alternative considered**: Re-validate keychain signatures during execution. This was rejected because:
- Adds execution-time overhead for every subblock tx
- Creates griefing vector: users could intentionally revoke keys to cause builder's subblock to fail
- Complicates the execution model

Root-only signing is the simplest solution that maintains user expectations around key revocation.

---

# Implementation Notes

## Relationship to Current Implementation

The current implementation stores subblock-related configuration as follows:

| Data | Current Location | TIP-1017 Location |
|------|------------------|-------------------|
| Fee recipient address | CLI arg (`--consensus.fee-recipient`) | `SubblockRegistry.builderConfig[builder].feeRecipient` |
| Subblock signing key | CLI arg (`--consensus.signing-key`), ed25519 | Builder's Ethereum address (ECDSA) |
| Subblock fee token | `TipFeeManager.validatorTokens[validator]` | `SubblockRegistry.builderConfig[builder].feeToken` |
| Proposer fee token | `TipFeeManager.validatorTokens[validator]` | Unchanged (remains in `TipFeeManager`) |

Key changes:
1. **Signing moves to ECDSA**: Currently uses ed25519 (same as consensus), becomes standard ECDSA since subblock signing is not consensus-critical
2. **Many-to-one delegation**: Validators can share a builder, accumulating gas budgets
3. **Builder configures fee routing**: The builder (not validator) sets fee recipient and token preferences
4. **Expiring nonce support**: Subblock txs can use expiring nonces by setting nonce = max uint88

---

# Migration

## Activation

This TIP activates at a specific block height. After activation:

- SubBlockVersion::V1 subblocks are rejected
- The old nonce key format (`0x5b | validator_pubkey_prefix | nonce`) is no longer valid
- Validators must delegate to a builder before their subblock gas is usable

## Migration Steps

1. **Pre-activation**: Builders call `setBuilderConfig()` to configure their fee routing
2. **Pre-activation**: Validators call `delegateToBuilder()` to delegate their gas budget
3. **Activation block**: Protocol switches to V2 subblock validation
4. **Post-activation**: V1 subblocks and old nonce key formats are rejected

Validators who want to build their own subblocks should delegate to themselves:
```solidity
SubblockRegistry.delegateToBuilder(msg.sender);
SubblockRegistry.setBuilderConfig(msg.sender, preferredFeeToken);
```
