---
id: TIP-1017
title: Validator Config V2 precompile
description: Validator Config V2 precompile for improved management of consensus participants
authors: Janis (@superfluffy)
status: Draft
---

# ValidatorConfig V2

## Abstract

TIP-1017 introduces ValidatorConfig V2, a new precompile for managing consensus participants. ValidatorConfigV2 introduces clearer tracking for accurately reconstructing validator sets for any epoch, and extra safety checks on validator input values. Validator config v2 is designed with security in mind that would allow for permissionless validator rotation. 

## Motivation

V1 allowed the chain to switch validators between `active` and `inactive`, forcing nodes to retain historical account state for each epoch. Insufficient safety checks on precompile inputs also prevented validators from rotating permissionlessly, and this was permanently disabled on Tempo by setting the addresses of validators to unowned addresses. This TIP also introduces extra safety checks on validator inputs as an extra layer of security. 

# Specification

## Precompile Address
```solidity
address constant VALIDATOR_CONFIG_V2_ADDRESS = 0xCCCCCCCC00000000000000000000000000000001;
```

## Interface

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

/// @title IValidatorConfigV2 - Validator Config V2 Precompile Interface
/// @notice Interface for managing consensus validators with append-only, delete-once semantics
interface IValidatorConfigV2 {

    /// @notice Thrown when caller lacks authorization to perform the requested action
    error Unauthorized();

    /// @notice Thrown when trying to add a validator with an address that already exists
    error AddressAlreadyHasValidator();

    /// @notice Thrown when trying to add a validator with a public key that already exists
    error PublicKeyAlreadyExists();

    /// @notice Thrown when validator is not found
    error ValidatorNotFound();

    /// @notice Thrown when trying to delete a validator that is already deleted
    error ValidatorAlreadyDeleted();

    /// @notice Thrown when public key is invalid (zero)
    error InvalidPublicKey();

    /// @notice Thrown when validator address is invalid (zero)
    error InvalidValidatorAddress();

    /// @notice Thrown when the Ed25519 signature verification fails
    error InvalidSignature();

    /// @notice Thrown when V2 is not yet initialized (writes blocked before init)
    error NotInitialized();

    /// @notice Thrown when V2 is already initialized (migration blocked after init)
    error AlreadyInitialized();

    /// @notice Thrown when migration is not complete (not all V1 validators migrated)
    error MigrationNotComplete();

    /// @notice Thrown when migration index is out of order
    error InvalidMigrationIndex();

    /// @notice Thrown when address is not in valid ip:port format
    /// @param input The invalid input that was provided
    /// @param backtrace Additional error context
    error NotIpPort(string input, string backtrace);

    /// @notice Thrown when address is not a valid IP (for egress field)
    /// @param input The invalid input that was provided
    /// @param backtrace Additional error context
    error NotIp(string input, string backtrace);

    /// @notice Thrown when trying to use an ingress IP already in use by another active validator
    /// @param ingress The ingress address that is already in use
    error IngressAlreadyExists(string ingress);

    /// @notice Validator information (V2 - append-only, delete-once)
    /// @param publicKey Ed25519 communication public key (non-zero, unique across all validators)
    /// @param validatorAddress Ethereum-style address of the validator (unique among active validators)
    /// @param ingress Address where other validators can connect (format: `<ip>:<port>`)
    /// @param egress IP address from which this validator will dial, e.g. for firewall whitelisting (format: `<ip>`)
    /// @param index Position in validators array (assigned at creation, immutable)
    /// @param addedAtHeight Block height when validator was added
    /// @param deactivatedAtHeight Block height when validator was deleted (0 = active)
    struct Validator {
        bytes32 publicKey;
        address validatorAddress;
        string ingress;
        string egress;
        uint64 index;
        uint64 addedAtHeight;
        uint64 deactivatedAtHeight;
    }

    /// @notice Get all validators in array order starting from idx.
    /// @dev The getter checks remaining gas before doing storage reads to ensure it will not fail from out-of-gas.
    /// @param idx The index of validators to start reading from
    /// @return validators Array of validators with their information
    function getAllValidators(uint256 idx) external view returns (Validator[] memory validators);

    /// @notice Get only active validators (where deactivatedAtHeight == 0)
    /// @return validators Array of active validators
    function getActiveValidators() external view returns (Validator[] memory validators);

    /// @notice Get the owner of the precompile
    /// @return The owner address
    function owner() external view returns (address);

    /// @notice Get total number of validators ever added (including deleted)
    /// @return The count of validators
    function validatorCount() external view returns (uint64);

    /// @notice Get validator information by index in the validators array
    /// @param index The index in the validators array
    /// @return The validator struct at the given index
    function validatorByIndex(uint64 index) external view returns (Validator memory);

    /// @notice Get validator information by address
    /// @param validatorAddress The validator address to look up
    /// @return The validator struct for the given address
    function validatorByAddress(address validatorAddress) external view returns (Validator memory);

    /// @notice Get validator information by public key
    /// @param publicKey The validator's public key to look up
    /// @return The validator struct for the given public key
    function validatorByPublicKey(bytes32 publicKey) external view returns (Validator memory);

    /// @notice Get the epoch at which a fresh DKG ceremony will be triggered
    /// @return The epoch number, or 0 if no fresh DKG is scheduled.
    ///         The fresh DKG ceremony runs in epoch N, and epoch N+1 uses the new DKG polynomial.
    function getNextFullDkgCeremony() external view returns (uint64);

    /// @notice Add a new validator (owner only)
    /// @dev The signature must be an Ed25519 signature over:
    ///      keccak256(bytes8(chainId) || contractAddress || validatorAddress || ingress || egress)
    ///      using the namespace "TEMPO_VALIDATOR_CONFIG_V2_ADD_VALIDATOR".
    ///      This proves the caller controls the private key corresponding to publicKey.
    ///      Reverts if isInitialized() returns false.
    /// @param validatorAddress The address of the new validator
    /// @param publicKey The validator's Ed25519 communication public key
    /// @param ingress The validator's inbound address `<ip>:<port>` for incoming connections
    /// @param egress The validator's outbound IP address `<ip>` for firewall whitelisting
    /// @param signature Ed25519 signature (64 bytes) proving ownership of the public key
    function addValidator(
        address validatorAddress,
        bytes32 publicKey,
        string calldata ingress,
        string calldata egress,
        bytes calldata signature
    ) external;

    /// @notice Deactivates a validator (owner or validator only)
    /// @dev Marks the validator as deactivated by setting deactivatedAtHeight to the current block height.
    ///      The validator's entry remains in storage for historical queries.
    ///      The public key remains reserved and cannot be reused. The address remains
    ///      reserved unless reassigned via transferValidatorOwnership.
    /// @param validatorAddress The validator address to deactivate
    function deactivateValidator(address validatorAddress) external;

    /// @notice Rotate a validator to a new identity (owner or validator only)
    /// @dev Atomically deactivates the specified validator entry and appends a new one. The same validation rules for addValidator also applies to rotateValidator.
    /// @param validatorAddress The address of the validator to rotate
    /// @param publicKey The new validator's Ed25519 communication public key
    /// @param ingress The new validator's inbound address `<ip>:<port>` for incoming connections
    /// @param egress The new validator's outbound IP address `<ip>` for firewall whitelisting
    /// @param signature Ed25519 signature (64 bytes) proving ownership of the new public key
    function rotateValidator(
        address validatorAddress,
        bytes32 publicKey,
        string calldata ingress,
        string calldata egress,
        bytes calldata signature
    ) external;

    /// @notice Update a validator's IP addresses (owner or validator only)
    /// @dev Can be called by the contract owner or by the validator's own address.
    ///      This allows validators to update their network addresses without requiring
    ///      a full rotation.
    /// @param validatorAddress The address of the validator to update
    /// @param ingress The new inbound address `<ip>:<port>` for incoming connections
    /// @param egress The new outbound IP address `<ip>` for firewall whitelisting
    function setIpAddresses(
        address validatorAddress,
        string calldata ingress,
        string calldata egress
    ) external;

    /// @notice Transfer a validator entry to a new address (owner or validator only)
    /// @dev Can be called by the contract owner or by the validator's own address.
    ///      Updates the validator's address in the lookup maps.
    ///      Reverts if the new address already exists in the validator set.
    /// @param currentAddress The current address of the validator to transfer
    /// @param newAddress The new address to assign to the validator
    function transferValidatorOwnership(address currentAddress, address newAddress) external;

    /// @notice Transfer owner of the contract (owner only)
    /// @param newOwner The new owner address
    function transferOwnership(address newOwner) external;

    /// @notice Set the epoch at which a fresh DKG ceremony will be triggered (owner only)
    /// @param epoch The epoch in which to run the fresh DKG ceremony.
    ///        Epoch N runs the ceremony, and epoch N+1 uses the new DKG polynomial.
    function setNextFullDkgCeremony(uint64 epoch) external;

    /// @notice Migrate a single validator at `idx` from V1 to V2 (owner only)
    /// @param idx Index of the validator in V1 validators array (must equal current validatorsArray.length)
    function migrateValidator(uint64 idx) external;

    /// @notice Initialize V2 and enable reads (owner only)
    /// @dev Should only be called after all validators have been migrated via migrateValidator.
    function initializeIfMigrated() external;

    /// @notice Check if V2 has been initialized from V1
    /// @return True if initialized, false otherwise
    function isInitialized() external view returns (bool);

    /// @notice Get the height at which the contract was initialized
    /// @return the height at which the contract was initialized. Note that this
    ///         value only makes sense in conjunction with isInitialized()
    function getInitializedAtHeight() external view returns (uint64);
}
```

## Changes From V1

### Validator Lifecycle

Validators in V2 follow a fixed lifecycle:
1. **Addition**: Either from `addValidator` or `migrateValidator` from V1. This creates a permanent validator entry with `addedAtHeight` set to the current block height and `deactivatedAtHeight = 0`.
2. **Active period**: Validator participates in consensus while `deactivatedAtHeight == 0`.
3. **Deactivation**: Either `deactivateValidator` or `rotateValidator` sets `deactivatedAtHeight` for that validator entry to the current block height.

Note that once `addedAtHeight` or `deactivatedAtHeight` for a validator entry is set, it cannot be set again any way. After deactivation, the validator entry will stay in storage forever.

### New V2 Safety Checks

Validator config V2 introduces additional safety checks on validator inputs over validator config V1:
1. Validator ed25519 public keys must be unique across all validators (active + inactive).
2. Validator addresses must be unique across active validators. Duplication in the set of inactive validators is allowed.
3. The ingress (previously "inbound") must be a valid IP with port (<ip>:<port>), and the IP must be unique across all active validators.
4. The egress (previously "outbound") must be a valid IP.
5. A signature must be provided over the parameters of `addValidator` or `rotateValidator` from the ed25519 key to be added. This is an anti-footgun mechanism to prevent accidentally adding the wrong key. The signature format is detailed below
6. Each validator maintains a constant `idx` value in the validator array. In V1, we used `validatorAddress` for update and delete operations, which allowed validators to front-run the call to prevent themselves from being updated or deleted by the owner. 

### Ed25519 Signature Verification on Adding a New Validator

When adding a validator, the caller must provide an Ed25519 signature proving ownership of the public key. The signature is checked over a full message containing: the length of the namespace in bytes, the namespace, and a 32-byte hashed message.

**Namespace:** `addValidator` uses `b"TEMPO_VALIDATOR_CONFIG_V2_ADD_VALIDATOR"` and `rotateValidator` uses `b"TEMPO_VALIDATOR_CONFIG_V2_ROTATE_VALIDATOR"`.

**Message:**
```
message = keccak256(
    bytes8(chainId)       // uint64: Prevents cross-chain replay
    || contractAddress    // address: Prevents cross-contract replay
    || validatorAddress   // address: Binds to specific validator address
    || ingress            // string: Binds network configuration
    || egress             // string: Binds network configuration
)
```

The Ed25519 signature is computed over the message using the namespace parameter (see commonware's [signing scheme](https://github.com/commonwarexyz/monorepo/blob/abb883b4a8b42b362d4003b510bd644361eb3953/cryptography/src/ed25519/scheme.rs#L38-L40) and [union format](https://github.com/commonwarexyz/monorepo/blob/abb883b4a8b42b362d4003b510bd644361eb3953/utils/src/lib.rs#L166-L174)).

### TODO: Consensus Layer Usage
<!-- 
**IP Address Changes**: When a validator's IP address changes via `setIpAddresses`, the consensus layer is expected to update its peer list on the next finalized block.

**Validator Addition and Deactivation**: When validators are added or deleted (this also applies to rotation),
there is no warmup period: deactivated validators are immediately removed from the set of players on the next epoch,
while activated validators are immediately added on the next epoch. This means that compared to validator config V1,
there is no cooldown and no warmup period.

**DKG Player Selection**: The consensus layer determines DKG players for epoch `E+1` by reading state at `boundary(E)` and filtering:

```
players(E+1) = validators.filter(v =>
    v.addedAtHeight <= boundary(E) &&
    (v.deactivatedAtHeight == 0 || v.deactivatedAtHeight > boundary(E))
)
```

This enables nodes to reconstruct DKG player sets without accessing historical account stateâ€”critical for node recovery and late-joining validators.

### CL Read Behavior

The CL checks `v2.isInitialized()` to determine which contract to read:

- **`initialized == false`**: CL reads from V1
- **`initialized == true`**: CL reads from V2

This is handled entirely in the CL logic, not in the V2 precompile. The V2
precompile does NOT proxy reads to V1. -->

## Migration

If validator config V2 is to be used in a new network without V1, `initializeIfMigrated` can be called immediately (with zero V1 validators) to skip migration.

Validator migration must be carefully designed and executed to prevent footguns that could cause consensus to break down, triggering a chain halt. Due to the high gas costs of `SSTORE` imposed by TIP-1000, migration is performed manually and validator-by-validator to ensure that there is no risk of too many validators causing the migration transaction to fail from out-of-gas. 

### Migration Process

1. At the hardfork timestamp or block number, validator config V2 becomes active on the network. The consensus layer still continues to read from validator config V1 during this time.
2. The owner calls `migrateValidator(0)`. The first call copies the `owner` from validator config V1 over to validator config V2.
3. The owner continues and calls `migrateValidator(idx)` for `1...n` where `n` is the total number of validators in validator config V1.
4. During this migration, if a validator goes offline, the owner is able to deactivate the validator in both the V1 and V2 contracts.
5. When all validator entries have been copied over, the owner calls `initializeIfMigrated()` which checks that all validators have been migrated over. It sets `initialized` to true which signals to the CL to start reading from validator config V2 instead of V1.
6. The owner collects addresses from each validator and calls `transferValidatorOwnership` for each entry to enable permissionless rotation.

### Permitted Calls to V2 during migration

The owner is able to call: `deactivateValidator`, `transferOwnership`, `setIpAddresses`, `migrateValidator` and `initializeIfMigrated`. 

In theory, the validator is able to call `deactivateValidator` and `setIpAddresses`, but because the addresses are unowned, they are unable to do so.

### Permitted Calls to V1 during migration

All calls are allowed to V1 during migration (after the hardfork timestamp). Note that since validator addresses are unowned, validators are unable to call any function on V1.

## Test Cases
<!-- 
The test suite must cover:

### Basic Operations

1. **Add validator**: Successfully adds a validator with valid signature
2. **Delete validator**: Successfully marks validator as deleted
3. **Change owner**: Successfully transfers ownership
4. **Set next DKG ceremony**: Successfully sets the epoch
5. **Rotate validator**: Successfully deletes old validator and adds new one atomically

### Query Functions

6. **getAllValidators**: Returns all validators including deleted with correct
   `addedAtHeight` and `deactivatedAtHeight`
7. **getActiveValidators**: Returns only validators with `deactivatedAtHeight == 0`
   (note: validators with `addedAtHeight == deactivatedAtHeight` are excluded)
8. **validatorByPublicKey**: Returns validator by public key lookup
9. **validatorCount**: Returns total count including deleted

### Error Conditions

10. **Unauthorized**: Non-owner cannot call protected functions
11. **ValidatorAlreadyExists**: Cannot re-add same address
12. **PublicKeyAlreadyExists**: Cannot re-use same public key
13. **ValidatorNotFound**: Cannot query/delete non-existent validator
14. **ValidatorAlreadyDeleted**: Cannot delete twice
15. **InvalidPublicKey**: Rejects zero public key
16. **InvalidSignature**: Rejects wrong signature, wrong length, wrong signer
17. **IngressAlreadyExists**: Cannot use ingress IP already in use by active validator (even with different port)

### rotateValidator

17. **rotateValidator by owner**: Owner can rotate any active validator
18. **rotateValidator by validator**: Validator can rotate themselves
19. **rotateValidator unauthorized**: Non-owner and non-validator cannot rotate
20. **rotateValidator already deleted**: Cannot rotate already-deleted validator
21. **rotateValidator new pubkey exists**: Cannot rotate to existing public key
22. **rotateValidator invalid signature**: Rejects invalid signature for rotation
23. **rotateValidator validator not found**: Reverts if validatorAddress does not exist
24. **rotateValidator atomicity**: Old validator is deleted and new one added in same block
25. **rotateValidator preserves index**: New validator gets next available index, old index remains deleted

### Address Validation

26. **Valid IPv4:port**: Accepts `192.168.1.1:8080`
27. **Valid IPv6:port**: Accepts `[2001:db8::1]:8080`
28. **Invalid format**: Rejects malformed addresses

### Historical Filtering (Caller-side)

29. **addedAtHeight correctness**: Validators have correct `addedAtHeight` set
    at creation
30. **deactivatedAtHeight correctness**: Deleted validators have correct
    `deactivatedAtHeight` set
31. **Filter logic**: Caller can correctly filter by
    `addedAtHeight <= H && (deactivatedAtHeight == 0 || deactivatedAtHeight > H)`

### Manual Migration

32. **migrateValidator imports validator**: Calling `migrateValidator(i)`
    correctly imports validator at index i from V1 with the same address
33. **migrateValidator copies address from V1**: The V2 validator uses the address from V1
34. **migrateValidator reverts on duplicate**: Calling `migrateValidator(i)` reverts
    if `i != validatorsArray.length`
35. **migrateValidator reverts if initialized**: Calling `migrateValidator` reverts
    if `isInitialized() == true`
36. **migrateValidator owner only**: Non-owner cannot call `migrateValidator`
37. **All validators imported on migration**: Both V1 active and inactive validators
    are imported; active ones have `addedAtHeight > 0` and `deactivatedAtHeight == 0`,
    inactive ones have `addedAtHeight == deactivatedAtHeight > 0`.
38. **addedAtHeight set correctly**: All migrated validators have `addedAtHeight > 0` (block.height at migration time).
39. **deactivatedAtHeight set correctly**: Active validators have `deactivatedAtHeight == 0`.
    Inactive validators have `addedAtHeight == deactivatedAtHeight > 0` at migration time.
40. **initialize sets flag**: After `initializeIfMigrated()`, `isInitialized()` returns true
41. **migrateValidator copies owner**: V2 `owner()` matches V1 after first `migrateValidator` call
42. **initialize copies DKG ceremony**: V2 `getNextFullDkgCeremony()` matches V1
    after `initializeIfMigrated()`
43. **initialize owner only**: Non-owner cannot call `initialize`
44. **isInitialized returns correct value**: Returns false before initialize, true after
45. **Writes blocked before init**: `addValidator`, `rotateValidator`, `transferValidatorOwnership`
46. **initialize reverts if not all migrated**: `initializeIfMigrated()` reverts if
    `validatorsArray.length < V1.getAllValidators().length`

### transferValidatorOwnership

47. **transferValidatorOwnership by owner**: Owner can transfer any validator to a new address
48. **transferValidatorOwnership by validator**: Validator can transfer themselves to a new address
49. **transferValidatorOwnership unauthorized**: Non-owner and non-validator cannot transfer
50. **transferValidatorOwnership reverts on invalid validator**: Reverts if `validatorAddress` does not exist
51. **transferValidatorOwnership reverts on duplicate address**: Reverts if `newAddress` already exists
52. **transferValidatorOwnership updates lookup maps**: Old address is removed, new address is added to lookup

### setIpAddresses

53. **setIpAddresses by owner**: Owner can update any validator's IP addresses
54. **setIpAddresses by validator**: Validator can update their own IP addresses
55. **setIpAddresses unauthorized**: Non-owner and non-validator cannot update IP addresses
56. **setIpAddresses reverts on invalid validator**: Reverts if validator does not exist
57. **setIpAddresses reverts on deactivated validator**: Reverts if validator is already deactivated
58. **setIpAddresses validates format**: Rejects invalid `<ip>:<port>` format
59. **setIpAddresses before init (self)**: Validator can update their own IPs before initialization
60. **setIpAddresses before init (owner)**: Owner can update validator IPs before initialization
61. **deactivateValidator before init (self)**: Validator can deactivate themselves before initialization
62. **deactivateValidator before init (owner)**: Owner can deactivate validators before initialization

--- -->

# Security Issues
<!-- 
## Migration Timing

The migration must be completed (including `initializeIfMigrated()`) before an epoch
boundary to avoid disrupting DKG. The admin should:

1. Schedule migration during a period with no imminent epoch transitions
2. Monitor the current epoch and time remaining
3. Complete all `migrateValidator` calls and `initializeIfMigrated()` with sufficient time buffer

# Invariants

The following invariants must always hold:

1. **Append-only array**: The `validatorsArray` length only increases; it never
   decreases.

2. **Immutable identity**: Once a validator is added, its `publicKey`,
   `index`, and `addedAtHeight` fields never change. The `ingress` and `egress`
   fields can be updated via `setIpAddresses`. `validatorAddress` can only be
   changed by the contract owner.

3. **Address update**: `transferValidatorOwnership` updates the address of an
    existing validator without changing any other fields. This can be called
    by the contract owner or by the validator themselves and is required for
    post-migration fixes: validator contract v1 contains unusable dummy addresses
    that are not usable.

4. **Delete-once**: A validator's `deactivatedAtHeight` can only transition from 0
   to a non-zero value, never back to 0 or to a different non-zero value.

5. **Unique addresses**: No two active validators can have the same
   `validatorAddress`. Deactivated addresses may be reused.

6. **Unique public keys**: No two validators (including deleted ones) can have
   the same `publicKey`.

7. **Non-zero public keys**: All validators must have a non-zero `publicKey`.

8. **Monotonic index**: Validator `index` equals its position in
   `validatorsArray` and equals `validatorCount - 1` at creation time.

9. **Historical consistency**: For any height H, the active validator set
   consists of validators where `addedAtHeight <= H && (deactivatedAtHeight == 0 ||
   deactivatedAtHeight > H)`. Validators with `addedAtHeight == deactivatedAtHeight` are
   never considered active.

10. **Signature binding**: The signature message includes `chainId`,
   `contractAddress`, `validatorAddress`, `ingress`, and
   `egress`, preventing replay across chains, contracts, or parameter
   changes.

11. **Owner authorization**: Only the owner can call `addValidator`,
    `transferOwnership`, `migrateValidator`, `initializeIfMigrated`, and
    `setNextFullDkgCeremony`.

12. **Dual authorization**:
    - `rotateValidator` and `transferValidatorOwnership` can be called by either
      the owner or the validator itself. These functions require initialization.
    - `deactivateValidator` and `setIpAddresses` can be called by the owner or the validator itself.
      These functions do NOT require initialization and can be used during migration.

13. **Initialized once**: The `initialized` bit (bit 255 of slot 0) can only
    transition from 0 to 1, never back to 0.

14. **Atomic rotation**: `rotateValidator` atomically deletes the old validator
    (setting its `deactivatedAtHeight`), adds a new validator entry, and updates
    the `addresses[validatorAddress]` mapping to point to the new entry. Both
    operations occur in the same transaction with the same block height. -->