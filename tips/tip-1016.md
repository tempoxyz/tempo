---
id: TIP-1016
title: Exempt Storage Creation from Gas Limits
description: Storage creation gas costs are charged but don't count against transaction or block gas limits, using a reservoir model aligned with EIP-8037 for correct GAS opcode semantics and EVM compatibility.
authors: Dankrad Feist @dankrad
status: Draft
related: TIP-1000, TIP-1010, EIP-8037, EIP-8011, EIP-7825
protocolVersion: TBD
---

# TIP-1016: Exempt Storage Creation from Gas Limits

## Abstract

Storage creation operations (new state elements, account creation, contract code storage) continue to consume and be charged for gas, but this gas does not count against transaction or block gas limits. Gas accounting uses a **reservoir model** (aligned with [EIP-8037](https://eips.ethereum.org/EIPS/eip-8037)) that splits execution gas into `gas_left` and `state_gas_reservoir`, ensuring the `GAS` opcode accurately reflects the remaining execution budget. This allows increasing contract code pricing to 2,500 gas/byte without preventing large contract deployments, and prevents new account creation from reducing effective throughput.

## Motivation

TIP-1000 increased storage creation costs to 250,000 gas per operation and 1,000 gas/byte for contract code. This created two problems:

1. **Contract deployment constraints**: 24KB contracts require ~26M gas, forcing us to:
   - Keep transaction gas cap at 30M (would prefer 16M)
   - Keep general gas limit at 30M (would prefer lower)
   - Limit contract code to 1,000 gas/byte (would prefer 2,500)

2. **New account throughput penalty**: TIP-20 transfer to new address costs 271,000 gas total (26k regular + 245k state) vs 24,000 gas to existing. At 500M payment lane gas limit:
   - Without exemption (single dimension): only 1,847 new account transfers/block = 3,694 TPS
   - With reservoir model (block limits apply to regular gas only): ~19,000 new account transfers/block = ~38,000 TPS
   - Existing account transfers unaffected: ~21,000 transfers/block = ~42,000 TPS
   - ~10x throughput improvement for new accounts by exempting state gas from block limits

The root cause: storage creation gas counts against limits designed for execution time constraints. Storage creation is permanent (disk) not ephemeral (CPU), and shouldn't be bounded by per-block execution limits.

### Why a reservoir model

Simply exempting storage creation gas from protocol limits without changing EVM internals creates two problems:

1. **`GAS` opcode inaccuracy**: The `GAS` opcode would return remaining gas from `tx.gas` minus all gas consumed (execution + storage), which doesn't reflect the actual execution budget. A contract that has used 15.9M execution gas with a 16M `max_transaction_gas_limit` would see `GAS` report millions of gas remaining, but OOG after just ~100k more execution gas.

2. **Broken gas patterns**: Contracts relying on `gasleft()` for loop guards, subcall gas forwarding (63/64 rule), and relay/meta-transaction patterns would see incorrect values, potentially leading to unexpected OOG reverts.

The reservoir model (from [EIP-8037](https://eips.ethereum.org/EIPS/eip-8037)) solves this by maintaining two internal counters: `gas_left` (reflecting execution budget) and `state_gas_reservoir` (holding overflow for storage creation). The `GAS` opcode returns only `gas_left`, accurately reflecting available execution capacity.

---

# Specification

## Gas Dimensions

All operations consume gas in two dimensions:

- **Regular gas** (`regular_gas`): Compute, memory, calldata, and the computational cost of storage operations (writing, hashing). This is the execution-time resource.

- **State gas** (`state_gas`): The permanent storage burden of state creation operations. This is the long-term state growth resource.

At the transaction level, the user pays for both. At the block level, only regular gas counts toward block gas limits; state gas is exempt.

## Storage Gas Operations

Storage creation operations split their cost between regular gas (computational overhead) and state gas (permanent storage burden):

| Operation | Regular Gas | State Gas | Total | Against Limits |
|-----------|-------------|-----------|-------|----------------|
| Cold SSTORE (zero → non-zero) | 5,000 | 245,000 | 250,000 | 5,000 |
| Hot SSTORE (non-zero → non-zero) | 2,900 | 0 | 2,900 | 2,900 |
| Account creation (nonce 0 → 1) | 5,000 | 245,000 | 250,000 | 5,000 |
| Contract code storage (per byte) | 200 | 2,300 | 2,500 | 200 |
| Contract metadata (keccak + nonce) | 5,000 | 495,000 | 500,000 | 5,000 |

**Notes:**
- Regular gas reflects computational cost (writing, hashing) and counts toward protocol limits
- State gas reflects permanent storage burden and does NOT count toward protocol limits
- All gas (regular + state) counts toward user's `gas_limit` and is charged at `base_fee_per_gas`
- All other operations (non-state-creating) are charged entirely as regular gas

## Transaction Validation

Before transaction execution, `calculate_intrinsic_cost` returns two values:

- `intrinsic_regular_gas`: Base transaction cost, calldata, access lists, and other non-state-creating intrinsic costs
- `intrinsic_state_gas`: State gas components of intrinsic cost (e.g., account creation for contract deployment transactions)

`validate_transaction` rejects transactions where:

```
tx.gas < intrinsic_regular_gas + intrinsic_state_gas
```

or where:

```
intrinsic_regular_gas > max_transaction_gas_limit
```

`validate_transaction` also returns `intrinsic_regular_gas` and `intrinsic_state_gas`.

## Transaction-Level Gas Accounting (Reservoir Model)

Since transactions have a single gas limit parameter (`tx.gas`), gas accounting is enforced through a **reservoir model**, in which `gas_left` and `state_gas_reservoir` are initialized as follows:

```python
intrinsic_gas = intrinsic_regular_gas + intrinsic_state_gas
execution_gas = tx.gas - intrinsic_gas
regular_gas_budget = max_transaction_gas_limit - intrinsic_regular_gas
gas_left = min(regular_gas_budget, execution_gas)
state_gas_reservoir = execution_gas - gas_left
```

The `state_gas_reservoir` holds gas that exceeds the per-transaction regular gas budget (`max_transaction_gas_limit`, per EIP-7825). The two counters operate as follows:

- **Regular gas** charges deduct from `gas_left` only.
- **State gas** charges deduct from `state_gas_reservoir` first; when the reservoir is exhausted, from `gas_left`.
- The **`GAS` opcode** returns `gas_left` only (excluding the reservoir).
- The reservoir is passed **in full** to child frames (no 63/64 rule). Unused reservoir is returned to the parent on child completion.
- On **exceptional halt**, both `gas_left` and `state_gas_reservoir` are set to zero (all gas consumed), consistent with existing EVM out-of-gas semantics. This is not applied to system transactions.

The two counters are returned by the transaction output. Besides the two counters, the EVM also keeps track of `execution_state_gas_used` and `execution_regular_gas_used` during transaction execution. `state_gas` costs are added to `execution_state_gas_used` while `regular_gas` costs are added to `execution_regular_gas_used`. These two counters are also returned by the transaction output.

## Transaction Gas Used

At the end of transaction execution, the gas used before and after refunds is defined as:

```python
tx_gas_used_before_refund = tx.gas - tx_output.gas_left - tx_output.state_gas_reservoir
tx_gas_refund = min(tx_gas_used_before_refund // 5, tx_output.refund_counter)
tx_gas_used_after_refund = tx_gas_used_before_refund - tx_gas_refund
```

The refund cap remains at 20% of gas used.

**Note**: EIP-8037 uses `tx_gas_used` in the refund and post-refund formulas, but that variable is not defined in the same code block. TIP-1016 uses `tx_gas_used_before_refund` consistently to avoid ambiguity.

## Block-Level Gas Accounting

At block level, only **regular gas** counts toward block gas limits. State gas is exempt — it is not tracked at the block level and does not constrain block capacity.

```python
tx_regular_gas = intrinsic_regular_gas + tx_output.execution_regular_gas_used

block_output.block_regular_gas_used += tx_regular_gas
```

The block header `gas_used` field is set to:

```python
gas_used = block_output.block_regular_gas_used
```

The block validity condition uses this value:

```python
assert gas_used <= block.gas_limit, 'invalid block: too much gas used'
```

The base fee update rule uses this same value:

```python
gas_used_delta = parent.gas_used - parent.gas_target
```

**Note**: Tempo has two block limits — general gas limit (~25M) for contracts and payment lane limit (500M) for simple transfers. In both lanes, only regular gas counts toward the limit; state gas is exempt.

**Divergence from EIP-8037**: EIP-8037 uses a bottleneck model where `gas_used = max(block_regular_gas, block_state_gas)`, effectively capping state gas at the block gas limit. TIP-1016 instead exempts state gas entirely from block limits, relying on fixed high prices (250,000 gas per state element) as the economic deterrent for state growth.

## SSTORE Refund for Slot Restoration

When a storage slot is set to a non-zero value and then restored to zero within the same transaction (0→X→0 pattern), the following are refunded via `refund_counter`:

- State gas: 245,000 (the full state creation charge)
- Regular gas: `GAS_STORAGE_UPDATE - GAS_COLD_SLOAD - GAS_WARM_ACCESS` (5,000 − 2,100 − 100 = 2,800)

The state creation cost is fully recouped. The net regular gas cost of the cycle is `GAS_COLD_SLOAD + 2 × GAS_WARM_ACCESS` = 2,100 + 200 = 2,300 (the irreducible access overhead from the cold read and two warm writes), consistent with pre-TIP-1016 `SSTORE` restoration behavior. Refunds use `refund_counter` rather than direct gas accounting decrements, so that reverted frames do not benefit from the refund.

## Revert Behavior for State Gas

Once state gas is charged for account creation (during successful `CREATE`/`CREATE2`, `CALL` to new account), it is consumed even if the parent frame subsequently reverts — state changes are rolled back but gas is not refunded. This is consistent with existing EVM behavior where `GAS_NEW_ACCOUNT` was consumed on revert.

## Receipt Semantics

Receipt `cumulative_gas_used` tracks the cumulative sum of `tx_gas_used_after_refund` (post-refund) across transactions. This means `receipt[i].cumulative_gas_used - receipt[i-1].cumulative_gas_used` equals the gas paid by transaction `i`.

## Contract Creation Pricing

Contract code storage cost increases from 1,000 to **2,500 gas/byte** (200 regular + 2,300 state).

### Contract Deployment Cost Calculation

When a contract creation transaction or opcode (`CREATE`/`CREATE2`) is executed, gas is charged differently based on whether the deployment succeeds or fails. Given bytecode `B` (length `L`) returned by initcode and `H = keccak256(B)`:

**When opcode execution starts:** Always charge `GAS_CREATE` (5,000 regular + 495,000 state for keccak hash and codesize metadata fields)

**During initcode execution:** Charge the actual gas consumed by the initcode execution

**Success path** (no error, not reverted, and `L ≤ MAX_CODE_SIZE`):
- If the target account is new, charge account creation (5,000 regular + 245,000 state)
- Charge `GAS_CODE_DEPOSIT * L` (200 regular + 2,300 state per byte) and persist `B` under `H`, then link `codeHash` to `H`

**Failure paths** (REVERT, OOG/invalid during initcode, OOG during code deposit, or `L > MAX_CODE_SIZE`):
- Do NOT charge account creation or `GAS_CODE_DEPOSIT * L`
- No code is stored; no `codeHash` is linked to the account
- The account remains unchanged or non-existent

This is aligned with EIP-8037's deployment flow, where `GAS_NEW_ACCOUNT` is charged only on the success path.

### Example: 24KB Contract Deployment

- Contract code regular gas: `24,576 × 200 = 4,915,200`
- Contract code state gas: `24,576 × 2,300 = 56,524,800`
- Contract metadata regular gas: `5,000`
- Contract metadata state gas: `495,000`
- Account creation regular gas: `5,000`
- Account creation state gas: `245,000`
- Deployment logic regular gas: ~2M

**Totals:**
- Regular gas: ~7M (counts toward protocol limits via `gas_left`)
- State gas: ~57M (served from `state_gas_reservoir`, doesn't count toward protocol limits)
- Total gas: ~64M (user must authorize with `gas_limit >= 64M`)
- **Can deploy with protocol max_transaction_gas_limit = 16M** (only ~7M regular gas counts)

## Examples

### TIP-20 Transfer to New Address
- Transfer logic: ~21,000 regular gas
- New balance slot: 5,000 regular gas + 245,000 state gas
- **Total**: 26,000 regular gas + 245,000 state gas = 271,000 gas
- User must authorize: `gas_limit >= 271,000`
- Reservoir initialization (assuming `max_transaction_gas_limit = 16M`):
  - `intrinsic_gas = intrinsic_regular + intrinsic_state ≈ 21,000 + 0 = 21,000`
  - `execution_gas = 271,000 - 21,000 = 250,000`
  - `regular_gas_budget = 16M - 21,000 ≈ 15,979,000`
  - `gas_left = min(15,979,000, 250,000) = 250,000`
  - `state_gas_reservoir = 250,000 - 250,000 = 0`
  - Since total < `max_transaction_gas_limit`, all gas fits in `gas_left`; state gas draws from `gas_left`
- `GAS` opcode accurately reflects execution budget (~250,000 before execution)
- Block accounting: adds 26,000 to `block_regular_gas_used` (state gas is exempt from block limits)
- Total cost: 271,000 gas

### TIP-20 Transfer to Existing Address
- Transfer logic: ~21,000 regular gas
- Update existing slot: ~2,900 regular gas (hot SSTORE)
- **Total**: ~24,000 regular gas (no state gas)
- User must authorize: `gas_limit >= 24,000`
- Counts toward block limit: ~24,000 regular gas
- Total cost: ~24,000 gas

### Block Throughput
At 500M payment lane gas limit (only regular gas counts toward block limits):

- **New account transfers**: ~26k regular gas each → ~19,000 transfers/block ≈ 38,000 TPS
- **Existing account transfers**: ~24k regular gas each → ~21,000 transfers/block ≈ 42,000 TPS
- **Mixed workload**: Only regular gas constrains capacity. A block can contain any mix of new and existing transfers as long as total regular gas ≤ 500M. State gas doesn't reduce block capacity.
- **vs TIP-1000**: ~19,000 new account transfers/block vs 1,845 in TIP-1000 (~10x improvement)

---

# Invariants

1. **User Authorization**: Total gas used (regular + state) MUST NOT exceed `transaction.gas_limit` (prevents surprise costs)
2. **Protocol Transaction Limit**: Regular gas (via `gas_left`) MUST NOT exceed `max_transaction_gas_limit` (EIP-7825 limit, e.g. 16M)
3. **Protocol Block Limits**: Block `regular_gas` MUST NOT exceed applicable limit:
   - General transactions: `general_gas_limit` (25M target, currently 30M)
   - Payment lane transactions: `payment_lane_limit` (500M)
4. **State Gas Exemption**: State gas MUST NOT count toward protocol limits (transaction or block). State gas is uncapped at the block level.
5. **Reservoir Model**: Gas accounting MUST use the reservoir model — `gas_left` and `state_gas_reservoir` initialized from `tx.gas`, with state gas drawing from reservoir first
6. **GAS Opcode**: The `GAS` opcode MUST return `gas_left` only (excluding `state_gas_reservoir`)
7. **Reservoir Passing**: The `state_gas_reservoir` MUST be passed in full to child frames (no 63/64 rule). Unused reservoir MUST be returned to parent on child completion
8. **Exceptional Halt**: On exceptional halt, both `gas_left` and `state_gas_reservoir` MUST be set to zero
9. **Regular Gas Component**: Storage creation operations MUST charge regular gas for computational overhead (writing, hashing)
10. **Total Cost**: Transaction cost MUST equal `(regular_gas + state_gas) × (base_fee_per_gas + priority_fee)`
11. **Gas Split**: Storage creation operations MUST split cost into regular gas (computational) and state gas (permanent burden)
12. **Hot vs Cold**: Hot SSTORE (non-zero → non-zero) has NO state gas component; cold SSTORE (zero → non-zero) has both
13. **Refund via Counter**: SSTORE slot restoration refunds MUST use `refund_counter`, not direct gas decrements
14. **Revert Behavior**: Account creation state gas MUST be consumed even if the parent frame reverts

---

# Changes from TIP-1000

| Parameter | TIP-1000 | TIP-1016 |
|-----------|----------|----------|
| Gas accounting model | Single dimension | Reservoir model (`gas_left` + `state_gas_reservoir`) |
| `GAS` opcode returns | Total remaining gas | `gas_left` only (execution budget) |
| Contract code pricing | 1,000 gas/byte | 2,500 gas/byte (200 regular + 2,300 state) |
| Cold SSTORE pricing | 250,000 gas | 250,000 gas (5,000 regular + 245,000 state) |
| Account creation pricing | 250,000 gas | 250,000 gas (5,000 regular + 245,000 state) |
| Storage creation gas counts toward user's gas_limit | Yes | Yes (no change) |
| Storage creation gas counts toward protocol limits | Yes | No (exempt via reservoir model) |
| Execution gas counts toward protocol limits | Yes | Yes (no change) |
| Max transaction gas limit (EIP-7825) | 30M | Can reduce to 16M |
| Block gas limit for execution | 30M | 25M (ideal target) |
| Block gas limit for payments lane | 500M | 500M (unchanged) |
| Block gas accounting | Single counter | Regular gas only; state gas exempt from block limits |

---

# Alignment with EIP-8037

This TIP adopts the **reservoir model** from [EIP-8037](https://eips.ethereum.org/EIPS/eip-8037) for transaction-level gas accounting, with the following Tempo-specific differences:

| Aspect | EIP-8037 | TIP-1016 |
|--------|----------|----------|
| State gas pricing | Dynamic `cost_per_state_byte` scaling with block gas limit | Fixed costs (e.g., 245,000 per slot) — Tempo uses fixed high prices for state growth protection |
| Gas cost harmonization | Harmonizes all state creation to uniform cost-per-byte | Maintains Tempo-specific pricing from TIP-1000 |
| Target state growth | 100 GiB/year dynamic target | Economic deterrence via fixed high costs |
| Block-level gas accounting | Bottleneck model: `max(block_regular_gas, block_state_gas)` | Regular gas only; state gas fully exempt from block limits |
| Block gas limit range | 60M–300M+ (Ethereum L1 scaling) | 25M general + 500M payment lane (Tempo dual-lane) |
| Quantization | Top-5 significant bits with offset for `cost_per_state_byte` | Not applicable (fixed costs) |
| Contract deployment | `GAS_NEW_ACCOUNT` charged on success path only | Same as EIP-8037 |

The core EVM mechanism — reservoir model, `GAS` opcode semantics, SSTORE refund/revert behavior, contract deployment flow, and receipt semantics — is shared with EIP-8037, minimizing implementation divergence from upstream. The key divergence is at the block level: TIP-1016 exempts state gas entirely from block limits rather than using EIP-8037's bottleneck model.

---

# Key Benefits

1. **Higher contract code pricing**: 2,500 gas/byte (vs 1,000) provides better state growth protection ($50M for 1TB vs $20M)
2. **Lower protocol transaction limit**: Can use 16M max_transaction_gas_limit while deploying 24KB contracts (~7M regular gas counts)
3. **Better throughput for new accounts**: ~19,000 new account transfers/block vs 1,845 in TIP-1000 (~10x improvement); existing-only transfers reach ~21,000/block
4. **Accounts for computational cost**: Storage operations still charge regular gas for writing/hashing (not completely free)
5. **No surprise costs**: User's `gas_limit` still bounds total cost (no griefing)
6. **Correct `GAS` opcode**: Reservoir model ensures `GAS`/`gasleft()` accurately reflects execution budget, preserving contract compatibility
7. **EIP-8037 alignment**: Shared EVM mechanism with Ethereum L1 reduces implementation divergence and tech debt

## Economic Impact

| Operation | TIP-1000 Cost | TIP-1016 Cost |
|-----------|---------------|---------------|
| TIP-20 transfer (existing) | ~50k gas = 0.1 cent | ~24k gas = 0.05 cent |
| TIP-20 transfer (new) | ~300k gas = 0.6 cent | ~271k gas = 0.54 cent |
| 1KB contract | ~1.75M gas = 3.5 cents | ~3.25M gas = 6.5 cents |
| 24KB contract | ~30M gas = 60 cents | ~64M gas = 128 cents |

Cost calculations assume base_fee = 2 × 10^10 attodollars (1 token unit = 1 microdollar = 10^-6 USD).

**Note**: Costs are similar to TIP-1000, but protocol limits now only count regular gas via the reservoir model, enabling higher contract code pricing and better throughput.
