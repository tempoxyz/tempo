---
id: TIP-1019
title: Subblocks v2 - Builder Delegation
description: Separates subblock builder identity from validator identity with many-to-one delegation, ed25519 subblock signing via registered p2p keys, and expiring nonce support.
authors: Mallesh Pai
status: Draft
related: Subblock Specification, TIP-1009
protocolVersion: TBD
---

# TIP-1019: Subblocks v2 - Builder Delegation

## Abstract

This TIP introduces major changes to the subblock system:

1. **Builder Delegation**: Validators delegate subblock production to a builder identified by an address. Multiple validators can delegate to the same builder, who accumulates their combined gas budget. The builder address is also the fee recipient for subblock fees.

2. **Builder P2P Keys**: Each physical builder machine has its own ed25519 key registered under the builder address in the SubblockRegistry (max 4 per builder). These keys serve dual purpose: commonware p2p authentication and subblock signing.

3. **Nonce Key Format**: The nonce key format changes to `0x5b | builder_address | nonce_remainder`, embedding the builder's 20-byte address directly in the transaction.

4. **Expiring Nonces in Subblocks**: Subblock transactions can use expiring nonces by setting the nonce remainder to all 1s (`0xFFFF...`).

5. **Fee failure semantics**: When a subblock transaction cannot pay fees (e.g., user emptied their account in the main block), the transaction becomes a **noop** but the **nonce is still incremented**. The block remains valid.

## Motivation

The current subblock design has several limitations:

1. **Validator coupling**: The validator's consensus key must also sign subblocks, meaning validators cannot delegate subblock production to separate infrastructure without sharing their consensus key.

2. **One-to-one only**: Each validator must run their own subblock builder; there is no way to delegate to a shared builder.

3. **No expiring nonces**: Subblock transactions require sequential nonces within their nonce key, preventing use of expiring nonces (TIP-1009).

4. **No high availability**: A single builder machine failure takes down subblock production for that validator. There is no mechanism for multiple machines to operate under a shared identity. The latter is because the CommonwareP2P network is authenticated, and each machine joining the network must have a unique identity. 

This TIP addresses these issues by:

- Allowing validators to delegate to builders identified by address
- Supporting many-to-one delegation where multiple validators share a builder
- Each builder machine has its own ed25519 key for both p2p authentication and subblock signing — no shared key material (KMS/HSM) required
- Enabling expiring nonces within subblock transactions

---

# Specification

## Definitions

- **Parent post-state**: The world state after executing the parent block — equivalently, the state at the very start of the current block, before any of its transactions execute.
- **Nonce key** (`nonceKey`): The full `U256` routing key embedded in a transaction, structured as `0x5b | builder_address | nonce_remainder`.
- **Nonce remainder** (`nonce_remainder`): The low 11 bytes (`uint88`) of the nonce key. Each unique nonce remainder selects an independent nonce lane: the NonceManager tracks a sequential counter per `(account, nonceKey)` pair, where `nonceKey` is the full 32-byte value including the remainder. The transaction's `nonce` field must match that lane's on-chain counter and is unconditionally incremented. For expiring nonces, the nonce remainder is set to max uint88 (see Section 3).
- **Builder address**: A 20-byte address that identifies the builder and serves as the fee recipient. Must be capable of calling `registerP2pKey`, `removeP2pKey`, and `FeeManager.setValidatorToken`.
- **Validator in the set**: An address that is an active validator in `ValidatorConfig`. (Currently: non-zero `publicKey`; after ValidatorConfig V2: `deactivatedAtHeight == 0`.)
- **Gas weight**: The number of validators in the set currently delegating to a given builder. Computed on the fly from `delegatedBuilder` mappings and the current validator set — not stored on-chain.

## 1. Subblock Registry

A new Subblock Registry precompile stores validator delegations and builder p2p key registrations.

### 1.1 Storage

```solidity
// Validator → builder address they delegate to (zero = not delegated)
mapping(address => address) public delegatedBuilder;

// Builder address → registered ed25519 p2p keys (max 4)
mapping(address => bytes32[]) public p2pKeys;
```

**Gas weight** is not stored on-chain. Since there are few builders (only those with at least one delegation from a validator in the set), nodes keep all builder configs in memory and compute gas weight on the fly by counting `delegatedBuilder` entries from validators currently in the set.

**Fee token preference** is not stored in SubblockRegistry. Builders set their preferred fee token via the existing `FeeManager.setValidatorToken(token)`, which is permissionless (any address can call it). During subblock execution, `block.beneficiary` is temporarily set to the builder address, so `FeeManager.validatorTokens[builder]` is consulted for fee routing — the same mechanism used for proposer fees.

### 1.2 Interface

```solidity
interface ISubblockRegistry {
    // ========== Delegation ==========

    /// @notice Delegates the caller's subblock production to a builder.
    /// @param builder The builder's address (also the fee recipient).
    /// @dev Sets delegatedBuilder[msg.sender] = builder.
    /// @dev Anyone can call, but only delegations from validators in the set
    ///      contribute to gas weight.
    /// @dev Requires p2pKeys[builder].length > 0 (builder has at least one registered key).
    function delegateToBuilder(address builder) external;

    /// @notice Clears the caller's delegation.
    /// @dev Sets delegatedBuilder[msg.sender] = address(0).
    function clearDelegation() external;

    // ========== Builder Functions ==========

    /// @notice Registers an ed25519 p2p key under the caller's builder address.
    /// @param p2pPubkey The ed25519 public key for p2p authentication and subblock signing.
    /// @param signature Ed25519 signature from p2pPubkey over
    ///        keccak256(abi.encodePacked("TEMPO_SUBBLOCK_REGISTER_P2P_KEY", chainId, address(this), msg.sender))
    ///        proving the caller controls the corresponding private key.
    /// @dev Max 4 p2p keys per builder. Reverts if limit exceeded.
    /// @dev Reverts if p2pPubkey is already registered to any builder.
    function registerP2pKey(bytes32 p2pPubkey, bytes calldata signature) external;

    /// @notice Removes an ed25519 p2p key from the caller's builder address.
    /// @param p2pPubkey The ed25519 public key to remove.
    /// @dev Reverts if p2pPubkey is not registered to the caller.
    function removeP2pKey(bytes32 p2pPubkey) external;

    // ========== View Functions ==========

    /// @notice Returns the builder a validator has delegated to.
    function builderOf(address validator) external view returns (address);

    /// @notice Returns the p2p keys registered to a builder.
    function p2pKeysOf(address builder) external view returns (bytes32[] memory);
}
```

### 1.3 Behavior

**Registry state snapshot:** All registry lookups (delegations, p2p keys) during subblock validation and execution use the **parent post-state**. Mutations within the current block do not affect that block's subblock validity or fee routing.

**Delegation:**
- Anyone can call `delegateToBuilder()`, but only delegations from validators in the set contribute to gas weight
- When delegating, any existing delegation is cleared first
- Delegation requires the builder to have at least one registered p2p key
- On-chain delegation changes take effect immediately in the next block

**P2P keys:**
- Each builder can register up to 4 ed25519 p2p keys (one per physical machine)
- These keys serve dual purpose: commonware p2p authentication and subblock signing
- `registerP2pKey()` requires an ed25519 signature from the p2p key over a domain-separated message including `chainId`, the SubblockRegistry address, and the caller's address. This prevents key sniping (an attacker registering someone else's key to grief them).
- `registerP2pKey()` reverts if the key is already registered to any builder
- `removeP2pKey()` reverts if the key is not owned by the caller
- A builder MAY remove all their p2p keys even while validators delegate to them. This effectively disables their subblock production until a key is re-registered.

**Gas weight (computed, not stored):**
- Gas weight for a builder is the count of validators **in the set** whose `delegatedBuilder` points to that builder
- Computed on the fly from the current validator set and `delegatedBuilder` mappings
- When a validator leaves the set, their delegation entry becomes inert — it is not counted toward gas weight since the validator is no longer in the set. No cleanup callback is needed.

**Fee token:**
- Builders set their preferred fee token by calling `FeeManager.setValidatorToken(token)` from the builder address
- This is the same mechanism validators use
- If `FeeManager.validatorTokens[builder]` is unset (zero), fees are routed in PathUSD (the FeeManager default). Builders SHOULD set an explicit preference to ensure predictable fee routing.

### 1.4 Precompile Address

```
SUBBLOCK_REGISTRY_ADDRESS = 0x0b10c0000000000000000000000000000000000X  // TBD
```

The precompile address will be assigned before activation. Does not affect wire format or spec semantics.

### 1.5 Relationship to ValidatorConfig

The SubblockRegistry is a **separate precompile** from ValidatorConfig. It reads the current validator set to determine which delegations contribute to gas weight:

```
┌─────────────────────┐  reads   ┌─────────────────────┐
│   ValidatorConfig   │◄─────────│   SubblockRegistry  │
│                     │          │                     │
│  (validator set)    │          │ - delegatedBuilder  │
│                     │          │ - p2pKeys           │
└─────────────────────┘          └─────────────────────┘
     Source of truth               Builder delegation
     for validator set             and p2p key config
```

- ValidatorConfig defines **who is in the validator set** (used for consensus)
- SubblockRegistry tracks **builder delegations and p2p keys** (separate from consensus)
- No callback from ValidatorConfig is needed; gas weight is computed on the fly

### 1.6 P2P Peer Set

Builder p2p keys whose owning builder has gas weight > 0 are included in the peer set alongside validators. The node reads active builder p2p keys from SubblockRegistry and adds them to the commonware p2p oracle, allowing builder machines to join the authenticated network.

**Key distinction:**
- Builder p2p keys (ed25519) are authorized for **subblock delivery only**, not consensus participation
- P2P peer set updates occur **per-block**, on a best-effort basis

---

## 2. Nonce Key Format

### 2.1 Subblock Nonce Key

Subblock transactions use the following nonce key format (big-endian, byte 0 = MSB, matching `U256::to_be_bytes()`):

```
32 bytes total:
┌──────────────────┬──────────────────────────────────┬──────────────────────────┐
│ 0x5b (1 byte)    │ builder_address (20 bytes)        │ nonce_remainder (11 bytes)│
├──────────────────┼──────────────────────────────────┼──────────────────────────┤
│ byte 0 (MSB)     │ bytes 1-20                       │ bytes 21-31 (LSB)        │
└──────────────────┴──────────────────────────────────┴──────────────────────────┘
```

- **Byte 0 (MSB)**: `0x5b` prefix identifying this as a subblock transaction
- **Bytes 1-20**: Builder's 20-byte address (also the fee recipient)
- **Bytes 21-31**: 11-byte nonce remainder (2^88 possible values)

### 2.2 V1 vs V2 Nonce Key Discrimination

Both V1 and V2 nonce keys use the `0x5b` prefix. The version is determined by **fork activation height**, not by the nonce key format:

| Version | Bytes 1-15 | Bytes 16-20 | Bytes 21-31 |
|---------|------------|-------------|-------------|
| V1 | PartialValidatorKey (15 bytes) | nonce high bytes | nonce low bytes |
| V2 | builder_address[0..15] | builder_address[15..20] | nonce_remainder (11 bytes) |

Before activation height: V1 interpretation. After activation height: V2 interpretation.

### 2.3 Nonce Key Construction

```
nonceKey = (0x5b << 248) | (builder_address << 88) | nonce_remainder
```

### 2.4 Builder Extraction

```
builder_address = address(nonceKey[1..21])  // 20 bytes
```

The extracted address is verified against the `builder` field in the SubBlock/SubBlockMetadata.

### 2.5 Nonce Remainder Extraction

```solidity
function extractNonceRemainder(uint256 nonceKey) pure returns (uint88) {
    return uint88(nonceKey);
}
```

### 2.6 Subblock Transaction Detection

```solidity
function isSubblockTx(uint256 nonceKey) pure returns (bool) {
    return uint8(nonceKey >> 248) == 0x5b;
}
```

---

## 3. Expiring Nonces in Subblocks

### 3.1 Motivation

TIP-1009 introduced expiring nonces for parallel transaction submission without sequential ordering. This TIP extends that support to subblock transactions.

### 3.2 Detection

A subblock transaction uses expiring nonce semantics if:
1. The nonce key has `0x5b` prefix (byte 0)
2. The nonce remainder (bytes 21-31) is all 1s: `0xFFFFFFFFFFFFFFFFFFFFFF` (max uint88, 11 bytes)

```solidity
uint88 constant EXPIRING_NONCE_MARKER = type(uint88).max;  // 0xFFFFFFFFFFFFFFFFFFFFFF

function isSubblockExpiringNonce(uint256 nonceKey) pure returns (bool) {
    return isSubblockTx(nonceKey) && extractNonceRemainder(nonceKey) == EXPIRING_NONCE_MARKER;
}
```

### 3.3 Nonce Key Format (Expiring)

```
32 bytes total:
┌──────────────────┬──────────────────────────────────┬──────────────────────────┐
│ 0x5b (1 byte)    │ builder_address (20 bytes)        │ 0xFFF...FF (11 bytes)    │
├──────────────────┼──────────────────────────────────┼──────────────────────────┤
│ byte 0 (MSB)     │ bytes 1-20                       │ bytes 21-31 = max        │
└──────────────────┴──────────────────────────────────┴──────────────────────────┘
```

### 3.4 Replay Protection

Subblock expiring nonce transactions follow TIP-1009 semantics:
- `validBefore` field is required
- `nonce` field must be `0`
- Replay protection via transaction hash + **same circular buffer** as TIP-1009
- Same validity window (30 seconds max)

The only difference from standard expiring nonces is the nonce key format, which routes the transaction to a specific builder. The replay protection shares the same `expiringNonceSeen` and `expiringNonceRing` storage as regular expiring nonces — no separate buffer is needed since the transaction hash is globally unique.

### 3.5 Nonce Key Construction (Expiring)

```
expiringNonceKey = (0x5b << 248) | (builder_address << 88) | EXPIRING_NONCE_MARKER
```

---

## 4. Signed Subblock Structure

### 4.1 SubBlock

```rust
struct SubBlock {
    version: SubBlockVersion,    // V2 for this spec
    parent_hash: B256,           // Block hash this subblock builds on
    builder: Address,            // Builder's address (= fee recipient)
    chain_id: u64,               // Chain ID for cross-chain replay protection
    transactions: Vec<Transaction>,
}
```

### 4.2 SignedSubBlock

```rust
struct SignedSubBlock {
    subblock: SubBlock,
    signer: B256,      // ed25519 public key that signed this subblock
    signature: Bytes,  // ed25519 signature
}
```

The `signer` is one of the builder's registered p2p keys. Verification:
1. `ed25519_verify(signer, signature_hash, signature)` — valid signature
2. `signer` is in `p2pKeys[subblock.builder]` — signer is registered to this builder

### 4.3 Signature Computation

```
signature_hash = keccak256(0x78 || RLP(subblock))
signature = ed25519_sign(p2p_private_key, signature_hash)
```

### 4.4 Signature Verification

```
hash = keccak256(0x78 || RLP(subblock))
valid = ed25519_verify(signed.signer, hash, signed.signature)
       && signed.signer in p2pKeys[signed.subblock.builder]
```

### 4.5 Version

This TIP introduces `SubBlockVersion::V2`. Nodes MUST reject V1 subblocks after activation.

---

## 5. Subblock Metadata

### 5.1 SubBlockMetadata

The proposer includes metadata about included subblocks in a system transaction:

```rust
struct SubBlockMetadataEntry {
    version: SubBlockVersion,   // V2
    builder: Address,           // Builder's address (= fee recipient)
    signer: B256,               // ed25519 public key that signed the subblock
    tx_start_index: u32,        // Index of first tx in block
    tx_count: u32,              // Number of transactions (may be 0 for empty subblocks)
    signature: Bytes,           // ed25519 signature
}

struct SubBlockMetadata {
    entries: Vec<SubBlockMetadataEntry>,
}
```

The `builder` address is both the on-chain identity and the fee recipient. No separate `fee_recipient` field is needed. The `builder` field is kept explicitly in metadata (rather than derived from `signer`) so that verification does not require a reverse lookup.

### 5.2 Metadata Validation

During block execution, the SubBlockMetadata system transaction is processed:

1. For each entry (all lookups at parent post-state):
   a. Reconstruct the SubBlock from block data:
      - `version` = `entry.version`
      - `parent_hash` = block header's parent hash
      - `builder` = `entry.builder`
      - `chain_id` = chain's ID
      - `transactions` = block transactions `[entry.tx_start_index .. entry.tx_start_index + entry.tx_count)`
   b. Compute `hash = keccak256(0x78 || RLP(reconstructed_subblock))`
   c. Verify ed25519 signature: `ed25519_verify(entry.signer, hash, entry.signature)`
   d. Verify signer is registered to builder: `entry.signer` is in `p2pKeys[entry.builder]`
   e. Verify all transactions in range have nonce key builder_address matching `entry.builder`
   f. Verify gas weight > 0 for `entry.builder` (at least one validator in the set delegates to this builder)

2. Verify metadata entry ranges are non-overlapping, ordered, and within block bounds
3. Every `0x5b` transaction in the block MUST be covered by exactly one metadata entry
4. Metadata entries MUST NOT cover non-`0x5b` transactions
5. At most one metadata entry per builder address
6. A SubBlockMetadata system transaction MUST be present (and last) whenever any subblock metadata entries exist — including entries for empty subblocks (`tx_count == 0`). The trigger is "subblocks were included," not "0x5b transactions exist." Empty subblocks matter because they unlock gas budget for the incentive lane.
7. Empty subblocks (`tx_count == 0`) are valid. They carry a signature proving the builder was active, and including them unlocks the builder's gas budget for the incentive lane (see Section 5.3). For an empty entry, `tx_start_index` is ignored.

### 5.3 Gas Budget Enforcement

Each builder's subblock is limited by their accumulated gas budget:

```
per_validator_gas = (block_gas_limit / TEMPO_SHARED_GAS_DIVISOR) / num_validators
builder_gas_budget = per_validator_gas × gas_weight(builder)
```

During validation:
1. Compute gas weight for the builder (count of validators in the set with `delegatedBuilder == builder`, at parent post-state)
2. Compute builder's gas budget as `per_validator_gas × gas_weight`
3. Verify subblock's total gas does not exceed budget

By including a builder's subblock, the proposer unlocks the builder's **entire** gas budget for the gas incentive lane (see Section 9.3), regardless of how much of it the subblock actually uses.

---

## 6. Fee Routing

### 6.1 Fee Recipient

For subblock transactions, the fee recipient is the **builder address** itself. During subblock execution, `block.beneficiary` is temporarily set to the builder address (extracted from the nonce key, bytes 1-20), matching the existing V1 mechanism.

### 6.2 Fee Token Resolution

The user's fee token is resolved using standard Tempo resolution:
1. Transaction's explicit `fee_token` field (if set)
2. User's default fee token preference (from user config)
3. Inference from transaction context
4. PathUSD (default)

### 6.3 Fee Token Swap

The builder's preferred fee token is read from `FeeManager.validatorTokens[builder]`. If the user's fee token differs from the builder's preference:
- If sufficient FeeAMM liquidity exists, swap to the builder's preferred token using the same swap mechanism as proposer fee swaps
- If insufficient liquidity, the builder receives the user's fee token directly

> **V2 change from V1**: In V1, insufficient swap liquidity causes `checkSufficientLiquidity` in `collectFeePreTx` to revert, triggering the fee failure path (noop + nonce increment, builder receives nothing). V2 introduces a graceful fallback: when swap liquidity is insufficient, the builder receives the user's fee token directly instead of the transaction becoming a noop. This ensures builders are always compensated for included transactions.

The transaction is **never invalidated** due to missing AMM liquidity. If the builder has not set a fee token preference, fees are routed in PathUSD (the FeeManager default).

### 6.4 Fee Failure

If a subblock transaction cannot pay fees (e.g., user emptied their account in the main block), the transaction becomes a **noop** but the **nonce is still incremented**. The block remains valid.

### 6.5 Transaction Failure Semantics

The following failures **invalidate the block** (consensus-critical):
- Malformed transaction (invalid encoding, missing fields)
- Invalid transaction signature
- Invalid nonce (nonce too high, nonce too low, nonce gaps within a nonce key)
- Nonce key builder_address does not match the metadata entry's builder
- SubBlockMetadata validation failures (see Section 5.2)

The only per-transaction failure that does **not** invalidate the block:
- **Fee payment failure**: transaction becomes a noop, nonce is still incremented, block remains valid

All other transaction execution outcomes (revert, out-of-gas) follow standard Tempo execution semantics.

---

## 7. Transaction Routing

### 7.1 Builder Endpoint

Subblock builders MUST expose an RPC endpoint for receiving subblock transactions from users. Users submit transactions to the builder whose address matches their nonce key. Builders SHOULD authenticate incoming requests (e.g., verify sender signature before full transaction decode) to mitigate DDoS.

### 7.2 Subblock Delivery via P2P

Builder machines join the authenticated commonware p2p network using their ed25519 p2p keys. They send signed subblocks directly to the next proposer via p2p, the same mechanism used in V1.

The proposer stores received subblocks and selects them for inclusion during block building.

### 7.3 Builder P2P Authorization

Builder p2p keys whose owning builder has gas weight > 0 are added to the per-block peer set. When a builder's gas weight drops to zero (all validators undelegated or removed from the set), their p2p keys are removed from the authorized set.

Builder p2p keys are authorized for **subblock delivery only**, not consensus participation.

### 7.4 High Availability

This design supports high availability without shared key material: multiple physical machines can operate under a single builder address, each with its own registered ed25519 key. Each machine independently builds and signs subblocks; the proposer deduplicates by selecting the best one (see Section 10.3).

---

## 8. End-to-End Flow

### 8.1 Setup (Once per Builder)

```
1. Builder selects an address to receive fees
2. Builder calls FeeManager.setValidatorToken(preferredToken) to set fee token preference
3. For each physical machine:
   a. Generate an ed25519 keypair for p2p identity and subblock signing
   b. Builder calls SubblockRegistry.registerP2pKey(p2pPubkey, signature) from the builder address
   c. Start commonware p2p node with the machine's ed25519 key
```

### 8.2 Setup (Once per Validator)

```
1. Validator selects a builder to delegate to (by address)
2. Validator calls SubblockRegistry.delegateToBuilder(builderAddress)
```

### 8.3 Transaction Creation (User)

```
1. User selects a builder by address
2. User constructs nonce key: 0x5b | builder_address | nonce_remainder
   - For sequential: nonce_remainder = next available value
   - For expiring: nonce_remainder = 0xFFF...FF (max uint88)
3. User signs transaction with ROOT EOA key (no keychain)
4. User submits transaction to builder's RPC endpoint
```

### 8.4 Subblock Building (Builder Machine)

```
1. Builder machine collects transactions matching its builder address in nonce key
2. Builder machine validates each transaction (nonce, balance, execution)
3. Builder machine orders transactions, respects gas budget
4. Builder machine creates SubBlock with parent_hash = current chain tip, chain_id
5. Builder machine signs with its own ed25519 key → SignedSubBlock
6. Builder machine sends to next proposer via commonware p2p
```

### 8.5 Block Building (Proposer)

```
1. Proposer receives SignedSubBlocks from builder machines via p2p
2. For each subblock (using parent post-state for all lookups):
   a. Verify ed25519 signature against signed.signer
   b. Verify signer is in p2pKeys[subblock.builder]
   c. Verify chain_id matches
   d. Verify all txs have nonce key builder_address matching subblock.builder
   e. Verify parent_hash matches current tip
   f. Verify gas_weight(builder) > 0
   g. Compute builder's gas budget from gas weight
   h. Verify total gas does not exceed budget
   i. Execute transactions, verify validity
3. Select valid subblocks: at most one subblock per builder address
   (see Section 10.3 for conflict resolution when multiple are received)
4. Order selected subblocks (proposer may choose any order)
5. Build SubBlockMetadata with version, builder, signer, tx_start_index,
   tx_count, and signature for each
6. Append SubBlockMetadata system transaction at end of block (MUST be last)
```

### 8.6 Block Execution (All Nodes)

```
1. Execute block transactions in order
2. For each 0x5b transaction:
   a. Extract builder_address from nonce key (bytes 1-20)
   b. Determine if expiring nonce (nonce_remainder = max uint88)
   c. If expiring: use TIP-1009 replay protection
   d. Else: use sequential 2D nonce semantics — the nonce key identifies an
      independent nonce sequence per (account, nonceKey) pair, stored in the
      NonceManager precompile. The nonce value must exactly match the on-chain
      state and is unconditionally incremented.
   e. Set block.beneficiary = builder_address (temporarily, for this tx)
   f. Fees are routed via FeeManager using validatorTokens[builder_address]
   g. If fee payment fails: tx becomes noop, nonce is still incremented,
      block remains valid (see Section 6.4)
   h. Restore block.beneficiary after tx
3. Process SubBlockMetadata system transaction:
   a. Verify ed25519 signatures for each entry
   b. Verify entry.signer is in p2pKeys[entry.builder] at parent post-state
   c. Verify tx ranges match actual transactions
   d. If any verification fails, block is invalid
```

---

## 9. Gas Accounting

### 9.1 Per-Validator Gas Budget

Gas budgets are computed per-validator:

```
shared_gas_limit = block_gas_limit / TEMPO_SHARED_GAS_DIVISOR
per_validator_gas = shared_gas_limit / num_validators
```

### 9.2 Builder Gas Budget

A builder's gas budget is the sum of per-validator gas for all validators in the set delegating to them:

```
builder_gas_budget = per_validator_gas × gas_weight(builder)
```

Gas weight is computed on the fly from the current validator set and `delegatedBuilder` mappings. When a validator leaves the set, their delegation is no longer counted — no cleanup is needed.

### 9.3 Gas Incentive Lane

Unused gas from subblocks becomes available for the gas incentive lane:

```
incentive_gas = Σ (builder_gas_budget - subblock_gas_used)
```

The gas incentive lane is **only available to the proposer if they include subblocks**. This creates a direct incentive for proposers to include subblocks: if a proposer omits subblocks, they forfeit access to the incentive gas pool.

By including a builder's subblock, the proposer unlocks the builder's **entire** gas budget for the incentive lane, not just the portion used by the subblock.

---

## 10. Subblock Lifecycle

### 10.1 Subblock Validity

A signed subblock is valid only if (all lookups at parent post-state):
- `parent_hash` matches the current chain tip
- `chain_id` matches the chain's ID
- The ed25519 signature verifies against `signed.signer`
- `signed.signer` is in `p2pKeys[subblock.builder]` (signer is registered to this builder)
- `gas_weight(builder) > 0` (at least one validator in the set delegates to this builder)
- All transactions have nonce key prefix `0x5b` with `builder_address` matching `subblock.builder`
- Total gas does not exceed the builder's computed gas budget

### 10.2 Subblock Expiry

Subblocks expire immediately when `parent_hash` becomes stale. Subblocks have a 1-block lifetime.

### 10.3 Conflicting Subblocks

If a builder submits multiple subblocks for the same `parent_hash` (e.g., from different machines), the proposer selects the one with the higher total `gas_limit` sum (static check, not gas used). Ties are broken by selecting the subblock with the **lower `signature_hash`** (lexicographic comparison of `keccak256(0x78 || RLP(subblock))`).

### 10.4 Cross-Builder Independence

Subblocks from different builders cannot conflict at the nonce level. Each builder's transactions use a distinct nonce key (`0x5b | builder_address | nonce_remainder`), so different builders occupy entirely independent nonce sequences in the NonceManager. The same sender can submit transactions to multiple builders without ordering conflicts.

### 10.5 Deduplication

Nodes deduplicate received subblocks by `(builder, parent_hash)`. Only the highest-`gas_limit`-sum subblock is retained per builder per parent.

---

# Invariants

## Must Hold

| ID | Invariant |
|----|-----------|
| **S1** | Gas weight correctness: Gas weight for a builder equals the count of validators in the set with `delegatedBuilder == builder`, computed on the fly |
| **S2** | Nonce key format: All 0x5b transactions have builder address in bytes 1-20 |
| **S3** | Signature validity: Subblock ed25519 signature verifies against `signer`, and `signer` is in `p2pKeys[builder]` |
| **S4** | Builder match: All transactions in a subblock have nonce key builder_address matching `subblock.builder` |
| **S5** | Range validity: Metadata tx ranges are non-overlapping, ordered, and within bounds |
| **S6** | Fee routing: Fees are sent to builder address via FeeManager |
| **S7** | Root-only signing: 0x5b transactions reject keychain signatures |
| **S8** | Gas budget: Each builder's subblock does not exceed their computed gas budget |
| **S9** | Immediate effect: Delegation and config changes take effect in the next block |
| **S10** | Expiring nonce detection: Nonce remainder = max uint88 triggers TIP-1009 semantics |
| **S11** | P2P key cap: Each builder can register at most 4 p2p keys |
| **S12** | P2P key uniqueness: Each ed25519 p2p pubkey is registered to at most one builder |
| **S13** | State snapshot: All subblock validation and fee routing uses parent post-state |
| **S14** | Metadata coverage: Every `0x5b` transaction is covered by exactly one metadata entry; no non-`0x5b` transactions in metadata ranges |
| **S15** | One subblock per builder: At most one metadata entry per builder address per block |
| **S16** | Metadata required: A SubBlockMetadata system transaction must be present (and last) whenever any subblock metadata entries exist, including entries for empty subblocks (`tx_count == 0`). The trigger is "subblocks were included," not "0x5b transactions exist." |
| **S17** | Key ownership proof: `registerP2pKey` requires ed25519 signature proving control of the private key |

## Test Cases

1. **Happy path**: Validator delegates to builder, user submits tx, builder machine creates subblock, proposer includes it
2. **Many-to-one delegation**: Multiple validators delegate to same builder, builder gets combined gas budget
3. **Signature verification**: Invalid ed25519 signature causes block rejection
4. **Signer not registered**: Valid ed25519 signature but signer not in `p2pKeys[builder]` causes rejection
5. **Builder mismatch**: Tx with wrong builder address in nonce key rejected from subblock
6. **Overlapping ranges**: Block with overlapping metadata ranges is invalid
7. **Keychain signature**: 0x5b tx with keychain signature is rejected
8. **No p2p keys**: Delegation rejected if builder has no registered p2p keys
9. **Builder rotation**: Validator changes delegation, old builder loses gas weight
10. **Gas budget exceeded**: Subblock exceeding computed gas budget is rejected
11. **Conflicting subblocks**: Higher gas_limit sum wins; equal gas_limit breaks tie by lower signature_hash
12. **Stale parent hash**: Subblock with old parent_hash rejected
13. **Validator exits set**: Validator removed from ValidatorConfig, their delegation becomes inert, builder's gas weight decreases
14. **Expiring nonce subblock**: Tx with nonce remainder = max uint88 uses TIP-1009 replay protection
15. **Fee token swap with liquidity**: If FeeAMM liquidity exists, builder receives their preferred token
16. **Fee token swap without liquidity**: If no FeeAMM liquidity, builder receives user's fee token
17. **Fee failure**: Tx that cannot pay fees becomes noop, nonce increments, block remains valid
18. **P2P key registration**: Builder registers 4 p2p keys; 5th registration reverts
19. **P2P key uniqueness**: Registering a p2p key already owned by another builder reverts
20. **Parent post-state snapshot**: Registry mutation in current block does not affect current block's subblock validation
21. **Chain ID mismatch**: Subblock with wrong chain_id rejected
22. **Proposer incentive**: Proposer omitting subblocks cannot access gas incentive lane
23. **Multi-machine HA**: Two machines sign subblocks for same builder, proposer selects best one
24. **Fee recipient is builder**: Fees are sent directly to builder address, not a separate feeRecipient
25. **Uncovered 0x5b tx**: Block with a 0x5b transaction not covered by any metadata entry is invalid
26. **Non-0x5b in metadata range**: Block where a metadata entry's range includes a non-0x5b transaction is invalid
27. **Duplicate builder in metadata**: Block with two metadata entries for the same builder address is invalid
28. **Builder removes all keys**: Builder removes last p2p key while delegated, cannot produce subblocks until key re-registered
29. **Cross-builder same sender**: Same sender submits to two builders, both subblocks included, no nonce conflict
30. **Key sniping prevention**: registerP2pKey without valid ed25519 signature from the key reverts
31. **Non-validator delegation**: Non-validator calls delegateToBuilder, delegation stored but does not affect gas weight
32. **Builder fee token via FeeManager**: Builder sets token via FeeManager.setValidatorToken, subblock fees routed accordingly
33. **Gas incentive unlock**: Including a subblock unlocks the builder's entire gas budget for the incentive lane

---

# Design Rationale

## ed25519 for Both P2P and Subblock Signing

Each builder machine has its own ed25519 key that serves dual purpose:
- **P2P authentication**: The key is used for commonware p2p network authentication, allowing the machine to connect to the network and deliver subblocks.
- **Subblock signing**: The same key signs subblocks. The SubBlockMetadata includes the `signer` pubkey, which nodes verify against `p2pKeys[builder]`.

This eliminates the need for shared key material (KMS/HSM) across machines. Each machine operates independently with its own key. The on-chain `p2pKeys` mapping is the source of truth for which keys are authorized to sign on behalf of a builder.

## Builder Address as Fee Recipient

The builder address directly receives subblock fees. This eliminates the need for a separate `feeRecipient` field and the `BuilderConfig` struct. A builder's on-chain state is just: which p2p keys are registered to it, and which validators delegate to it. Fee token preference is stored in the existing FeeManager.

## Permissionless Delegation

`delegateToBuilder` does not restrict callers to validators. Any address can set a delegation, but only delegations from addresses that are currently validators in the set contribute to gas weight. This simplifies the interface — no membership check is needed at delegation time — and supports pre-registration before a validator joins the set.

## Root-Only Signing for Subblock Transactions

Subblock transactions (0x5b prefix) require root EOA signatures and reject keychain (access key) signatures. This is intentional due to a race condition with key revocation:

1. User signs a 0x5b tx with an access key, submits to builder
2. Builder validates signature against current keychain state, includes in subblock
3. In the same block, a main block tx revokes that access key
4. Block execution order: main txs execute first, then subblock txs
5. When the subblock tx executes, the key is already revoked

The problem: signature validation happens at subblock validation time (before block building), not during execution. The subblock tx would still execute even though the key was revoked in the same block.

This violates user expectations. When a user revokes an access key, they expect immediate effect. Allowing keychain signatures for subblock txs would create a window where revoked keys can still authorize transactions.

**Alternative considered**: Re-validate keychain signatures during execution. This was rejected because:
- Adds execution-time overhead for every subblock tx
- Creates griefing vector: users could intentionally revoke keys to cause builder's subblock to fail
- Complicates the execution model

Root-only signing is the simplest solution that maintains user expectations around key revocation.

---

# Implementation Notes

## Relationship to Current Implementation

The current V1 implementation stores subblock-related configuration as follows:

| Data | V1 Location | TIP-1019 (V2) Location |
|------|-------------|------------------------|
| Fee recipient | CLI arg (`--consensus.fee-recipient`) | Builder address itself |
| Subblock signing key | CLI arg (`--consensus.signing-key`), ed25519 | Builder's registered p2p keys (ed25519) |
| Subblock fee token | `FeeManager.validatorTokens[validator]` | `FeeManager.validatorTokens[builder]` (same mechanism) |
| Proposer fee token | `FeeManager.validatorTokens[validator]` | Unchanged (remains in `FeeManager`) |
| P2P identity | Validator ed25519 key | Builder p2p ed25519 key (registered per machine) |
| Builder identity | PartialValidatorKey (15 bytes of validator ed25519 pubkey) | Builder address (20 bytes) |
| Nonce key identity field | 15-byte PartialValidatorKey (bytes 1-15) | 20-byte builder address (bytes 1-20) |

### V2 Struct Wire-Type Changes

| Struct | Change | Detail |
|--------|--------|--------|
| `SubBlock` | Added `chain_id: u64` | Cross-chain replay protection |
| `SubBlock` | Renamed `fee_recipient` → `builder` | Builder address is the fee recipient |
| `SubBlockMetadataEntry` | Added `tx_start_index: u32`, `tx_count: u32` | Replaces implicit range derivation; supports empty subblocks |
| `SubBlockMetadataEntry` | Renamed `validator` → `signer` | Now an ed25519 p2p key, not a validator identity |
| `SubBlockMetadataEntry` | Renamed `fee_recipient` → `builder` | Builder address is the fee recipient |
| `SubBlockMetadata` | Wrapper around `Vec<SubBlockMetadataEntry>` | V1 used a flat struct per entry; V2 wraps entries in a single struct |

Key changes from V1:
1. **Separate builder identity**: Builder address is independent from validator identity
2. **Many-to-one delegation**: Validators can share a builder, accumulating gas budgets
3. **Builder address = fee recipient**: No separate fee recipient configuration
4. **Per-machine signing**: Each machine signs with its own ed25519 key, no shared key needed
5. **Builder p2p keys**: Per-machine ed25519 keys for p2p and signing, registered under a builder (max 4)
6. **Expiring nonce support**: Subblock txs can use expiring nonces by setting nonce remainder = max uint88
7. **chain_id field**: SubBlock includes chain_id for cross-chain replay protection

---

# Migration

## Activation

This TIP activates at a specific block height. V1 vs V2 subblock discrimination is by **fork activation height**: both versions use the `0x5b` nonce key prefix, but the interpretation of the identity bytes changes. After activation:

- SubBlockVersion::V1 subblocks are rejected
- The V1 nonce key format (`0x5b | partial_validator_key[15] | nonce[16]`) is no longer valid
- The V2 nonce key format (`0x5b | builder_address[20] | nonce_remainder[11]`) is required
- Validators must delegate to a builder before their subblock gas is usable

## Migration Steps

1. **Pre-activation**: Builders call `FeeManager.setValidatorToken(token)` for fee token preference
2. **Pre-activation**: Builders call `registerP2pKey(p2pPubkey, signature)` for each physical machine
3. **Pre-activation**: Validators call `delegateToBuilder(builderAddress)` to delegate their gas budget
4. **Activation block**: Protocol switches to V2 subblock validation
5. **Post-activation**: V1 subblocks and old nonce key formats are rejected

Validators who want to build their own subblocks should register a p2p key and self-delegate:
```solidity
// From the builder address (can be same as validator address):
FeeManager.setValidatorToken(preferredToken);
SubblockRegistry.registerP2pKey(myP2pPubkey, mySignature);

// From the validator's address:
SubblockRegistry.delegateToBuilder(builderAddress);
```
