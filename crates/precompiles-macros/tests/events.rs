//! Event emission helper tests for the #[contract] macro.
//!
//! Tests that the macro generates _emit_* methods for events defined in interfaces.

// Re-export `tempo_precompiles::storage` as a local module so `crate::storage` works
mod storage {
    pub(super) use tempo_precompiles::storage::*;
}

use alloy::{
    primitives::{Address, U256},
    sol,
    sol_types::SolCall,
};
use storage::{ContractStorage, hashmap::HashMapStorageProvider};
use tempo_precompiles_macros::contract;

// Test interface with events matching the one registered in interface.rs
sol! {
    interface IMiniToken {
        function mint(address to, uint256 amount) external;

        event Transfer(address indexed from, address indexed to, uint256 amount);
        event Mint(address indexed to, uint256 amount);
    }
}

// Re-export the events enum generated by sol! macro
pub use IMiniToken::IMiniTokenEvents;

// Re-export helper functions so macro-generated code can find them via `crate::`
pub use tempo_precompiles::{
    METADATA_GAS, MUTATE_FUNC_GAS, Precompile, VIEW_FUNC_GAS, error, metadata, mutate, mutate_void,
    view,
};

// Helper to generate addresses
fn test_address(byte: u8) -> Address {
    let mut bytes = [0u8; 20];
    bytes[19] = byte;
    Address::from(bytes)
}

#[contract(IMiniToken)]
pub struct MiniToken {
    #[slot(10)]
    #[map = "balanceOf"]
    pub balances: storage::Mapping<Address, U256>,
}

impl<S: storage::PrecompileStorageProvider> MiniTokenCall for MiniToken<'_, S> {
    fn mint(
        &mut self,
        _s: Address,
        to: Address,
        amount: U256,
    ) -> tempo_precompiles::error::Result<()> {
        let balance = self._get_balances(to)?;
        self._set_balances(to, balance + amount)?;

        // Emit Transfer event from zero address
        let zero = Address::ZERO;
        self._emit_transfer(zero, to, amount)?;

        // Emit Mint event
        self._emit_mint(to, amount)?;
        Ok(())
    }
}

#[test]
fn test_event_emission_helpers_exist() {
    let mut storage = HashMapStorageProvider::new(1);
    let addr = test_address(1);
    let mut token = MiniToken::_new(addr, &mut storage);
    let recipient = test_address(2);

    // Test that _emit_transfer method exists and can be called directly
    let result = token._emit_transfer(Address::ZERO, recipient, U256::from(100));
    assert!(result.is_ok());

    // Test that _emit_mint method exists and can be called directly
    let result = token._emit_mint(recipient, U256::from(100));
    assert!(result.is_ok());
}

#[test]
fn test_event_emission_through_dispatcher() {
    let mut storage = HashMapStorageProvider::new(1);
    let addr = test_address(1);
    let mut token = MiniToken::_new(addr, &mut storage);
    let recipient = test_address(2);

    // Mint tokens through dispatcher (which internally calls _emit_transfer and _emit_mint)
    let calldata = IMiniToken::mintCall {
        to: recipient,
        amount: U256::from(1000),
    }
    .abi_encode();

    let result = token.call(&calldata, recipient);
    assert!(result.is_ok());

    // Verify balance was updated
    assert_eq!(token._get_balances(recipient).unwrap(), U256::from(1000));
}
