//! Objects that are created as part of a ceremony and distributed.

use bytes::{Buf, BufMut};
use commonware_codec::{EncodeSize, FixedSize as _, Read, ReadExt as _, Write, varint::UInt};
use commonware_consensus::types::Epoch;
use commonware_cryptography::{
    Signer as _, Verifier as _,
    bls12381::primitives::{group, poly::Public, variant::MinSig},
    ed25519::{PrivateKey, PublicKey, Signature},
};
use commonware_utils::quorum;

/// The actual message that is sent over p2p.
#[derive(Clone, Debug, PartialEq)]
pub(super) struct Message {
    pub(super) epoch: Epoch,
    pub(super) payload: Payload,
}

impl Write for Message {
    fn write(&self, buf: &mut impl BufMut) {
        UInt(self.epoch).write(buf);
        self.payload.write(buf);
    }
}

impl Read for Message {
    type Cfg = u32;

    fn read_cfg(buf: &mut impl Buf, num_players: &u32) -> Result<Self, commonware_codec::Error> {
        let epoch = UInt::read(buf)?.into();
        let payload = Payload::read_cfg(buf, num_players)?;
        Ok(Self { epoch, payload })
    }
}

impl EncodeSize for Message {
    fn encode_size(&self) -> usize {
        UInt(self.epoch).encode_size() + self.payload.encode_size()
    }
}

/// The two kinds of messages that are being exchanged during a ceremony.
#[derive(Clone, Debug, PartialEq)]
pub(super) enum Payload {
    /// Message from dealer to player.
    ///
    /// Contains the commitment / public polynomial generated by the dealer for
    /// the a ceremony and corresponding share of the private key for the
    /// receiving player.
    Share(Share),

    /// Message from player to dealer.
    ///
    /// Acknowledges the receipt and verification of a [`Share`].
    ///
    /// Contains a signature of dealer and commitment to authenticate the
    /// acknowledged.
    Ack(Ack),
}

impl From<Ack> for Payload {
    fn from(value: Ack) -> Self {
        Payload::Ack(value)
    }
}

impl From<Share> for Payload {
    fn from(value: Share) -> Self {
        Payload::Share(value)
    }
}

impl Write for Payload {
    fn write(&self, buf: &mut impl BufMut) {
        match self {
            Payload::Share(inner) => {
                buf.put_u8(SHARE_TAG);
                inner.write(buf);
            }
            Payload::Ack(inner) => {
                buf.put_u8(ACK_TAG);
                inner.write(buf);
            }
        }
    }
}

const SHARE_TAG: u8 = 0;
const ACK_TAG: u8 = 1;

impl Read for Payload {
    type Cfg = u32;

    fn read_cfg(buf: &mut impl Buf, p: &u32) -> Result<Self, commonware_codec::Error> {
        let tag = u8::read(buf)?;
        let result = match tag {
            SHARE_TAG => Payload::Share(Share::read_cfg(buf, p)?),
            ACK_TAG => Payload::Ack(Ack::read(buf)?),
            _ => return Err(commonware_codec::Error::InvalidEnum(tag)),
        };
        Ok(result)
    }
}

impl EncodeSize for Payload {
    fn encode_size(&self) -> usize {
        u8::SIZE
            + match self {
                Payload::Share(inner) => inner.encode_size(),
                Payload::Ack(inner) => inner.encode_size(),
            }
    }
}

/// A message from a player to a dealer.
///
/// Confirms the receipt and verification of a [`Share`] message by a dealer.
///
/// Contains the player's public key, as well as its signature over the
/// ceremony's epoch, dealear public key, and commitment contained in the
/// share message.
#[derive(Debug, Clone, PartialEq, Eq)]
pub(super) struct Ack {
    /// The public key identifier of the [Player] sending the acknowledgment.
    ///
    /// [Player]: crate::bls12381::dkg::Player
    pub(super) player: PublicKey,
    /// A signature covering the DKG round, dealer ID, and the [Dealer]'s commitment.
    /// This confirms the player received and validated the correct share.
    ///
    /// [Dealer]: crate::bls12381::dkg::Dealer
    pub(super) signature: Signature,
}

impl Ack {
    /// Create a new [Ack] message, constructing and signing the payload with the provided [Signer].
    pub(super) fn new(
        namespace: &[u8],
        signer: PrivateKey,
        player: PublicKey,
        epoch: Epoch,
        dealer: &PublicKey,
        commitment: &Public<MinSig>,
    ) -> Self {
        let payload = Self::construct_signature_payload(epoch, dealer, commitment);
        let signature = signer.sign(Some(namespace), &payload);
        Self { player, signature }
    }

    fn construct_signature_payload(
        epoch: Epoch,
        dealer: &PublicKey,
        commitment: &Public<MinSig>,
    ) -> Vec<u8> {
        let mut payload =
            Vec::with_capacity(Epoch::SIZE + PublicKey::SIZE + commitment.encode_size());
        epoch.write(&mut payload);
        dealer.write(&mut payload);
        commitment.write(&mut payload);
        payload
    }

    pub(super) fn verify(
        &self,
        namespace: &[u8],
        public_key: &PublicKey,
        epoch: Epoch,
        dealer: &PublicKey,
        commitment: &Public<MinSig>,
    ) -> bool {
        let payload = Self::construct_signature_payload(epoch, dealer, commitment);
        public_key.verify(Some(namespace), &payload, &self.signature)
    }
}

impl Write for Ack {
    fn write(&self, buf: &mut impl BufMut) {
        self.player.write(buf);
        self.signature.write(buf);
    }
}

impl EncodeSize for Ack {
    fn encode_size(&self) -> usize {
        self.player.encode_size() + self.signature.encode_size()
    }
}

impl Read for Ack {
    type Cfg = ();

    fn read_cfg(buf: &mut impl Buf, _: &()) -> Result<Self, commonware_codec::Error> {
        Ok(Self {
            player: PublicKey::read(buf)?,
            signature: Signature::read(buf)?,
        })
    }
}

/// A message from a dealer to a player.
///
/// Contains the commitment and one of the shares the dealer generated for the
/// current ceremony.
///
/// The receipt of this message is acknowledged by the player returning an
/// [`Ack`] to the dealer.
#[derive(Debug, Clone, PartialEq, Eq)]
pub(super) struct Share {
    /// The dealer's generated public polyonimal.
    pub(super) commitment: Public<MinSig>,
    /// The secret share generated for the player.
    pub(super) share: group::Share,
}

impl Write for Share {
    fn write(&self, buf: &mut impl BufMut) {
        self.commitment.write(buf);
        self.share.write(buf);
    }
}

impl EncodeSize for Share {
    fn encode_size(&self) -> usize {
        self.commitment.encode_size() + self.share.encode_size()
    }
}

impl Read for Share {
    type Cfg = u32;

    fn read_cfg(buf: &mut impl Buf, t: &u32) -> Result<Self, commonware_codec::Error> {
        let q = quorum(*t);
        Ok(Self {
            commitment: Public::<MinSig>::read_cfg(buf, &(q as usize))?,
            share: group::Share::read(buf)?,
        })
    }
}
