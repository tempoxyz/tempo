//! TIP403 Registry module.
//!
//! This module contains the TIP403 transfer policy registry implementation.

use crate::{
    TIP403_REGISTRY_ADDRESS,
    error::{Result, TempoPrecompileError},
    storage::{Handler, Mapping},
};
use alloy::primitives::{Address, U256};
use tempo_precompiles_macros::{Storable, abi, contract};

#[contract(abi, dispatch, addr = TIP403_REGISTRY_ADDRESS)]
pub struct TIP403Registry {
    policy_id_counter: u64,
    policy_data: Mapping<u64, PolicyData>,
    policy_set: Mapping<u64, Mapping<Address, bool>>,
}

#[derive(Debug, Clone, Storable)]
pub struct PolicyData {
    pub policy_type: u8,
    pub admin: Address,
}

// NOTE(rusowsky): can be removed once revm uses precompiles rather than directly
// interacting with storage slots.
impl PolicyData {
    pub fn decode_from_slot(slot_value: U256) -> Self {
        use crate::storage::{LayoutCtx, Storable, packing::PackedSlot};

        Self::load(&PackedSlot(slot_value), U256::ZERO, LayoutCtx::FULL)
            .expect("unable to decode PolicyData from slot")
    }

    pub fn encode_to_slot(&self) -> U256 {
        use crate::storage::packing::insert_into_word;
        use __packing_policy_data::{ADMIN_LOC as A_LOC, POLICY_TYPE_LOC as PT_LOC};

        let encoded = insert_into_word(
            U256::ZERO,
            &self.policy_type,
            PT_LOC.offset_bytes,
            PT_LOC.size,
        )
        .expect("unable to insert 'policy_type'");

        insert_into_word(encoded, &self.admin, A_LOC.offset_bytes, A_LOC.size)
            .expect("unable to insert 'admin'")
    }
}

#[abi(dispatch)]
#[rustfmt::skip]
pub mod abi {
    use super::*;

    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum PolicyType {
        Whitelist = 0,
        Blacklist = 1,
    }

    pub trait IRegistry {
        // View functions
        fn policy_id_counter(&self) -> Result<u64>;
        fn policy_exists(&self, policy_id: u64) -> Result<bool>;
        fn policy_data(&self, policy_id: u64) -> Result<(PolicyType, Address)>;
        fn is_authorized(&self, policy_id: u64, user: Address) -> Result<bool>;

        // State-changing functions (msg_sender is injected by macro)
        fn create_policy(&mut self, admin: Address, policy_type: PolicyType) -> Result<u64>;
        fn create_policy_with_accounts(&mut self, admin: Address, policy_type: PolicyType, accounts: Vec<Address>) -> Result<u64>;
        fn set_policy_admin(&mut self, policy_id: u64, admin: Address) -> Result<()>;
        fn modify_policy_whitelist(&mut self, policy_id: u64, account: Address, allowed: bool) -> Result<()>;
        fn modify_policy_blacklist(&mut self, policy_id: u64, account: Address, restricted: bool) -> Result<()>;
    }

    pub enum Error {
        Unauthorized,
        IncompatiblePolicyType,
        PolicyNotFound,
    }

    pub enum Event {
        PolicyAdminUpdated { #[indexed] policy_id: u64, #[indexed] updater: Address, #[indexed] admin: Address },
        PolicyCreated { #[indexed] policy_id: u64, #[indexed] updater: Address, policy_type: PolicyType },
        WhitelistUpdated { #[indexed] policy_id: u64, #[indexed] updater: Address, #[indexed] account: Address, allowed: bool },
        BlacklistUpdated { #[indexed] policy_id: u64, #[indexed] updater: Address, #[indexed] account: Address, restricted: bool },
    }
}

// Type aliases for backward compatibility (generated by #[contract] macro)
// pub type TIP403RegistryError = abi::Error;
// pub type TIP403RegistryEvent = abi::Event;
pub use abi::PolicyType;
pub use IAbi as ITIP403Registry;

impl TIP403Registry {
    /// Initializes the registry contract.
    pub fn initialize(&mut self) -> Result<()> {
        self.__initialize()
    }

    // Internal helper functions
    fn get_policy_data(&self, policy_id: u64) -> Result<PolicyData> {
        self.policy_data[policy_id].read()
    }

    fn set_policy_data(&mut self, policy_id: u64, data: PolicyData) -> Result<()> {
        self.policy_data[policy_id].write(data)
    }

    fn set_policy_set(&mut self, policy_id: u64, account: Address, value: bool) -> Result<()> {
        self.policy_set[policy_id][account].write(value)
    }

    fn is_authorized_internal(&self, policy_id: u64, user: Address) -> Result<bool> {
        // Special case for always-allow and always-reject policies
        if policy_id < 2 {
            return Ok(policy_id == 1);
        }

        let data = self.get_policy_data(policy_id)?;
        let is_in_set = self.policy_set[policy_id][user].read()?;

        let policy_type: PolicyType = data
            .policy_type
            .try_into()
            .map_err(|_| TempoPrecompileError::under_overflow())?;

        let auth = match policy_type {
            PolicyType::Whitelist => is_in_set,
            PolicyType::Blacklist => !is_in_set,
        };

        Ok(auth)
    }

    fn policy_id_counter_internal(&self) -> Result<u64> {
        self.policy_id_counter.read().map(|counter| counter.max(2))
    }

    fn policy_exists_internal(&self, policy_id: u64) -> Result<bool> {
        if policy_id < 2 {
            return Ok(true);
        }
        let counter = self.policy_id_counter_internal()?;
        Ok(policy_id < counter)
    }
}

impl abi::IRegistry for TIP403Registry {
    fn policy_id_counter(&self) -> Result<u64> {
        self.policy_id_counter_internal()
    }

    fn policy_exists(&self, policy_id: u64) -> Result<bool> {
        self.policy_exists_internal(policy_id)
    }

    fn policy_data(&self, policy_id: u64) -> Result<(PolicyType, Address)> {
        if !self.policy_exists_internal(policy_id)? {
            return Err(TIP403RegistryError::policy_not_found().into());
        }

        let data = self.get_policy_data(policy_id)?;
        let policy_type: PolicyType = data
            .policy_type
            .try_into()
            .map_err(|_| TempoPrecompileError::under_overflow())?;
        Ok((policy_type, data.admin))
    }

    fn is_authorized(&self, policy_id: u64, user: Address) -> Result<bool> {
        self.is_authorized_internal(policy_id, user)
    }

    fn create_policy(
        &mut self,
        msg_sender: Address,
        admin: Address,
        policy_type: PolicyType,
    ) -> Result<u64> {
        let new_policy_id = self.policy_id_counter_internal()?;

        self.policy_id_counter.write(
            new_policy_id
                .checked_add(1)
                .ok_or(TempoPrecompileError::under_overflow())?,
        )?;

        self.policy_data[new_policy_id].write(PolicyData {
            policy_type: policy_type as u8,
            admin,
        })?;

        self.emit_event(TIP403RegistryEvent::policy_created(
            new_policy_id,
            msg_sender,
            policy_type,
        ))?;

        self.emit_event(TIP403RegistryEvent::policy_admin_updated(
            new_policy_id,
            msg_sender,
            admin,
        ))?;

        Ok(new_policy_id)
    }

    fn create_policy_with_accounts(
        &mut self,
        msg_sender: Address,
        admin: Address,
        policy_type: PolicyType,
        accounts: Vec<Address>,
    ) -> Result<u64> {
        let new_policy_id = self.policy_id_counter_internal()?;

        self.policy_id_counter.write(
            new_policy_id
                .checked_add(1)
                .ok_or(TempoPrecompileError::under_overflow())?,
        )?;

        self.set_policy_data(
            new_policy_id,
            PolicyData {
                policy_type: policy_type as u8,
                admin,
            },
        )?;

        for account in accounts.iter() {
            self.set_policy_set(new_policy_id, *account, true)?;

            match policy_type {
                PolicyType::Whitelist => {
                    self.emit_event(TIP403RegistryEvent::whitelist_updated(
                        new_policy_id,
                        msg_sender,
                        *account,
                        true,
                    ))?;
                }
                PolicyType::Blacklist => {
                    self.emit_event(TIP403RegistryEvent::blacklist_updated(
                        new_policy_id,
                        msg_sender,
                        *account,
                        true,
                    ))?;
                }
            }
        }

        self.emit_event(TIP403RegistryEvent::policy_created(
            new_policy_id,
            msg_sender,
            policy_type,
        ))?;

        self.emit_event(TIP403RegistryEvent::policy_admin_updated(
            new_policy_id,
            msg_sender,
            admin,
        ))?;

        Ok(new_policy_id)
    }

    fn set_policy_admin(
        &mut self,
        msg_sender: Address,
        policy_id: u64,
        admin: Address,
    ) -> Result<()> {
        let data = self.get_policy_data(policy_id)?;

        if data.admin != msg_sender {
            return Err(TIP403RegistryError::unauthorized().into());
        }

        self.set_policy_data(
            policy_id,
            PolicyData {
                admin,
                ..data
            },
        )?;

        self.emit_event(TIP403RegistryEvent::policy_admin_updated(
            policy_id,
            msg_sender,
            admin,
        ))
    }

    fn modify_policy_whitelist(
        &mut self,
        msg_sender: Address,
        policy_id: u64,
        account: Address,
        allowed: bool,
    ) -> Result<()> {
        let data = self.get_policy_data(policy_id)?;

        if data.admin != msg_sender {
            return Err(TIP403RegistryError::unauthorized().into());
        }

        if data.policy_type != PolicyType::Whitelist as u8 {
            return Err(TIP403RegistryError::incompatible_policy_type().into());
        }

        self.set_policy_set(policy_id, account, allowed)?;

        self.emit_event(TIP403RegistryEvent::whitelist_updated(
            policy_id,
            msg_sender,
            account,
            allowed,
        ))
    }

    fn modify_policy_blacklist(
        &mut self,
        msg_sender: Address,
        policy_id: u64,
        account: Address,
        restricted: bool,
    ) -> Result<()> {
        let data = self.get_policy_data(policy_id)?;

        if data.admin != msg_sender {
            return Err(TIP403RegistryError::unauthorized().into());
        }

        if data.policy_type != PolicyType::Blacklist as u8 {
            return Err(TIP403RegistryError::incompatible_policy_type().into());
        }

        self.set_policy_set(policy_id, account, restricted)?;

        self.emit_event(TIP403RegistryEvent::blacklist_updated(
            policy_id,
            msg_sender,
            account,
            restricted,
        ))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::storage::{StorageCtx, hashmap::HashMapStorageProvider};
    use alloy::primitives::Address;
    use rand::Rng;

    #[test]
    fn test_create_policy() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        let admin = Address::random();
        StorageCtx::enter(&mut storage, || {
            let mut registry = TIP403Registry::new();

            assert_eq!(abi::IRegistry::policy_id_counter(&registry)?, 2);

            let result = abi::IRegistry::create_policy(&mut registry, admin, admin, PolicyType::Whitelist);
            assert!(result.is_ok());
            assert_eq!(result?, 2);

            assert_eq!(abi::IRegistry::policy_id_counter(&registry)?, 3);

            let data = abi::IRegistry::policy_data(&registry, 2)?;
            assert_eq!(data.0, PolicyType::Whitelist);
            assert_eq!(data.1, admin);
            Ok(())
        })
    }

    #[test]
    fn test_is_authorized_special_policies() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        let user = Address::random();
        StorageCtx::enter(&mut storage, || {
            let registry = TIP403Registry::new();

            assert!(!abi::IRegistry::is_authorized(&registry, 0, user)?);
            assert!(abi::IRegistry::is_authorized(&registry, 1, user)?);
            Ok(())
        })
    }

    #[test]
    fn test_whitelist_policy() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        let admin = Address::random();
        let user = Address::random();
        StorageCtx::enter(&mut storage, || {
            let mut registry = TIP403Registry::new();

            let policy_id = abi::IRegistry::create_policy(&mut registry, admin, admin, PolicyType::Whitelist)?;

            assert!(!abi::IRegistry::is_authorized(&registry, policy_id, user)?);

            abi::IRegistry::modify_policy_whitelist(&mut registry, admin, policy_id, user, true)?;

            assert!(abi::IRegistry::is_authorized(&registry, policy_id, user)?);

            Ok(())
        })
    }

    #[test]
    fn test_blacklist_policy() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        let admin = Address::random();
        let user = Address::random();
        StorageCtx::enter(&mut storage, || {
            let mut registry = TIP403Registry::new();

            let policy_id = abi::IRegistry::create_policy(&mut registry, admin, admin, PolicyType::Blacklist)?;

            assert!(abi::IRegistry::is_authorized(&registry, policy_id, user)?);

            abi::IRegistry::modify_policy_blacklist(&mut registry, admin, policy_id, user, true)?;

            assert!(!abi::IRegistry::is_authorized(&registry, policy_id, user)?);

            Ok(())
        })
    }

    #[test]
    fn test_policy_data_reverts_for_non_existent_policy() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        StorageCtx::enter(&mut storage, || {
            let registry = TIP403Registry::new();

            let result = abi::IRegistry::policy_data(&registry, 100);
            assert!(result.is_err());

            let err = result.unwrap_err();
            assert!(matches!(
                err,
                crate::error::TempoPrecompileError::TIP403RegistryError(
                    TIP403RegistryError::PolicyNotFound(_)
                )
            ));

            Ok(())
        })
    }

    #[test]
    fn test_policy_exists() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        let admin = Address::random();
        StorageCtx::enter(&mut storage, || {
            let mut registry = TIP403Registry::new();

            assert!(abi::IRegistry::policy_exists(&registry, 0)?);
            assert!(abi::IRegistry::policy_exists(&registry, 1)?);

            let mut rng = rand::thread_rng();
            for _ in 0..100 {
                let random_policy_id = rng.gen_range(2..u64::MAX);
                assert!(!abi::IRegistry::policy_exists(&registry, random_policy_id)?);
            }

            let mut created_policy_ids = Vec::new();
            for i in 0..50 {
                let policy_id = abi::IRegistry::create_policy(
                    &mut registry,
                    admin,
                    admin,
                    if i % 2 == 0 {
                        PolicyType::Whitelist
                    } else {
                        PolicyType::Blacklist
                    },
                )?;
                created_policy_ids.push(policy_id);
            }

            for policy_id in &created_policy_ids {
                assert!(abi::IRegistry::policy_exists(&registry, *policy_id)?);
            }

            Ok(())
        })
    }
}
