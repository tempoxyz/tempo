//! TIP Fee Manager dispatch tests.
//!
//! The dispatch implementation is auto-generated by the `#[contract(abi = [...], dispatch)]` macro.

#[cfg(test)]
mod tests {
    use crate::{
        Precompile, expect_precompile_revert,
        storage::{ContractStorage, StorageCtx, hashmap::HashMapStorageProvider},
        test_util::{TIP20Setup, assert_full_coverage, check_selector_coverage},
        tip_fee_manager::{
            IFeeAMM, IFeeManager, M, MIN_LIQUIDITY, N, SCALE, TipFeeManager, amm::PoolKey,
        },
    };
    use alloy::{
        primitives::{Address, B256, U256},
        sol_types::{SolCall, SolValue},
    };

    #[test]
    fn test_set_validator_token() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        let admin = Address::random();
        let validator = Address::random();
        StorageCtx::enter(&mut storage, || {
            let token = TIP20Setup::create("TestToken", "TST", admin).apply()?;
            let mut fee_manager = TipFeeManager::new();

            let calldata = IFeeManager::setValidatorTokenCall {
                token: token.address(),
            }
            .abi_encode();
            let result = fee_manager.call(&calldata, validator)?;
            assert_eq!(result.gas_used, 0);

            // Verify token was set
            let calldata = IFeeManager::validatorTokensCall { validator }.abi_encode();
            let result = fee_manager.call(&calldata, validator)?;
            assert_eq!(result.gas_used, 0);
            let returned_token = Address::abi_decode(&result.bytes)?;
            assert_eq!(returned_token, token.address());

            Ok(())
        })
    }

    #[test]
    fn test_set_validator_token_zero_address() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        let validator = Address::random();
        StorageCtx::enter(&mut storage, || {
            let mut fee_manager = TipFeeManager::new();

            let calldata = IFeeManager::setValidatorTokenCall {
                token: Address::ZERO,
            }
            .abi_encode();
            let result = fee_manager.call(&calldata, validator);
            expect_precompile_revert(&result, IFeeManager::Error::invalid_token());

            Ok(())
        })
    }

    #[test]
    fn test_set_user_token() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        let admin = Address::random();
        let user = Address::random();
        StorageCtx::enter(&mut storage, || {
            let token = TIP20Setup::create("TestToken", "TST", admin).apply()?;
            let mut fee_manager = TipFeeManager::new();

            let calldata = IFeeManager::setUserTokenCall {
                token: token.address(),
            }
            .abi_encode();
            let result = fee_manager.call(&calldata, user)?;
            assert_eq!(result.gas_used, 0);

            // Verify token was set
            let calldata = IFeeManager::userTokensCall { user }.abi_encode();
            let result = fee_manager.call(&calldata, user)?;
            assert_eq!(result.gas_used, 0);
            let returned_token = Address::abi_decode(&result.bytes)?;
            assert_eq!(returned_token, token.address());

            Ok(())
        })
    }

    #[test]
    fn test_set_user_token_zero_address() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        let user = Address::random();
        StorageCtx::enter(&mut storage, || {
            let mut fee_manager = TipFeeManager::new();

            let calldata = IFeeManager::setUserTokenCall {
                token: Address::ZERO,
            }
            .abi_encode();
            let result = fee_manager.call(&calldata, user);
            expect_precompile_revert(&result, IFeeManager::Error::invalid_token());

            Ok(())
        })
    }

    #[test]
    fn test_get_pool_id() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        let token_a = Address::random();
        let token_b = Address::random();
        let sender = Address::random();
        StorageCtx::enter(&mut storage, || {
            let mut fee_manager = TipFeeManager::new();

            let calldata = IFeeAMM::getPoolIdCall {
                user_token: token_a,
                validator_token: token_b,
            }
            .abi_encode();
            let result = fee_manager.call(&calldata, sender)?;
            assert_eq!(result.gas_used, 0);

            let returned_id = B256::abi_decode(&result.bytes)?;
            let expected_id = PoolKey::new(token_a, token_b).get_id();
            assert_eq!(returned_id, expected_id);

            Ok(())
        })
    }

    #[test]
    fn test_tip_fee_amm_pool_operations() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        let token_a = Address::random();
        let token_b = Address::random();
        let sender = Address::random();
        StorageCtx::enter(&mut storage, || {
            let mut fee_manager = TipFeeManager::new();

            // Get pool using ITIPFeeAMM interface
            let get_pool_call = IFeeAMM::getPoolCall {
                user_token: token_a,
                validator_token: token_b,
            };
            let calldata = get_pool_call.abi_encode();
            let result = fee_manager.call(&calldata, sender)?;
            assert_eq!(result.gas_used, 0);

            // Decode and verify pool (should be empty initially)
            let pool = IFeeAMM::Pool::abi_decode(&result.bytes)?;
            assert_eq!(pool.reserve_user_token, 0);
            assert_eq!(pool.reserve_validator_token, 0);

            Ok(())
        })
    }

    #[test]
    fn test_pool_id_calculation() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        let token_a = Address::random();
        let token_b = Address::random();
        let sender = Address::random();
        StorageCtx::enter(&mut storage, || {
            let mut fee_manager = TipFeeManager::new();

            // Get pool ID with tokens in order (a, b)
            let calldata1 = IFeeAMM::getPoolIdCall {
                user_token: token_a,
                validator_token: token_b,
            }
            .abi_encode();
            let result1 = fee_manager.call(&calldata1, sender)?;
            let id1 = B256::abi_decode(&result1.bytes)?;

            // Get pool ID with tokens reversed (b, a)
            let calldata2 = IFeeAMM::getPoolIdCall {
                user_token: token_b,
                validator_token: token_a,
            }
            .abi_encode();
            let result2 = fee_manager.call(&calldata2, sender)?;
            let id2 = B256::abi_decode(&result2.bytes)?;

            // Pool IDs should be different since tokens are ordered
            assert_ne!(id1, id2);

            Ok(())
        })
    }

    #[test]
    fn test_fee_manager_invalid_token_error() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        let user = Address::random();
        let validator = Address::random();
        StorageCtx::enter(&mut storage, || {
            let mut fee_manager = TipFeeManager::new();

            // Test setValidatorToken with zero address
            let set_validator_call = IFeeManager::setValidatorTokenCall {
                token: Address::ZERO,
            };
            let result = fee_manager.call(&set_validator_call.abi_encode(), validator);
            expect_precompile_revert(&result, IFeeManager::Error::invalid_token());

            // Test setUserToken with zero address
            let set_user_call = IFeeManager::setUserTokenCall {
                token: Address::ZERO,
            };
            let result = fee_manager.call(&set_user_call.abi_encode(), user);
            expect_precompile_revert(&result, IFeeManager::Error::invalid_token());

            Ok(())
        })
    }

    #[test]
    fn test_amm_constants() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        let sender = Address::random();
        StorageCtx::enter(&mut storage, || {
            let mut fee_manager = TipFeeManager::new();

            let result = fee_manager.call(&IFeeAMM::MIN_LIQUIDITYCall {}.abi_encode(), sender)?;
            assert!(!result.reverted);
            assert_eq!(U256::abi_decode(&result.bytes)?, MIN_LIQUIDITY);

            let result = fee_manager.call(&IFeeAMM::MCall {}.abi_encode(), sender)?;
            assert_eq!(U256::abi_decode(&result.bytes)?, M);

            let result = fee_manager.call(&IFeeAMM::NCall {}.abi_encode(), sender)?;
            assert_eq!(U256::abi_decode(&result.bytes)?, N);

            let result = fee_manager.call(&IFeeAMM::SCALECall {}.abi_encode(), sender)?;
            assert_eq!(U256::abi_decode(&result.bytes)?, SCALE);

            Ok(())
        })
    }

    #[test]
    fn test_tip_fee_manager_selector_coverage() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        StorageCtx::enter(&mut storage, || {
            let mut fee_manager = TipFeeManager::new();

            let fee_manager_unsupported = check_selector_coverage(
                &mut fee_manager,
                IFeeManager::InterfaceCalls::SELECTORS,
                "Interface",
                IFeeManager::InterfaceCalls::name_by_selector,
            );

            let amm_unsupported = check_selector_coverage(
                &mut fee_manager,
                IFeeAMM::InterfaceCalls::SELECTORS,
                "IFeeAMM",
                IFeeAMM::InterfaceCalls::name_by_selector,
            );

            let constants_unsupported = check_selector_coverage(
                &mut fee_manager,
                IFeeAMM::ConstantsCalls::SELECTORS,
                "Constants",
                IFeeAMM::ConstantsCalls::name_by_selector,
            );

            assert_full_coverage([
                fee_manager_unsupported,
                amm_unsupported,
                constants_unsupported,
            ]);

            Ok(())
        })
    }
}
