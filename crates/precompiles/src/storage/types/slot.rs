use alloy::primitives::{Address, U256};
use std::marker::PhantomData;

use crate::{
    error::Result,
    storage::{
        FieldLocation, Handler, LayoutCtx, Storable, StorableType, StorageContext, StorageOps,
    },
};

/// Type-safe wrapper for a single EVM storage slot.
///
/// # Type Parameters
///
/// - `T`: The Rust type stored in this slot (must implement `Storable`)
///
/// # Example
///
/// ```ignore
/// // Generated by #[contract] macro:
/// pub mod slots {
///     pub const NAME: U256 = uint!(2_U256);
/// }
/// let name_slot = Slot::<String>::new(slots::NAME);
/// ```
///
/// The actual storage operations are handled by generated accessor methods
/// that read/write values using the `PrecompileStorageProvider` trait.
#[derive(Debug, Clone)]
pub struct Slot<T> {
    slot: U256,
    ctx: LayoutCtx,
    address: Address,
    _ty: PhantomData<T>,
}

impl<T> Default for Slot<T> {
    fn default() -> Self {
        Self::new(U256::ZERO, Address::ZERO)
    }
}

impl<T> Slot<T> {
    /// Creates a new `Slot` with the given slot number and address.
    ///
    /// This is typically called with slot constants generated by the `#[contract]` macro.
    /// Creates a full-slot accessor. For packed fields, use `new_at_loc` instead.
    #[inline]
    pub fn new(slot: U256, address: Address) -> Self {
        Self {
            slot,
            ctx: LayoutCtx::FULL,
            address,
            _ty: PhantomData,
        }
    }

    /// Creates a new `Slot` with the given slot number, layout context, and address.
    ///
    /// This is used by the handler system to create slots with specific packing contexts.
    #[inline]
    pub fn new_with_ctx(slot: U256, ctx: LayoutCtx, address: Address) -> Self {
        Self {
            slot,
            ctx,
            address,
            _ty: PhantomData,
        }
    }

    /// Creates a new `Slot` with the given base slot number with the given offset and address.
    ///
    /// This is a convenience method for accessing struct fields.
    /// Creates a full-slot accessor. For packed fields, use `new_at_loc` instead.
    #[inline]
    pub fn new_at_offset(base_slot: U256, offset_slots: usize, address: Address) -> Self {
        Self {
            slot: base_slot.saturating_add(U256::from_limbs([offset_slots as u64, 0, 0, 0])),
            ctx: LayoutCtx::FULL,
            address,
            _ty: PhantomData,
        }
    }

    /// Creates a new `Slot` from a `FieldLocation` generated by the `#[derive(Storable)]` macro.
    ///
    /// This is the recommended way to access packed struct fields, combining slot offset
    /// and byte offset information in a type-safe manner.
    ///
    /// This method should only be used with packable types (size < 32 bytes).
    #[inline]
    pub fn new_at_loc(base_slot: U256, loc: FieldLocation, address: Address) -> Self
    where
        T: StorableType,
    {
        debug_assert!(
            T::IS_PACKABLE,
            "`fn new_at_loc` can only be used with packable types"
        );
        Self {
            slot: base_slot.saturating_add(U256::from_limbs([loc.offset_slots as u64, 0, 0, 0])),
            ctx: LayoutCtx::packed(loc.offset_bytes),
            address,
            _ty: PhantomData,
        }
    }

    /// Returns the storage slot number where the underlying type is stored.
    ///
    /// Multi-slot types use consecutive slots from this base slot.
    #[inline]
    pub const fn slot(&self) -> U256 {
        self.slot
    }

    /// Returns the byte offset within the slot (for packed fields).
    ///
    /// Returns `Some(offset)` if this is a packed slot, `None` if it's a full slot.
    #[inline]
    pub const fn offset(&self) -> Option<usize> {
        self.ctx.packed_offset()
    }
}

impl<T: Storable> Handler<T> for Slot<T> {
    /// Reads a value from storage at this slot.
    ///
    /// This method delegates to the `Storable::load` implementation,
    /// which may read one or more consecutive slots depending on the type.
    ///
    /// Uses thread-local storage context initialized by [`StorageGuard`].
    ///
    /// # Example
    ///
    /// ```ignore
    /// let name_slot = Slot::<String>::new(slots::NAME, address_rc);
    /// let name = name_slot.read().unwrap();
    /// ```
    #[inline]
    fn read(&self) -> Result<T> {
        T::load(self, self.slot, self.ctx)
    }

    /// Writes a value to storage at this slot.
    ///
    /// This method delegates to the `Storable::store` implementation,
    /// which may write one or more consecutive slots depending on the type.
    ///
    /// Uses thread-local storage context initialized by [`StorageGuard`].
    ///
    /// # Example
    ///
    /// ```ignore
    /// let mut name_slot = Slot::<String>::new(slots::NAME, address_rc);
    /// name_slot.write("MyToken".to_string()).unwrap();
    /// ```
    #[inline]
    fn write(&mut self, value: T) -> Result<()> {
        value.store(self, self.slot, self.ctx)
    }

    /// Deletes the value at this slot (sets all slots to zero).
    ///
    /// This method delegates to the `Storable::delete` implementation,
    /// which sets the appropriate slots to zero.
    ///
    /// Uses thread-local storage context initialized by [`StorageGuard`].
    ///
    /// # Example
    ///
    /// ```ignore
    /// let mut name_slot = Slot::<String>::new(slots::NAME, address_rc);
    /// name_slot.delete().unwrap();
    /// ```
    #[inline]
    fn delete(&mut self) -> Result<()> {
        T::delete(self, self.slot, self.ctx)
    }
}

impl<T> StorageOps for Slot<T> {
    fn sload(&self, slot: U256) -> Result<U256> {
        let storage = StorageContext;
        storage.sload(self.address, slot)
    }

    fn sstore(&mut self, slot: U256, value: U256) -> Result<()> {
        let mut storage = StorageContext;
        storage.sstore(self.address, slot, value)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::storage::{
        Handler, PrecompileStorageProvider, StorageKey, hashmap::HashMapStorageProvider,
    };
    use alloy::primitives::{Address, B256};
    use proptest::prelude::*;

    // Property test strategies
    fn arb_address() -> impl Strategy<Value = Address> {
        any::<[u8; 20]>().prop_map(Address::from)
    }

    fn arb_u256() -> impl Strategy<Value = U256> {
        any::<[u64; 4]>().prop_map(U256::from_limbs)
    }

    fn setup_storage() -> (HashMapStorageProvider, Address) {
        (HashMapStorageProvider::new(1), Address::random())
    }

    // -- BASIC TESTS -----------------------------------------------------------

    #[test]
    fn test_slot_size() {
        // slot (U256) 32 bytes + LayoutCtx (usize) 8 bytes + Address 20 bytes (+4 for byte alignement)
        assert_eq!(std::mem::size_of::<Slot<U256>>(), 64);
        assert_eq!(std::mem::size_of::<Slot<Address>>(), 64);
        assert_eq!(std::mem::size_of::<Slot<bool>>(), 64);
    }

    #[test]
    fn test_slot_number_extraction() {
        let (mut storage, address) = setup_storage();
        StorageContext::enter(&mut storage, || {
            let slot_0 = Slot::<U256>::new(U256::ZERO, address.clone());
            let slot_1 = Slot::<Address>::new(U256::ONE, address.clone());
            let slot_max = Slot::<bool>::new(U256::MAX, address);
            assert_eq!(slot_0.slot(), U256::ZERO);
            assert_eq!(slot_1.slot(), U256::ONE);
            assert_eq!(slot_max.slot(), U256::MAX);
        });
    }

    #[test]
    fn test_slot_edge_case_zero() {
        let (mut storage, address) = setup_storage();
        StorageContext::enter(&mut storage, || {
            // Explicit test for U256::ZERO slot
            let mut slot = Slot::<U256>::new(U256::ZERO, address);
            assert_eq!(slot.slot(), U256::ZERO);

            let value = U256::random();
            slot.write(value).unwrap();
            let loaded = slot.read().unwrap();
            assert_eq!(loaded, value);
        });
    }

    #[test]
    fn test_slot_edge_case_max() {
        let (mut storage, address) = setup_storage();
        StorageContext::enter(&mut storage, || {
            // Explicit test for U256::MAX slot
            let mut slot = Slot::<U256>::new(U256::MAX, address);
            assert_eq!(slot.slot(), U256::MAX);

            let value = U256::random();
            slot.write(value).unwrap();
            let loaded = slot.read().unwrap();
            assert_eq!(loaded, value);
        });
    }

    #[test]
    fn test_slot_read_write_u256() {
        let (mut storage, address) = setup_storage();
        let slot_num = U256::random();
        let test_value = U256::random();

        StorageContext::enter(&mut storage, || {
            let mut slot = Slot::<U256>::new(slot_num, address.clone());

            // Write using new API
            slot.write(test_value).unwrap();

            // Read using new API
            let loaded = slot.read().unwrap();
            assert_eq!(loaded, test_value);
        });

        // Verify it actually wrote to slot
        let raw = storage.sload(address, slot_num);
        assert_eq!(raw, Ok(test_value));
    }

    #[test]
    fn test_slot_read_write_address() {
        let (mut storage, address) = setup_storage();
        StorageContext::enter(&mut storage, || {
            let test_addr = Address::random();
            let mut slot = Slot::<Address>::new(U256::random(), address);

            // Write
            slot.write(test_addr).unwrap();

            // Read
            let loaded = slot.read().unwrap();
            assert_eq!(loaded, test_addr);
        });
    }

    #[test]
    fn test_slot_read_write_bool() {
        let (mut storage, address) = setup_storage();
        StorageContext::enter(&mut storage, || {
            let mut slot = Slot::<bool>::new(U256::random(), address);

            // Write true
            slot.write(true).unwrap();
            assert!(slot.read().unwrap());

            // Write false
            slot.write(false).unwrap();
            assert!(!slot.read().unwrap());
        });
    }

    // #[test]
    // fn test_slot_read_write_string() {
    //     let (mut storage, address) = setup_storage();
    //        let _guard = storage.enter().unwrap();

    //         let mut slot = Slot::<String>::new(U256::random(), address.clone());

    //         let test_name = "TestToken";
    //         slot.write(test_name.to_string()).unwrap();

    //         let loaded = slot.read().unwrap();
    //         assert_eq!(loaded, test_name);
    // }

    #[test]
    fn test_slot_default_value_is_zero() {
        let (mut storage, address) = setup_storage();
        StorageContext::enter(&mut storage, || {
            let slot = Slot::<U256>::new(U256::random(), address);

            // Reading uninitialized storage should return zero
            let value = slot.read().unwrap();
            assert_eq!(value, U256::ZERO);
        });
    }

    #[test]
    fn test_slot_overwrite() {
        let (mut storage, address) = setup_storage();
        StorageContext::enter(&mut storage, || {
            let mut slot = Slot::<u64>::new(U256::random(), address);

            // Write initial value
            slot.write(100).unwrap();
            assert_eq!(slot.read(), Ok(100));

            // Overwrite with new value
            slot.write(200).unwrap();
            assert_eq!(slot.read(), Ok(200));
        });
    }

    proptest! {
        #![proptest_config(ProptestConfig::with_cases(500))]

        #[test]
        fn proptest_slot_read_write_u256(slot in arb_u256(),value in arb_u256()) {
            let (mut storage, address) = setup_storage();
            StorageContext::enter(&mut storage, || -> std::result::Result<(), TestCaseError> {
                let mut slot = Slot::<U256>::new(slot, address);

                // Write and read back
                slot.write(value).unwrap();
                let loaded = slot.read().unwrap();
                prop_assert_eq!(loaded, value, "roundtrip failed");

                // Delete and verify
                slot.delete().unwrap();
                let after_delete = slot.read().unwrap();
                prop_assert_eq!(after_delete, U256::ZERO, "not zero after delete");
                Ok(())
            })?;
        }

        #[test]
        fn proptest_slot_read_write_address(slot in arb_u256(),addr_value in arb_address()) {
            let (mut storage, address) = setup_storage();
            StorageContext::enter(&mut storage, || -> std::result::Result<(), TestCaseError> {
                let mut slot = Slot::<Address>::new(slot, address);

                // Write and read back
                slot.write(addr_value).unwrap();
                let loaded = slot.read().unwrap();
                prop_assert_eq!(loaded, addr_value, "address roundtrip failed");
                Ok(())
            })?;
        }

        #[test]
        fn proptest_slot_isolation(slot1 in arb_u256(), slot2 in arb_u256(), value1 in arb_u256(), value2 in arb_u256()) {
            let (mut storage, address) = setup_storage();
            StorageContext::enter(&mut storage, || -> std::result::Result<(), TestCaseError> {
                let mut slot1 = Slot::<U256>::new(slot1, address.clone());
                let mut slot2 = Slot::<U256>::new(slot2, address);

                slot1.write(value1).unwrap();
                slot2.write(value2).unwrap();

                // Verify both slots retain their independent values
                let loaded1 = slot1.read().unwrap();
                let loaded2 = slot2.read().unwrap();

                prop_assert_eq!(loaded1, value1, "slot 1 value changed");
                prop_assert_eq!(loaded2, value2, "slot 2 value changed");

                // Delete slot 1, verify slot 2 unaffected
                slot1.delete().unwrap();
                let after_delete1 = slot1.read().unwrap();
                let after_delete2 = slot2.read().unwrap();

                prop_assert_eq!(after_delete1, U256::ZERO, "slot 1 not deleted");
                prop_assert_eq!(after_delete2, value2, "slot 2 affected by slot 1 delete");
                Ok(())
            })?;
        }
    }

    // -- RUNTIME SLOT OFFSET TESTS --------------------------------------------

    #[test]
    fn test_slot_at_offset() {
        let (mut storage, address) = setup_storage();
        StorageContext::enter(&mut storage, || {
            let pair_key = B256::random();
            let orderbook_base_slot = pair_key.mapping_slot(U256::ZERO);

            let base_address = Address::random();

            // Write to orderbook.base using runtime offset
            let mut slot = Slot::<Address>::new_at_offset(orderbook_base_slot, 0, address);
            slot.write(base_address).unwrap();

            // Read back
            let read_address = slot.read().unwrap();

            assert_eq!(read_address, base_address);

            // Delete
            slot.delete().unwrap();

            let deleted = slot.read().unwrap();

            assert_eq!(deleted, Address::ZERO);
        });
    }

    // #[test]
    // fn test_slot_at_offset_multi_slot_value() {
    //     let (mut storage, address) = setup_storage();
    // let _guard = storage.enter().unwrap();

    //         let struct_key = B256::random();
    //         let struct_base = mapping_slot(struct_key, U256::ZERO);

    //         // Test writing a multi-slot value like a String at offset 2
    //         let test_string = "Hello, Orderbook!".to_string();

    //         let mut slot = Slot::<String>::new_at_offset(struct_base, 2, address.clone());
    //         slot.write(test_string.clone()).unwrap();

    //         let read_string = slot.read().unwrap();

    //         assert_eq!(read_string, test_string);
    // }

    #[test]
    fn test_multiple_primitive_fields() {
        let (mut storage, address) = setup_storage();
        StorageContext::enter(&mut storage, || {
            let key = B256::random();
            let base = key.mapping_slot(U256::ZERO);

            // Simulate different primitive fields at different offsets
            let field_0 = Address::random();
            let field_1: u64 = 12345;
            let field_2 = U256::random();

            Slot::<Address>::new_at_offset(base, 0, address.clone())
                .write(field_0)
                .unwrap();
            Slot::<u64>::new_at_offset(base, 1, address.clone())
                .write(field_1)
                .unwrap();
            Slot::<U256>::new_at_offset(base, 2, address.clone())
                .write(field_2)
                .unwrap();

            // Verify independence
            let read_0 = Slot::<Address>::new_at_offset(base, 0, address.clone())
                .read()
                .unwrap();
            let read_1 = Slot::<u64>::new_at_offset(base, 1, address.clone())
                .read()
                .unwrap();
            let read_2 = Slot::<U256>::new_at_offset(base, 2, address)
                .read()
                .unwrap();

            assert_eq!(read_0, field_0);
            assert_eq!(read_1, field_1);
            assert_eq!(read_2, field_2);
        });
    }
}
