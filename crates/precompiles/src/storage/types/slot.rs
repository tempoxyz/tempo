use alloy::primitives::U256;
use std::marker::PhantomData;

use crate::{
    error::Result,
    storage::{Storable, StorageOps},
};

/// Type-safe wrapper for a single EVM storage slot.
///
/// # Type Parameters
///
/// - `T`: The Rust type stored in this slot (must implement `Storable<N>`)
///
/// # Example
///
/// ```ignore
/// // Generated by #[contract] macro:
/// pub mod slots {
///     pub const NAME: U256 = uint!(2_U256);
/// }
/// let name_slot = Slot::<String>::new(slots::NAME);
/// ```
///
/// The actual storage operations are handled by generated accessor methods
/// that read/write values using the `PrecompileStorageProvider` trait.
#[derive(Debug, Clone, Copy)]
pub struct Slot<T> {
    slot: U256,
    _phantom: PhantomData<T>,
}

impl<T> Slot<T> {
    /// Creates a new `Slot` with the given slot number.
    ///
    /// This is typically called with slot constants generated by the `#[contract]` macro.
    #[inline]
    pub const fn new(slot: U256) -> Self {
        Self {
            slot,
            _phantom: PhantomData,
        }
    }

    /// Returns the U256 storage slot number.
    #[inline]
    pub const fn slot(&self) -> U256 {
        self.slot
    }

    /// Reads a value from storage at this slot.
    ///
    /// This method delegates to the `Storable::load` implementation,
    /// which may read one or more consecutive slots depending on `N`.
    ///
    /// # Example
    ///
    /// ```ignore
    /// let name_slot = Slot::<String>::new(slots::NAME);
    /// let name = name_slot.read(&mut contract)?;
    /// ```
    #[inline]
    pub fn read<S: StorageOps, const N: usize>(&self, storage: &mut S) -> Result<T>
    where
        T: Storable<N>,
    {
        T::load(storage, self.slot, crate::storage::types::LayoutCtx::Full)
    }

    /// Writes a value to storage at this slot.
    ///
    /// This method delegates to the `Storable::store` implementation,
    /// which may write one or more consecutive slots depending on `N`.
    ///
    /// # Example
    ///
    /// ```ignore
    /// let name_slot = Slot::<String>::new(slots::NAME);
    /// name_slot.write(&mut contract, "MyToken".to_string())?;
    /// ```
    #[inline]
    pub fn write<S: StorageOps, const N: usize>(&self, storage: &mut S, value: T) -> Result<()>
    where
        T: Storable<N>,
    {
        value.store(storage, self.slot, crate::storage::types::LayoutCtx::Full)
    }

    /// Deletes the value at this slot (sets all slots to zero).
    ///
    /// This method delegates to the `Storable::delete` implementation,
    /// which sets `N` consecutive slots to zero.
    ///
    /// # Example
    ///
    /// ```ignore
    /// let name_slot = Slot::<String>::new(slots::NAME);
    /// name_slot.delete(&mut contract)?;
    /// ```
    #[inline]
    pub fn delete<S: StorageOps, const N: usize>(&self, storage: &mut S) -> Result<()>
    where
        T: Storable<N>,
    {
        T::delete(storage, self.slot, crate::storage::types::LayoutCtx::Full)
    }

    /// Reads a value from a field within a struct at a runtime base slot.
    ///
    /// This enables accessing non-packed fields within structs when you have
    /// the struct's base slot at runtime and know the field's offset.
    ///
    /// # Example
    ///
    /// ```ignore
    /// // For: mapping(bytes32 => Orderbook) books, where Orderbook.base is at field offset 0
    /// let orderbook_base = mapping_slot(pair_key, BooksSlot::SLOT);
    /// let base_address = Slot::<Address, DummySlot>::read_at_offset(
    ///     &mut storage,
    ///     orderbook_base,
    ///     0  // field offset
    /// )?;
    /// ```
    #[inline]
    pub fn read_at_offset<S: StorageOps, const N: usize>(
        storage: &mut S,
        struct_base_slot: U256,
        field_offset_slots: usize,
    ) -> Result<T>
    where
        T: Storable<N>,
    {
        let slot = struct_base_slot + U256::from(field_offset_slots);
        T::load(storage, slot, crate::storage::types::LayoutCtx::Full)
    }

    /// Writes a value to a field within a struct at a runtime base slot.
    ///
    /// # Example
    ///
    /// ```ignore
    /// let orderbook_base = mapping_slot(pair_key, BooksSlot::SLOT);
    /// Slot::<Address, DummySlot>::write_at_offset(
    ///     &mut storage,
    ///     orderbook_base,
    ///     0,  // field offset
    ///     base_address
    /// )?;
    /// ```
    #[inline]
    pub fn write_at_offset<S: StorageOps, const N: usize>(
        storage: &mut S,
        struct_base_slot: U256,
        field_offset_slots: usize,
        value: T,
    ) -> Result<()>
    where
        T: Storable<N>,
    {
        let slot = struct_base_slot + U256::from(field_offset_slots);
        value.store(storage, slot, crate::storage::types::LayoutCtx::Full)
    }

    /// Deletes a field within a struct at a runtime base slot (sets slots to zero).
    ///
    /// # Example
    ///
    /// ```ignore
    /// let orderbook_base = mapping_slot(pair_key, BooksSlot::SLOT);
    /// Slot::<Address, DummySlot>::delete_at_offset(
    ///     &mut storage,
    ///     orderbook_base,
    ///     0  // field offset
    /// )?;
    /// ```
    #[inline]
    pub fn delete_at_offset<S: StorageOps, const N: usize>(
        storage: &mut S,
        struct_base_slot: U256,
        field_offset_slots: usize,
    ) -> Result<()>
    where
        T: Storable<N>,
    {
        let slot = struct_base_slot + U256::from(field_offset_slots);
        T::delete(storage, slot, crate::storage::types::LayoutCtx::Full)
    }

    /// Reads a packed field from storage at a given base slot.
    ///
    /// Use this method when the field shares a storage slot with other fields (i.e., is packed).
    /// For fields that occupy their own slot(s), use `read_at_offset` instead.
    #[inline]
    pub fn read_at_offset_packed<S: StorageOps>(
        storage: &mut S,
        struct_base_slot: U256,
        location: crate::storage::FieldLocation,
    ) -> Result<T>
    where
        T: Storable<1>,
    {
        crate::storage::packing::read_packed_at(storage, struct_base_slot, location)
    }

    /// Writes a packed field to storage at a given base slot.
    ///
    /// Use this method when the field shares a storage slot with other fields (i.e., is packed).
    /// This correctly preserves other fields in the same slot.
    /// For fields that occupy their own slot(s), use `write_at_offset` instead.
    #[inline]
    pub fn write_at_offset_packed<S: StorageOps>(
        storage: &mut S,
        struct_base_slot: U256,
        location: crate::storage::FieldLocation,
        value: T,
    ) -> Result<()>
    where
        T: Storable<1>,
    {
        crate::storage::packing::write_packed_at(storage, struct_base_slot, location, &value)
    }

    /// Deletes a packed field in storage at a given base slot (sets bytes to zero).
    ///
    /// Use this method when the field shares a storage slot with other fields (i.e., is packed).
    /// This correctly preserves other fields in the same slot.
    /// For fields that occupy their own slot(s), use `delete_at_offset` instead.
    #[inline]
    pub fn delete_at_offset_packed<S: StorageOps>(
        storage: &mut S,
        struct_base_slot: U256,
        location: crate::storage::FieldLocation,
    ) -> Result<()>
    where
        T: Storable<1>,
    {
        crate::storage::packing::clear_packed_at(storage, struct_base_slot, location)
    }
}

impl<T> Default for Slot<T> {
    fn default() -> Self {
        Self::new(U256::ZERO)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::storage::{
        PrecompileStorageProvider, hashmap::HashMapStorageProvider, mapping_slot,
    };
    use alloy::primitives::{Address, B256};
    use proptest::prelude::*;

    // Test helper that implements StorageOps
    struct TestContract<'a, S> {
        address: Address,
        storage: &'a mut S,
    }

    impl<'a, S: PrecompileStorageProvider> StorageOps for TestContract<'a, S> {
        fn sstore(&mut self, slot: U256, value: U256) -> Result<()> {
            self.storage.sstore(self.address, slot, value)
        }

        fn sload(&mut self, slot: U256) -> Result<U256> {
            self.storage.sload(self.address, slot)
        }
    }

    /// Helper to create a test contract with fresh storage.
    fn setup_test_contract<'a>(
        storage: &'a mut HashMapStorageProvider,
    ) -> TestContract<'a, HashMapStorageProvider> {
        TestContract {
            address: Address::random(),
            storage,
        }
    }

    // Test slot constants
    const TEST_SLOT_0: U256 = U256::ZERO;
    const TEST_SLOT_1: U256 = U256::from_limbs([1, 0, 0, 0]);
    const TEST_SLOT_2: U256 = U256::from_limbs([2, 0, 0, 0]);
    const TEST_SLOT_MAX: U256 = U256::MAX;

    // Property test strategies
    fn arb_address() -> impl Strategy<Value = Address> {
        any::<[u8; 20]>().prop_map(Address::from)
    }

    fn arb_u256() -> impl Strategy<Value = U256> {
        any::<[u64; 4]>().prop_map(U256::from_limbs)
    }

    #[test]
    fn test_slot_size() {
        // Slot now stores U256, so it's 32 bytes + PhantomData (zero-sized)
        assert_eq!(std::mem::size_of::<Slot<U256>>(), 32);
        assert_eq!(std::mem::size_of::<Slot<Address>>(), 32);
        assert_eq!(std::mem::size_of::<Slot<bool>>(), 32);
    }

    #[test]
    fn test_slot_creation() {
        let _slot_u256 = Slot::<U256>::new(TEST_SLOT_0);
        let _slot_addr = Slot::<Address>::new(TEST_SLOT_1);
        let _slot_default = Slot::<bool>::default();
        assert_eq!(_slot_default.slot(), U256::ZERO);
    }

    #[test]
    fn test_slot_number_extraction() {
        let slot_0 = Slot::<U256>::new(TEST_SLOT_0);
        let slot_1 = Slot::<Address>::new(TEST_SLOT_1);
        let slot_max = Slot::<bool>::new(TEST_SLOT_MAX);
        assert_eq!(slot_0.slot(), U256::ZERO);
        assert_eq!(slot_1.slot(), TEST_SLOT_1);
        assert_eq!(slot_max.slot(), U256::MAX);
    }

    #[test]
    fn test_slot_edge_case_zero() {
        // Explicit test for U256::ZERO slot
        let slot = Slot::<U256>::new(TEST_SLOT_0);
        assert_eq!(slot.slot(), U256::ZERO);

        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);
        let value = U256::random();

        _ = slot.write(&mut contract, value);
        let loaded = slot.read(&mut contract).unwrap();
        assert_eq!(loaded, value);
    }

    #[test]
    fn test_slot_edge_case_max() {
        // Explicit test for U256::MAX slot
        let slot = Slot::<U256>::new(TEST_SLOT_MAX);
        assert_eq!(slot.slot(), U256::MAX);

        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);

        let value = U256::random();
        _ = slot.write(&mut contract, value);
        let loaded = slot.read(&mut contract).unwrap();
        assert_eq!(loaded, value);
    }

    #[test]
    fn test_slot_read_write_u256() {
        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);
        let slot = Slot::<U256>::new(TEST_SLOT_1);
        let test_value = U256::random();

        // Write using new API
        _ = slot.write(&mut contract, test_value);

        // Read using new API
        let loaded = slot.read(&mut contract).unwrap();
        assert_eq!(loaded, test_value);

        // Verify it actually wrote to slot 1
        let raw = contract.storage.sload(contract.address, TEST_SLOT_1);
        assert_eq!(raw, Ok(test_value));
    }

    #[test]
    fn test_slot_read_write_address() {
        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);
        let test_addr = Address::random();
        let slot = Slot::<Address>::new(TEST_SLOT_1);

        // Write
        _ = slot.write(&mut contract, test_addr);

        // Read
        let loaded = slot.read(&mut contract).unwrap();
        assert_eq!(loaded, test_addr);
    }

    #[test]
    fn test_slot_read_write_bool() {
        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);
        let slot = Slot::<bool>::new(TEST_SLOT_1);

        // Write true
        _ = slot.write(&mut contract, true);
        assert!(slot.read(&mut contract).unwrap());

        // Write false
        _ = slot.write(&mut contract, false);
        assert!(!slot.read(&mut contract).unwrap());
    }

    #[test]
    fn test_slot_read_write_string() {
        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);
        let slot = Slot::<String>::new(TEST_SLOT_1);

        let test_name = "TestToken";
        _ = slot.write(&mut contract, test_name.to_string());

        let loaded = slot.read(&mut contract).unwrap();
        assert_eq!(loaded, test_name);
    }

    #[test]
    fn test_slot_default_value_is_zero() {
        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);
        let slot = Slot::<U256>::new(TEST_SLOT_1);

        // Reading uninitialized storage should return zero
        let value = slot.read(&mut contract).unwrap();
        assert_eq!(value, U256::ZERO);
    }

    #[test]
    fn test_slot_overwrite() {
        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);
        let slot = Slot::<u64>::new(TEST_SLOT_1);

        // Write initial value
        _ = slot.write(&mut contract, 100);
        assert_eq!(slot.read(&mut contract), Ok(100));

        // Overwrite with new value
        _ = slot.write(&mut contract, 200);
        assert_eq!(slot.read(&mut contract), Ok(200));
    }

    proptest! {
        #![proptest_config(ProptestConfig::with_cases(500))]

        #[test]
        fn proptest_slot_read_write_u256(value in arb_u256()) {
            let mut storage = HashMapStorageProvider::new(1);
            let mut contract = setup_test_contract(&mut storage);
            let slot = Slot::<U256>::new(TEST_SLOT_2);

            // Write and read back
            slot.write(&mut contract, value)?;
            let loaded = slot.read(&mut contract)?;
            prop_assert_eq!(loaded, value, "roundtrip failed");

            // Delete and verify
            slot.delete(&mut contract)?;
            let after_delete = slot.read(&mut contract)?;
            prop_assert_eq!(after_delete, U256::ZERO, "not zero after delete");
        }

        #[test]
        fn proptest_slot_read_write_address(addr_value in arb_address()) {
            let mut storage = HashMapStorageProvider::new(1);
            let mut contract = setup_test_contract(&mut storage);
            let slot = Slot::<Address>::new(TEST_SLOT_1);

            // Write and read back
            slot.write(&mut contract, addr_value)?;
            let loaded = slot.read(&mut contract)?;
            prop_assert_eq!(loaded, addr_value, "address roundtrip failed");
        }

        #[test]
        fn proptest_slot_isolation(value1 in arb_u256(), value2 in arb_u256()) {
            let mut storage = HashMapStorageProvider::new(1);
            let mut contract = setup_test_contract(&mut storage);
            let slot1 = Slot::<U256>::new(TEST_SLOT_1);
            let slot2 = Slot::<U256>::new(TEST_SLOT_2);

            slot1.write(&mut contract, value1)?;
            slot2.write(&mut contract, value2)?;

            // Verify both slots retain their independent values
            let loaded1 = slot1.read(&mut contract)?;
            let loaded2 = slot2.read(&mut contract)?;

            prop_assert_eq!(loaded1, value1, "slot 1 value changed");
            prop_assert_eq!(loaded2, value2, "slot 2 value changed");

            // Delete slot 1, verify slot 2 unaffected
            slot1.delete(&mut contract)?;
            let after_delete1 = slot1.read(&mut contract)?;
            let after_delete2 = slot2.read(&mut contract)?;

            prop_assert_eq!(after_delete1, U256::ZERO, "slot 1 not deleted");
            prop_assert_eq!(after_delete2, value2, "slot 2 affected by slot 1 delete");
        }
    }

    // -- RUNTIME SLOT OFFSET TESTS --------------------------------------------

    #[test]
    fn test_slot_at_offset() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);

        let pair_key: B256 = U256::from(0xabcd).into();
        let orderbook_base_slot = mapping_slot(pair_key, U256::ZERO);

        let base_address = Address::random();

        // Write to orderbook.base using runtime offset
        Slot::<Address>::write_at_offset(
            &mut contract,
            orderbook_base_slot,
            0, // base field at offset 0
            base_address,
        )?;

        // Read back
        let read_address = Slot::<Address>::read_at_offset(&mut contract, orderbook_base_slot, 0)?;

        assert_eq!(read_address, base_address);

        // Delete
        Slot::<Address>::delete_at_offset(&mut contract, orderbook_base_slot, 0)?;

        let deleted = Slot::<Address>::read_at_offset(&mut contract, orderbook_base_slot, 0)?;

        assert_eq!(deleted, Address::ZERO);

        Ok(())
    }

    #[test]
    fn test_slot_at_offset_multi_slot_value() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);

        let struct_key: B256 = U256::from(0xabcd).into();
        let struct_base = mapping_slot(struct_key, U256::ZERO);

        // Test writing a multi-slot value like a String at offset 2
        let test_string = "Hello, Orderbook!".to_string();

        Slot::<String>::write_at_offset(&mut contract, struct_base, 2, test_string.clone())?;

        let read_string = Slot::<String>::read_at_offset(&mut contract, struct_base, 2)?;

        assert_eq!(read_string, test_string);

        Ok(())
    }

    #[test]
    fn test_multiple_primitive_fields() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);

        let key: B256 = U256::from(0x9999).into();
        let base = mapping_slot(key, U256::ZERO);

        // Simulate different primitive fields at different offsets
        let field_0 = Address::random();
        let field_1: u64 = 12345;
        let field_2 = U256::from(999999);

        Slot::<Address>::write_at_offset(&mut contract, base, 0, field_0)?;
        Slot::<u64>::write_at_offset(&mut contract, base, 1, field_1)?;
        Slot::<U256>::write_at_offset(&mut contract, base, 2, field_2)?;

        // Verify independence
        let read_0 = Slot::<Address>::read_at_offset(&mut contract, base, 0)?;
        let read_1 = Slot::<u64>::read_at_offset(&mut contract, base, 1)?;
        let read_2 = Slot::<U256>::read_at_offset(&mut contract, base, 2)?;

        assert_eq!(read_0, field_0);
        assert_eq!(read_1, field_1);
        assert_eq!(read_2, field_2);

        Ok(())
    }
}
