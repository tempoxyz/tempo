use alloy::primitives::{Address, U256};
use std::marker::PhantomData;

use crate::{
    error::Result,
    storage::{
        FieldLocation, Handler, LayoutCtx, Storable, StorableType, StorageContext, StorageOps,
    },
};

/// Type-safe wrapper for a single EVM storage slot.
///
/// # Type Parameters
///
/// - `T`: The Rust type stored in this slot (must implement `Storable`)
///
/// # Example
///
/// ```ignore
/// // Generated by #[contract] macro:
/// pub mod slots {
///     pub const NAME: U256 = uint!(2_U256);
/// }
/// let name_slot = Slot::<String>::new(slots::NAME);
/// ```
///
/// The actual storage operations are handled by generated accessor methods
/// that read/write values using the `PrecompileStorageProvider` trait.
#[derive(Debug, Clone)]
pub struct Slot<T> {
    slot: U256,
    ctx: LayoutCtx,
    address: Address,
    _ty: PhantomData<T>,
}

impl<T> Default for Slot<T> {
    fn default() -> Self {
        Self::new(U256::ZERO, Address::ZERO)
    }
}

impl<T> Slot<T> {
    /// Creates a new `Slot` with the given slot number and address.
    ///
    /// This is typically called with slot constants generated by the `#[contract]` macro.
    /// Creates a full-slot accessor. For packed fields, use `new_at_loc` instead.
    #[inline]
    pub fn new(slot: U256, address: Address) -> Self {
        Self {
            slot,
            ctx: LayoutCtx::FULL,
            address,
            _ty: PhantomData,
        }
    }

    /// Creates a new `Slot` with the given slot number, layout context, and address.
    ///
    /// This is used by the handler system to create slots with specific packing contexts.
    #[inline]
    pub fn new_with_ctx(slot: U256, ctx: LayoutCtx, address: Address) -> Self {
        Self {
            slot,
            ctx,
            address,
            _ty: PhantomData,
        }
    }

    /// Creates a new `Slot` with the given base slot number with the given offset and address.
    ///
    /// This is a convenience method for accessing struct fields.
    /// Creates a full-slot accessor. For packed fields, use `new_at_loc` instead.
    #[inline]
    pub fn new_at_offset(base_slot: U256, offset_slots: usize, address: Address) -> Self {
        Self {
            slot: base_slot.saturating_add(U256::from_limbs([offset_slots as u64, 0, 0, 0])),
            ctx: LayoutCtx::FULL,
            address,
            _ty: PhantomData,
        }
    }

    /// Creates a new `Slot` from a `FieldLocation` generated by the `#[derive(Storable)]` macro.
    ///
    /// This is the recommended way to access packed struct fields, combining slot offset
    /// and byte offset information in a type-safe manner.
    ///
    /// This method should only be used with packable types (size < 32 bytes).
    #[inline]
    pub fn new_at_loc(base_slot: U256, loc: FieldLocation, address: Address) -> Self
    where
        T: StorableType,
    {
        debug_assert!(
            T::IS_PACKABLE,
            "`fn new_at_loc` can only be used with packable types"
        );
        Self {
            slot: base_slot.saturating_add(U256::from_limbs([loc.offset_slots as u64, 0, 0, 0])),
            ctx: LayoutCtx::packed(loc.offset_bytes),
            address,
            _ty: PhantomData,
        }
    }

    /// Returns the storage slot number where the underlying type is stored.
    ///
    /// Multi-slot types use consecutive slots from this base slot.
    #[inline]
    pub const fn slot(&self) -> U256 {
        self.slot
    }

    /// Returns the byte offset within the slot (for packed fields).
    ///
    /// Returns `Some(offset)` if this is a packed slot, `None` if it's a full slot.
    #[inline]
    pub const fn offset(&self) -> Option<usize> {
        self.ctx.packed_offset()
    }
}

impl<T> StorageOps for Slot<T> {
    fn load(&self, slot: U256) -> Result<U256> {
        let storage = StorageContext;
        storage.sload(self.address, slot)
    }

    fn store(&mut self, slot: U256, value: U256) -> Result<()> {
        let mut storage = StorageContext;
        storage.sstore(self.address, slot, value)
    }
}

/// Wrapper that routes storage operations through transient storage (TLOAD/TSTORE).
///
/// Created via `Slot::transient()` and used by `t_read()`, `t_write()`, `t_delete()`.
struct TransientOps {
    address: Address,
}

impl StorageOps for TransientOps {
    fn load(&self, slot: U256) -> Result<U256> {
        let storage = StorageContext;
        storage.tload(self.address, slot)
    }

    fn store(&mut self, slot: U256, value: U256) -> Result<()> {
        let mut storage = StorageContext;
        storage.tstore(self.address, slot, value)
    }
}

impl<T: Storable> Slot<T> {
    /// Returns a transient storage operations wrapper for this slot's address.
    fn transient(&self) -> TransientOps {
        TransientOps {
            address: self.address,
        }
    }
}

impl<T: Storable> Handler<T> for Slot<T> {
    /// Reads a value from storage at this slot.
    ///
    /// This method delegates to the `Storable::load` implementation,
    /// which may read one or more consecutive slots depending on the type.
    ///
    /// Uses thread-local storage context initialized by [`StorageGuard`].
    ///
    /// # Example
    ///
    /// ```ignore
    /// let name_slot = Slot::<String>::new(slots::NAME, address_rc);
    /// let name = name_slot.read().unwrap();
    /// ```
    #[inline]
    fn read(&self) -> Result<T> {
        T::load(self, self.slot, self.ctx)
    }

    /// Writes a value to storage at this slot.
    ///
    /// This method delegates to the `Storable::store` implementation,
    /// which may write one or more consecutive slots depending on the type.
    ///
    /// Uses thread-local storage context initialized by [`StorageGuard`].
    ///
    /// # Example
    ///
    /// ```ignore
    /// let mut name_slot = Slot::<String>::new(slots::NAME, address_rc);
    /// name_slot.write("MyToken".to_string()).unwrap();
    /// ```
    #[inline]
    fn write(&mut self, value: T) -> Result<()> {
        value.store(self, self.slot, self.ctx)
    }

    /// Deletes the value at this slot (sets all slots to zero).
    ///
    /// This method delegates to the `Storable::delete` implementation,
    /// which sets the appropriate slots to zero.
    ///
    /// Uses thread-local storage context initialized by [`StorageGuard`].
    ///
    /// # Example
    ///
    /// ```ignore
    /// let mut name_slot = Slot::<String>::new(slots::NAME, address_rc);
    /// name_slot.delete().unwrap();
    /// ```
    #[inline]
    fn delete(&mut self) -> Result<()> {
        T::delete(self, self.slot, self.ctx)
    }

    /// Reads a value from transient storage at this slot.
    #[inline]
    fn t_read(&self) -> Result<T> {
        T::load(&self.transient(), self.slot, self.ctx)
    }

    /// Writes a value to transient storage at this slot.
    #[inline]
    fn t_write(&mut self, value: T) -> Result<()> {
        value.store(&mut self.transient(), self.slot, self.ctx)
    }

    /// Deletes the value at this slot in transient storage (sets to zero).
    #[inline]
    fn t_delete(&mut self) -> Result<()> {
        T::delete(&mut self.transient(), self.slot, self.ctx)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{
        storage::{Handler, PrecompileStorageProvider, StorageKey},
        test_util::setup_storage,
    };
    use alloy::primitives::{Address, B256};
    use proptest::prelude::*;

    // Property test strategies
    fn arb_address() -> impl Strategy<Value = Address> {
        any::<[u8; 20]>().prop_map(Address::from)
    }

    fn arb_u256() -> impl Strategy<Value = U256> {
        any::<[u64; 4]>().prop_map(U256::from_limbs)
    }

    // -- BASIC TESTS -----------------------------------------------------------

    #[test]
    fn test_slot_size() {
        // slot (U256) 32 bytes + LayoutCtx (usize) 8 bytes + Address 20 bytes (+4 for byte alignement)
        assert_eq!(std::mem::size_of::<Slot<U256>>(), 64);
        assert_eq!(std::mem::size_of::<Slot<Address>>(), 64);
        assert_eq!(std::mem::size_of::<Slot<bool>>(), 64);
    }

    #[test]
    fn test_slot_number_extraction() -> eyre::Result<()> {
        let (mut storage, address) = setup_storage();
        StorageContext::enter(&mut storage, || {
            let slot_0 = Slot::<U256>::new(U256::ZERO, address.clone());
            let slot_1 = Slot::<Address>::new(U256::ONE, address.clone());
            let slot_max = Slot::<bool>::new(U256::MAX, address);
            assert_eq!(slot_0.slot(), U256::ZERO);
            assert_eq!(slot_1.slot(), U256::ONE);
            assert_eq!(slot_max.slot(), U256::MAX);
            Ok(())
        })
    }

    #[test]
    fn test_slot_edge_cases() -> eyre::Result<()> {
        let (mut storage, address) = setup_storage();
        StorageContext::enter(&mut storage, || {
            // U256::ZERO slot
            let mut slot_zero = Slot::<U256>::new(U256::ZERO, address);
            assert_eq!(slot_zero.slot(), U256::ZERO);
            let value_zero = U256::random();
            slot_zero.write(value_zero)?;
            assert_eq!(slot_zero.read()?, value_zero);

            // U256::MAX slot
            let mut slot_max = Slot::<U256>::new(U256::MAX, address);
            assert_eq!(slot_max.slot(), U256::MAX);
            let value_max = U256::random();
            slot_max.write(value_max)?;
            assert_eq!(slot_max.read()?, value_max);

            Ok(())
        })
    }

    #[test]
    fn test_slot_read_write_types() -> eyre::Result<()> {
        let (mut storage, address) = setup_storage();
        let slot_num = U256::random();
        let test_value = U256::random();

        StorageContext::enter(&mut storage, || -> eyre::Result<()> {
            // U256
            let mut u256_slot = Slot::<U256>::new(slot_num, address);
            u256_slot.write(test_value)?;
            assert_eq!(u256_slot.read()?, test_value);

            // Address
            let test_addr = Address::random();
            let mut addr_slot = Slot::<Address>::new(U256::from(1), address);
            addr_slot.write(test_addr)?;
            assert_eq!(addr_slot.read()?, test_addr);

            // bool
            let mut bool_slot = Slot::<bool>::new(U256::from(2), address);
            bool_slot.write(true)?;
            assert!(bool_slot.read()?);
            bool_slot.write(false)?;
            assert!(!bool_slot.read()?);

            // String
            let mut str_slot = Slot::<String>::new(U256::from(3), address);
            str_slot.write("TestToken".to_string())?;
            assert_eq!(str_slot.read()?, "TestToken");

            Ok(())
        })?;

        // Verify U256 actually wrote to slot
        let raw = storage.sload(address, slot_num)?;
        assert_eq!(raw, test_value);
        Ok(())
    }

    #[test]
    fn test_slot_default_and_overwrite() -> eyre::Result<()> {
        let (mut storage, address) = setup_storage();
        StorageContext::enter(&mut storage, || {
            // Default value is zero
            let mut slot = Slot::<u64>::new(U256::random(), address);
            assert_eq!(slot.read()?, 0);

            // Write and overwrite
            slot.write(100)?;
            assert_eq!(slot.read()?, 100);
            slot.write(200)?;
            assert_eq!(slot.read()?, 200);

            Ok(())
        })
    }

    proptest! {
        #![proptest_config(ProptestConfig::with_cases(500))]

        #[test]
        fn proptest_slot_read_write_u256(slot in arb_u256(),value in arb_u256()) {
            let (mut storage, address) = setup_storage();
            StorageContext::enter(&mut storage, || -> std::result::Result<(), TestCaseError> {
                let mut slot = Slot::<U256>::new(slot, address);

                // Write and read back
                slot.write(value).unwrap();
                let loaded = slot.read().unwrap();
                prop_assert_eq!(loaded, value, "roundtrip failed");

                // Delete and verify
                slot.delete().unwrap();
                let after_delete = slot.read().unwrap();
                prop_assert_eq!(after_delete, U256::ZERO, "not zero after delete");
                Ok(())
            })?;
        }

        #[test]
        fn proptest_slot_read_write_address(slot in arb_u256(),addr_value in arb_address()) {
            let (mut storage, address) = setup_storage();
            StorageContext::enter(&mut storage, || -> std::result::Result<(), TestCaseError> {
                let mut slot = Slot::<Address>::new(slot, address);

                // Write and read back
                slot.write(addr_value).unwrap();
                let loaded = slot.read().unwrap();
                prop_assert_eq!(loaded, addr_value, "address roundtrip failed");
                Ok(())
            })?;
        }

        #[test]
        fn proptest_slot_isolation(slot1 in arb_u256(), slot2 in arb_u256(), value1 in arb_u256(), value2 in arb_u256()) {
            let (mut storage, address) = setup_storage();
            StorageContext::enter(&mut storage, || -> std::result::Result<(), TestCaseError> {
                let mut slot1 = Slot::<U256>::new(slot1, address.clone());
                let mut slot2 = Slot::<U256>::new(slot2, address);

                slot1.write(value1).unwrap();
                slot2.write(value2).unwrap();

                // Verify both slots retain their independent values
                let loaded1 = slot1.read().unwrap();
                let loaded2 = slot2.read().unwrap();

                prop_assert_eq!(loaded1, value1, "slot 1 value changed");
                prop_assert_eq!(loaded2, value2, "slot 2 value changed");

                // Delete slot 1, verify slot 2 unaffected
                slot1.delete().unwrap();
                let after_delete1 = slot1.read().unwrap();
                let after_delete2 = slot2.read().unwrap();

                prop_assert_eq!(after_delete1, U256::ZERO, "slot 1 not deleted");
                prop_assert_eq!(after_delete2, value2, "slot 2 affected by slot 1 delete");
                Ok(())
            })?;
        }
    }

    // -- RUNTIME SLOT OFFSET TESTS --------------------------------------------

    #[test]
    fn test_slot_at_offset() -> eyre::Result<()> {
        let (mut storage, address) = setup_storage();
        StorageContext::enter(&mut storage, || {
            let pair_key = B256::random();
            let base = pair_key.mapping_slot(U256::ZERO);
            let test_addr = Address::random();

            // Write, read, delete
            let mut slot = Slot::<Address>::new_at_offset(base, 0, address);
            slot.write(test_addr)?;
            assert_eq!(slot.read()?, test_addr);
            slot.delete()?;
            assert_eq!(slot.read()?, Address::ZERO);

            Ok(())
        })
    }

    #[test]
    fn test_multiple_primitive_fields() -> eyre::Result<()> {
        let (mut storage, address) = setup_storage();
        StorageContext::enter(&mut storage, || {
            let key = B256::random();
            let base = key.mapping_slot(U256::ZERO);

            let field_0 = Address::random();
            let field_1: u64 = (U256::random() % U256::from(u64::MAX)).to();
            let field_2 = U256::random();

            Slot::<Address>::new_at_offset(base, 0, address).write(field_0)?;
            Slot::<u64>::new_at_offset(base, 1, address).write(field_1)?;
            Slot::<U256>::new_at_offset(base, 2, address).write(field_2)?;

            assert_eq!(
                Slot::<Address>::new_at_offset(base, 0, address).read()?,
                field_0
            );
            assert_eq!(
                Slot::<u64>::new_at_offset(base, 1, address).read()?,
                field_1
            );
            assert_eq!(
                Slot::<U256>::new_at_offset(base, 2, address).read()?,
                field_2
            );

            Ok(())
        })
    }

    // -- TRANSIENT STORAGE TESTS ------------------------------------------------

    #[test]
    fn test_transient_ops() -> eyre::Result<()> {
        let (mut storage, address) = setup_storage();
        StorageContext::enter(&mut storage, || {
            // U256: default, roundtrip, overwrite, delete
            let mut u256_slot = Slot::<U256>::new(U256::from(1), address);
            assert_eq!(u256_slot.t_read()?, U256::ZERO);

            let num1 = U256::random();
            let num2 = U256::random();
            u256_slot.t_write(num1)?;
            assert_eq!(u256_slot.t_read()?, num1);
            u256_slot.t_write(num2)?;
            assert_eq!(u256_slot.t_read()?, num2);
            u256_slot.t_delete()?;
            assert_eq!(u256_slot.t_read()?, U256::ZERO);

            // Address: default, roundtrip, overwrite, delete
            let mut addr_slot = Slot::<Address>::new(U256::from(2), address);
            assert_eq!(addr_slot.t_read()?, Address::ZERO);

            let addr1 = Address::random();
            let addr2 = Address::random();
            addr_slot.t_write(addr1)?;
            assert_eq!(addr_slot.t_read()?, addr1);
            addr_slot.t_write(addr2)?;
            assert_eq!(addr_slot.t_read()?, addr2);
            addr_slot.t_delete()?;
            assert_eq!(addr_slot.t_read()?, Address::ZERO);

            // bool: default, roundtrip, overwrite, delete
            let mut bool_slot = Slot::<bool>::new(U256::from(3), address);
            assert!(!bool_slot.t_read()?);

            bool_slot.t_write(true)?;
            assert!(bool_slot.t_read()?);
            bool_slot.t_write(false)?;
            assert!(!bool_slot.t_read()?);
            bool_slot.t_delete()?;
            assert!(!bool_slot.t_read()?);

            Ok(())
        })
    }

    #[test]
    fn test_transient_persistance_isolation() -> eyre::Result<()> {
        let (mut storage, address) = setup_storage();
        let slot_num = U256::random();
        let t_value = U256::random();
        let s_value = U256::random();

        StorageContext::enter(&mut storage, || -> eyre::Result<()> {
            let mut slot = Slot::<U256>::new(slot_num, address);

            // Write different values to each storage type
            slot.write(s_value)?;
            slot.t_write(t_value)?;
            assert_eq!(slot.read()?, s_value);
            assert_eq!(slot.t_read()?, t_value);

            // Delete transient, persistent remains
            slot.t_delete()?;
            assert_eq!(slot.read()?, s_value);
            assert_eq!(slot.t_read()?, U256::ZERO);

            // Restore transient value
            slot.t_write(t_value)?;
            assert_eq!(slot.t_read()?, t_value);

            Ok(())
        })?;

        // Simulate new block
        storage.clear_transient();

        // Transient cleared, persistent remains
        StorageContext::enter(&mut storage, || {
            let slot = Slot::<U256>::new(slot_num, address);
            assert_eq!(slot.read()?, s_value);
            assert_eq!(slot.t_read()?, U256::ZERO);
            Ok(())
        })
    }
}
