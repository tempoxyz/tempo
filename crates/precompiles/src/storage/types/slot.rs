use alloy::primitives::U256;
use std::marker::PhantomData;

use crate::{
    error::Result,
    storage::{FieldLocation, Storable, StorageOps},
};

/// Type-safe wrapper for a single EVM storage slot.
///
/// # Type Parameters
///
/// - `T`: The Rust type stored in this slot (must implement `Storable<N>`)
///
/// # Example
///
/// ```ignore
/// // Generated by #[contract] macro:
/// pub mod slots {
///     pub const NAME: U256 = uint!(2_U256);
/// }
/// let name_slot = Slot::<String>::new(slots::NAME);
/// ```
///
/// The actual storage operations are handled by generated accessor methods
/// that read/write values using the `PrecompileStorageProvider` trait.
#[derive(Debug, Clone, Copy)]
pub struct Slot<T> {
    slot: U256,
    ctx: crate::storage::types::LayoutCtx,
    _ty: PhantomData<T>,
}

impl<T> Default for Slot<T> {
    fn default() -> Self {
        Self::new(U256::ZERO)
    }
}

impl<T> Slot<T> {
    /// Creates a new `Slot` with the given slot number.
    ///
    /// This is typically called with slot constants generated by the `#[contract]` macro.
    /// Creates a full-slot accessor. For packed fields, use `new_at_loc` instead.
    #[inline]
    pub const fn new(slot: U256) -> Self {
        Self {
            slot,
            ctx: crate::storage::types::LayoutCtx::FULL,
            _ty: PhantomData,
        }
    }

    /// Creates a new `Slot` with the given base slot number with the given offset.
    ///
    /// This is a convenience method for accessing struct fields.
    /// Creates a full-slot accessor. For packed fields, use `new_at_loc` instead.
    #[inline]
    pub const fn new_at_offset(base_slot: U256, offset_slots: usize) -> Self {
        Self {
            slot: base_slot.saturating_add(U256::from_limbs([offset_slots as u64, 0, 0, 0])),
            ctx: crate::storage::types::LayoutCtx::FULL,
            _ty: PhantomData,
        }
    }

    /// Creates a new `Slot` from a `FieldLocation` generated by the `#[derive(Storable)]` macro.
    ///
    /// This is the recommended way to access packed struct fields, combining slot offset
    /// and byte offset information in a type-safe manner.
    ///
    /// This method should only be used with packable types (size < 32 bytes).
    #[inline]
    pub const fn new_at_loc<const N: usize>(base_slot: U256, loc: FieldLocation) -> Self
    where
        T: Storable<N>,
    {
        debug_assert!(
            T::IS_PACKABLE,
            "`fn new_at_loc` can only be used with packable types"
        );
        Self {
            slot: base_slot.saturating_add(U256::from_limbs([loc.offset_slots as u64, 0, 0, 0])),
            ctx: crate::storage::types::LayoutCtx::packed(loc.offset_bytes),
            _ty: PhantomData,
        }
    }

    /// Returns the U256 storage slot number.
    #[inline]
    pub const fn slot(&self) -> U256 {
        self.slot
    }

    /// Returns the byte offset within the slot (for packed fields).
    ///
    /// Returns `Some(offset)` if this is a packed slot, `None` if it's a full slot.
    #[inline]
    pub const fn offset(&self) -> Option<usize> {
        self.ctx.packed_offset()
    }

    /// Reads a value from storage at this slot.
    ///
    /// This method delegates to the `Storable::load` implementation,
    /// which may read one or more consecutive slots depending on `N`.
    ///
    /// # Example
    ///
    /// ```ignore
    /// let name_slot = Slot::<String>::new(slots::NAME);
    /// let name = name_slot.read(&mut contract)?;
    /// ```
    #[inline]
    pub fn read<S: StorageOps, const N: usize>(&self, storage: &mut S) -> Result<T>
    where
        T: Storable<N>,
    {
        T::load(storage, self.slot, self.ctx)
    }

    /// Writes a value to storage at this slot.
    ///
    /// This method delegates to the `Storable::store` implementation,
    /// which may write one or more consecutive slots depending on `N`.
    ///
    /// # Example
    ///
    /// ```ignore
    /// let name_slot = Slot::<String>::new(slots::NAME);
    /// name_slot.write(&mut contract, "MyToken".to_string())?;
    /// ```
    #[inline]
    pub fn write<S: StorageOps, const N: usize>(&self, storage: &mut S, value: T) -> Result<()>
    where
        T: Storable<N>,
    {
        value.store(storage, self.slot, self.ctx)
    }

    /// Deletes the value at this slot (sets all slots to zero).
    ///
    /// This method delegates to the `Storable::delete` implementation,
    /// which sets `N` consecutive slots to zero.
    ///
    /// # Example
    ///
    /// ```ignore
    /// let name_slot = Slot::<String>::new(slots::NAME);
    /// name_slot.delete(&mut contract)?;
    /// ```
    #[inline]
    pub fn delete<S: StorageOps, const N: usize>(&self, storage: &mut S) -> Result<()>
    where
        T: Storable<N>,
    {
        T::delete(storage, self.slot, self.ctx)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::storage::{
        PrecompileStorageProvider, hashmap::HashMapStorageProvider, mapping_slot,
    };
    use alloy::primitives::{Address, B256};
    use proptest::prelude::*;

    // Test helper that implements StorageOps
    struct TestContract<'a, S> {
        address: Address,
        storage: &'a mut S,
    }

    impl<'a, S: PrecompileStorageProvider> StorageOps for TestContract<'a, S> {
        fn sstore(&mut self, slot: U256, value: U256) -> Result<()> {
            self.storage.sstore(self.address, slot, value)
        }

        fn sload(&mut self, slot: U256) -> Result<U256> {
            self.storage.sload(self.address, slot)
        }
    }

    /// Helper to create a test contract with fresh storage.
    fn setup_test_contract<'a>(
        storage: &'a mut HashMapStorageProvider,
    ) -> TestContract<'a, HashMapStorageProvider> {
        TestContract {
            address: Address::random(),
            storage,
        }
    }

    // Test slot constants
    const TEST_SLOT_0: U256 = U256::ZERO;
    const TEST_SLOT_1: U256 = U256::from_limbs([1, 0, 0, 0]);
    const TEST_SLOT_2: U256 = U256::from_limbs([2, 0, 0, 0]);
    const TEST_SLOT_MAX: U256 = U256::MAX;

    // Property test strategies
    fn arb_address() -> impl Strategy<Value = Address> {
        any::<[u8; 20]>().prop_map(Address::from)
    }

    fn arb_u256() -> impl Strategy<Value = U256> {
        any::<[u64; 4]>().prop_map(U256::from_limbs)
    }

    #[test]
    fn test_slot_size() {
        // slot (U256) 32 bytes + LayoutCtx (usize) 8 bytes + PhantomData (zero-sized)
        assert_eq!(std::mem::size_of::<Slot<U256>>(), 40);
        assert_eq!(std::mem::size_of::<Slot<Address>>(), 40);
        assert_eq!(std::mem::size_of::<Slot<bool>>(), 40);
    }

    #[test]
    fn test_slot_number_extraction() {
        let slot_0 = Slot::<U256>::new(TEST_SLOT_0);
        let slot_1 = Slot::<Address>::new(TEST_SLOT_1);
        let slot_max = Slot::<bool>::new(TEST_SLOT_MAX);
        assert_eq!(slot_0.slot(), U256::ZERO);
        assert_eq!(slot_1.slot(), TEST_SLOT_1);
        assert_eq!(slot_max.slot(), U256::MAX);
    }

    #[test]
    fn test_slot_edge_case_zero() {
        // Explicit test for U256::ZERO slot
        let slot = Slot::<U256>::new(TEST_SLOT_0);
        assert_eq!(slot.slot(), U256::ZERO);

        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);
        let value = U256::random();

        _ = slot.write(&mut contract, value);
        let loaded = slot.read(&mut contract).unwrap();
        assert_eq!(loaded, value);
    }

    #[test]
    fn test_slot_edge_case_max() {
        // Explicit test for U256::MAX slot
        let slot = Slot::<U256>::new(TEST_SLOT_MAX);
        assert_eq!(slot.slot(), U256::MAX);

        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);

        let value = U256::random();
        _ = slot.write(&mut contract, value);
        let loaded = slot.read(&mut contract).unwrap();
        assert_eq!(loaded, value);
    }

    #[test]
    fn test_slot_read_write_u256() {
        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);
        let slot = Slot::<U256>::new(TEST_SLOT_1);
        let test_value = U256::random();

        // Write using new API
        _ = slot.write(&mut contract, test_value);

        // Read using new API
        let loaded = slot.read(&mut contract).unwrap();
        assert_eq!(loaded, test_value);

        // Verify it actually wrote to slot 1
        let raw = contract.storage.sload(contract.address, TEST_SLOT_1);
        assert_eq!(raw, Ok(test_value));
    }

    #[test]
    fn test_slot_read_write_address() {
        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);
        let test_addr = Address::random();
        let slot = Slot::<Address>::new(TEST_SLOT_1);

        // Write
        _ = slot.write(&mut contract, test_addr);

        // Read
        let loaded = slot.read(&mut contract).unwrap();
        assert_eq!(loaded, test_addr);
    }

    #[test]
    fn test_slot_read_write_bool() {
        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);
        let slot = Slot::<bool>::new(TEST_SLOT_1);

        // Write true
        _ = slot.write(&mut contract, true);
        assert!(slot.read(&mut contract).unwrap());

        // Write false
        _ = slot.write(&mut contract, false);
        assert!(!slot.read(&mut contract).unwrap());
    }

    #[test]
    fn test_slot_read_write_string() {
        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);
        let slot = Slot::<String>::new(TEST_SLOT_1);

        let test_name = "TestToken";
        _ = slot.write(&mut contract, test_name.to_string());

        let loaded = slot.read(&mut contract).unwrap();
        assert_eq!(loaded, test_name);
    }

    #[test]
    fn test_slot_default_value_is_zero() {
        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);
        let slot = Slot::<U256>::new(TEST_SLOT_1);

        // Reading uninitialized storage should return zero
        let value = slot.read(&mut contract).unwrap();
        assert_eq!(value, U256::ZERO);
    }

    #[test]
    fn test_slot_overwrite() {
        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);
        let slot = Slot::<u64>::new(TEST_SLOT_1);

        // Write initial value
        _ = slot.write(&mut contract, 100);
        assert_eq!(slot.read(&mut contract), Ok(100));

        // Overwrite with new value
        _ = slot.write(&mut contract, 200);
        assert_eq!(slot.read(&mut contract), Ok(200));
    }

    proptest! {
        #![proptest_config(ProptestConfig::with_cases(500))]

        #[test]
        fn proptest_slot_read_write_u256(value in arb_u256()) {
            let mut storage = HashMapStorageProvider::new(1);
            let mut contract = setup_test_contract(&mut storage);
            let slot = Slot::<U256>::new(TEST_SLOT_2);

            // Write and read back
            slot.write(&mut contract, value)?;
            let loaded = slot.read(&mut contract)?;
            prop_assert_eq!(loaded, value, "roundtrip failed");

            // Delete and verify
            slot.delete(&mut contract)?;
            let after_delete = slot.read(&mut contract)?;
            prop_assert_eq!(after_delete, U256::ZERO, "not zero after delete");
        }

        #[test]
        fn proptest_slot_read_write_address(addr_value in arb_address()) {
            let mut storage = HashMapStorageProvider::new(1);
            let mut contract = setup_test_contract(&mut storage);
            let slot = Slot::<Address>::new(TEST_SLOT_1);

            // Write and read back
            slot.write(&mut contract, addr_value)?;
            let loaded = slot.read(&mut contract)?;
            prop_assert_eq!(loaded, addr_value, "address roundtrip failed");
        }

        #[test]
        fn proptest_slot_isolation(value1 in arb_u256(), value2 in arb_u256()) {
            let mut storage = HashMapStorageProvider::new(1);
            let mut contract = setup_test_contract(&mut storage);
            let slot1 = Slot::<U256>::new(TEST_SLOT_1);
            let slot2 = Slot::<U256>::new(TEST_SLOT_2);

            slot1.write(&mut contract, value1)?;
            slot2.write(&mut contract, value2)?;

            // Verify both slots retain their independent values
            let loaded1 = slot1.read(&mut contract)?;
            let loaded2 = slot2.read(&mut contract)?;

            prop_assert_eq!(loaded1, value1, "slot 1 value changed");
            prop_assert_eq!(loaded2, value2, "slot 2 value changed");

            // Delete slot 1, verify slot 2 unaffected
            slot1.delete(&mut contract)?;
            let after_delete1 = slot1.read(&mut contract)?;
            let after_delete2 = slot2.read(&mut contract)?;

            prop_assert_eq!(after_delete1, U256::ZERO, "slot 1 not deleted");
            prop_assert_eq!(after_delete2, value2, "slot 2 affected by slot 1 delete");
        }
    }

    // -- RUNTIME SLOT OFFSET TESTS --------------------------------------------

    #[test]
    fn test_slot_at_offset() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);

        let pair_key: B256 = U256::from(0xabcd).into();
        let orderbook_base_slot = mapping_slot(pair_key, U256::ZERO);

        let base_address = Address::random();

        // Write to orderbook.base using runtime offset
        let slot = Slot::<Address>::new_at_offset(orderbook_base_slot, 0);
        slot.write(&mut contract, base_address)?;

        // Read back
        let read_address = slot.read(&mut contract)?;

        assert_eq!(read_address, base_address);

        // Delete
        slot.delete(&mut contract)?;

        let deleted = slot.read(&mut contract)?;

        assert_eq!(deleted, Address::ZERO);

        Ok(())
    }

    #[test]
    fn test_slot_at_offset_multi_slot_value() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);

        let struct_key: B256 = U256::from(0xabcd).into();
        let struct_base = mapping_slot(struct_key, U256::ZERO);

        // Test writing a multi-slot value like a String at offset 2
        let test_string = "Hello, Orderbook!".to_string();

        let slot = Slot::<String>::new_at_offset(struct_base, 2);
        slot.write(&mut contract, test_string.clone())?;

        let read_string = slot.read(&mut contract)?;

        assert_eq!(read_string, test_string);

        Ok(())
    }

    #[test]
    fn test_multiple_primitive_fields() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);

        let key: B256 = U256::from(0x9999).into();
        let base = mapping_slot(key, U256::ZERO);

        // Simulate different primitive fields at different offsets
        let field_0 = Address::random();
        let field_1: u64 = 12345;
        let field_2 = U256::from(999999);

        Slot::<Address>::new_at_offset(base, 0).write(&mut contract, field_0)?;
        Slot::<u64>::new_at_offset(base, 1).write(&mut contract, field_1)?;
        Slot::<U256>::new_at_offset(base, 2).write(&mut contract, field_2)?;

        // Verify independence
        let read_0 = Slot::<Address>::new_at_offset(base, 0).read(&mut contract)?;
        let read_1 = Slot::<u64>::new_at_offset(base, 1).read(&mut contract)?;
        let read_2 = Slot::<U256>::new_at_offset(base, 2).read(&mut contract)?;

        assert_eq!(read_0, field_0);
        assert_eq!(read_1, field_1);
        assert_eq!(read_2, field_2);

        Ok(())
    }
}
