//! Type-safe wrapper for EVM storage mappings (hash-based key-value storage).

use alloy::primitives::{Address, U256};
use std::marker::PhantomData;

use crate::storage::{Layout, LayoutCtx, Storable, StorableType, StorageKey};

/// Type-safe access wrapper for EVM storage mappings (hash-based key-value storage).
///
/// This struct does not store data itself. Instead, it provides a zero-cost abstraction
/// for accessing mapping storage slots using Solidity's hash-based layout. It wraps a
/// base slot number and provides methods to compute the actual storage slots for keys.
///
/// # Type Parameters
///
/// - `K`: Key type (must implement `StorageKey`)
/// - `V`: Value type (must implement `StorableType`)
///
/// `Mapping<K, V>` is essentially a slot computation helper. The `.at(key)` method
/// performs the keccak256 hash to compute the actual storage slot and returns a
/// `Handler` that can be used for read/write operations.
///
/// # Storage Layout
///
/// Mappings use Solidity's storage layout:
/// - Base slot: stored in `base_slot` field (never accessed directly)
/// - Actual slot for key `k`: `keccak256(k || base_slot)`
///
/// # Usage Pattern
///
/// The typical usage follows a composable pattern:
/// 1. Create a `Mapping<K, V>` with a base slot (usually from generated constants)
/// 2. Call `.at(key)` to compute and obtain a `Handler` for that key
/// 3. Use `.read()`, `.write()`, or `.delete()` on the resulting slot
///
/// # Accessing Mapping Fields Within Structs
///
/// When a mapping is a field within a struct stored in another mapping, use the static
/// `at_offset` method to compute the slot without creating a `Mapping` instance:
#[derive(Debug, Clone)]
pub struct Mapping<K, V> {
    base_slot: U256,
    address: Address,
    _phantom: PhantomData<(K, V)>,
}

impl<K, V> Mapping<K, V> {
    /// Creates a new `Mapping` with the given base slot number and address.
    ///
    /// This is typically called with slot constants generated by the `#[contract]` macro.
    #[inline]
    pub fn new(base_slot: U256, address: Address) -> Self {
        Self {
            base_slot,
            address,
            _phantom: PhantomData,
        }
    }

    /// Returns the U256 base storage slot number for this mapping.
    #[inline]
    pub const fn slot(&self) -> U256 {
        self.base_slot
    }

    /// Returns a `Handler` for the given key.
    ///
    /// This enables the composable pattern: `mapping.at(key).read()`
    /// where the mapping slot computation happens once, and the resulting slot
    /// can be used for multiple operations.
    pub fn at(&self, key: K) -> V::Handler
    where
        K: StorageKey,
        V: StorableType + MappingStorable,
    {
        V::handle(
            key.mapping_slot(self.base_slot),
            LayoutCtx::FULL,
            self.address,
        )
    }
}

impl<K, V> Default for Mapping<K, V> {
    fn default() -> Self {
        Self::new(U256::ZERO, Address::ZERO)
    }
}

// Mappings occupy a full 32-byte slot in the layout (used as a base for hashing),
// even though they don't store data in that slot directly.
//
// **NOTE:** Necessary to allow it to participate in struct layout calculations.
impl<K, V> StorableType for Mapping<K, V> {
    const LAYOUT: Layout = Layout::Slots(1);
    type Handler = Self;

    fn handle(slot: U256, _ctx: LayoutCtx, address: Address) -> Self::Handler {
        Self::new(slot, address)
    }
}

// -- USER MAPPING (WITHOUT HASHING) -------------------------------------------

/// Mapping with direct slot computation (no keccak hashing).
///
/// Unlike `Mapping<Address, V>` which uses `keccak256(addr || slot)`,
/// `UserMapping<V>` uses the address value directly: `slot = U256::from(address)`.
/// This enables cheap lookups by address without hash computation.
///
/// # CONSTRAINTS
///
/// Enforced by the type system:
/// - Cannot be nested inside other mappings (`Mapping<K, UserMapping<V>>` is forbidden)
/// - Value type cannot be a mapping (`UserMapping<Mapping<K, V>>` is forbidden)
///
/// Enforced by `#[contract]` macro:
/// - At most one `UserMapping` per contract
#[derive(Debug, Clone)]
pub struct UserMapping<V> {
    address: Address,
    _phantom: PhantomData<V>,
}

impl<V> UserMapping<V> {
    /// Creates a new `UserMapping` with the given contract address.
    #[inline]
    pub fn new(address: Address) -> Self {
        Self {
            address,
            _phantom: PhantomData,
        }
    }

    /// Returns a `Handler` for the given user address.
    ///
    /// The storage slot is directly derived from the user address.
    pub fn at(&self, user: Address) -> V::Handler
    where
        V: StorableType + UserMappingStorable,
    {
        let mut slot = [0u8; 32];
        slot[..20].copy_from_slice(user.as_slice());

        V::handle(U256::from_be_bytes(slot), LayoutCtx::FULL, self.address)
    }
}

impl<V> Default for UserMapping<V> {
    fn default() -> Self {
        Self::new(Address::ZERO)
    }
}

impl<V> StorableType for UserMapping<V> {
    const LAYOUT: Layout = Layout::Slots(1);
    type Handler = Self;

    fn handle(_slot: U256, _ctx: LayoutCtx, address: Address) -> Self::Handler {
        Self::new(address)
    }
}

/// Marker trait for types that can be used as values in `Mapping<K, V>`.
///
/// Implemented for all `Storable` types and `Mapping<K, V>` itself (for nesting).
/// `UserMapping` deliberately does NOT implement this trait, preventing it from
/// being nested inside mappings.
pub trait MappingStorable {}

impl<T: Storable> MappingStorable for T {}
impl<K, V> MappingStorable for Mapping<K, V> {}

/// Marker trait for types that can be used as values in `UserMapping<V>`.
///
/// Only `Storable` types (primitives, structs) implement this trait.
/// `Mapping` and `UserMapping` do NOT implement this trait, preventing
/// any mapping types from being nested inside `UserMapping`.
pub trait UserMappingStorable {}

impl<T: Storable> UserMappingStorable for T {}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::storage::StorageKey;
    use alloy::primitives::{Address, B256, keccak256};

    // Backward compatibility helper to verify the trait impl.
    fn old_mapping_slot<K: AsRef<[u8]>>(key: K, slot: U256) -> U256 {
        let key = key.as_ref();
        let mut buf = [0u8; 64];
        buf[32 - key.len()..32].copy_from_slice(key);
        buf[32..].copy_from_slice(&slot.to_be_bytes::<32>());
        U256::from_be_bytes(keccak256(buf).0)
    }

    #[test]
    fn test_mapping_slot_encoding() {
        let key = Address::random();
        let base_slot = U256::random();

        // Manual computation to validate
        let mut buf = [0u8; 64];
        // Left-pad the address to 32 bytes
        buf[12..32].copy_from_slice(key.as_ref());
        // Slot in big-endian
        buf[32..].copy_from_slice(&base_slot.to_be_bytes::<32>());

        let expected = U256::from_be_bytes(keccak256(buf).0);
        let computed = key.mapping_slot(base_slot);

        assert_eq!(computed, expected, "mapping_slot encoding mismatch");
    }

    #[test]
    fn test_mapping_slot_matches_old_impl() {
        let slot = U256::random();

        let addr = Address::random();
        assert_eq!(
            addr.mapping_slot(slot),
            old_mapping_slot(addr.as_slice(), slot),
        );

        let b256 = B256::random();
        assert_eq!(
            b256.mapping_slot(slot),
            old_mapping_slot(b256.as_slice(), slot),
        );

        let u256 = U256::random();
        assert_eq!(
            u256.mapping_slot(slot),
            old_mapping_slot(u256.to_be_bytes::<32>(), slot),
        );
    }

    #[test]
    fn test_mapping_size() {
        assert_eq!(std::mem::size_of::<Address>(), 20);
        // Mapping contains: U256 (32) + Address (20 + 4 for 8-byte alignment) + PhantomData (0) = 56 bytes
        assert_eq!(std::mem::size_of::<Mapping<Address, U256>>(), 56);
        assert_eq!(std::mem::size_of::<Mapping<U256, Address>>(), 56);
        // Nested mappings are just Mapping<K, Mapping<K2, V>>, same size
        assert_eq!(
            std::mem::size_of::<Mapping<Address, Mapping<Address, U256>>>(),
            56
        );
    }

    #[test]
    fn test_mapping_basic_properties() {
        let address = Address::random();
        let base_slot = U256::random();
        let mapping = Mapping::<Address, U256>::new(base_slot, address);

        // Property 1: Determinism - same key always produces same slot
        let key = Address::random();
        let slot1 = mapping.at(key);
        let slot2 = mapping.at(key);
        assert_eq!(
            slot1.slot(),
            slot2.slot(),
            "same key should produce same slot"
        );

        // Property 2: Different keys produce different slots
        let key1 = Address::random();
        let key2 = Address::random();
        let slot_a = mapping.at(key1);
        let slot_b = mapping.at(key2);
        assert_ne!(
            slot_a.slot(),
            slot_b.slot(),
            "different keys should produce different slots"
        );

        // Property 3: Derived slot matches manual computation
        let test_key = Address::random();
        let derived_slot = mapping.at(test_key);
        let expected_slot = test_key.mapping_slot(base_slot);
        assert_eq!(
            derived_slot.slot(),
            expected_slot,
            ".at() should derive correct slot"
        );
    }

    #[test]
    fn test_nested_mapping_basic_properties() {
        let address = Address::random();
        let base_slot = U256::random();
        // Nested mappings use recursive Mapping<K, Mapping<K2, V>> type
        let nested = Mapping::<Address, Mapping<B256, U256>>::new(base_slot, address);

        let key1 = Address::random();
        let key2 = B256::random();

        // Property 1: Chaining - first .at() returns intermediate Mapping with correct slot
        let intermediate = nested.at(key1);
        let expected_intermediate_slot = key1.mapping_slot(base_slot);
        assert_eq!(
            intermediate.slot(),
            expected_intermediate_slot,
            "intermediate mapping should have correct slot"
        );

        // Property 2: Double-hash - second .at() returns final Slot with correct double-derived slot
        let final_slot = intermediate.at(key2);
        let expected_final_slot = key2.mapping_slot(expected_intermediate_slot);
        assert_eq!(
            final_slot.slot(),
            expected_final_slot,
            "final slot should use double-hash"
        );

        // Property 3: Determinism - same keys always produce same slot
        let slot_a = nested.at(key1).at(key2);
        let slot_b = nested.at(key1).at(key2);
        assert_eq!(
            slot_a.slot(),
            slot_b.slot(),
            "same keys should produce same slot"
        );

        // Property 4: Different first-level keys produce different final slots
        let different_key1 = Address::random();
        let different_slot = nested.at(different_key1).at(key2);
        assert_ne!(
            final_slot.slot(),
            different_slot.slot(),
            "different first-level keys should produce different slots"
        );

        // Property 5: Different second-level keys produce different final slots
        let different_key2 = B256::random();
        let another_slot = nested.at(key1).at(different_key2);
        assert_ne!(
            final_slot.slot(),
            another_slot.slot(),
            "different second-level keys should produce different slots"
        );
    }

    #[test]
    fn test_mapping_slot_boundaries() {
        let address = Address::random();

        // Test .slot() getter with ZERO boundary
        let zero_mapping = Mapping::<Address, U256>::new(U256::ZERO, address);
        assert_eq!(zero_mapping.slot(), U256::ZERO);
        let user = Address::random();
        let slot = zero_mapping.at(user);
        assert_eq!(slot.slot(), user.mapping_slot(U256::ZERO));

        // Test .slot() getter with MAX boundary
        let max_mapping = Mapping::<Address, U256>::new(U256::MAX, address);
        assert_eq!(max_mapping.slot(), U256::MAX);
        let user2 = Address::random();
        let slot2 = max_mapping.at(user2);
        assert_eq!(slot2.slot(), user2.mapping_slot(U256::MAX));

        // Test .slot() getter with arbitrary values
        let random_slot = U256::random();
        let arbitrary_mapping = Mapping::<Address, U256>::new(random_slot, address);
        assert_eq!(arbitrary_mapping.slot(), random_slot);
    }

    #[test]
    fn test_nested_mapping_at_offset() {
        // Simulate a struct with nested mapping at field offset 3
        let struct_key = B256::random();
        let mapping_base_slot = U256::random();
        let struct_base_slot = struct_key.mapping_slot(mapping_base_slot);

        let owner = Address::random();
        let spender = Address::random();

        // Nested mappings use recursive `Mapping<K, Mapping<K2, V>>` type
        let field_slot = struct_base_slot + U256::from(3); // nested mapping at field offset 3
        let nested_mapping =
            Mapping::<Address, Mapping<Address, U256>>::new(field_slot, Address::random());

        // Verify double-hash computation is correct
        let final_slot = nested_mapping.at(owner).at(spender);

        // Expected: keccak256(spender || keccak256(owner || field_slot))
        let intermediate_slot = owner.mapping_slot(field_slot);
        let expected_slot = spender.mapping_slot(intermediate_slot);
        assert_eq!(final_slot.slot(), expected_slot);
    }

    // --- USER MAPPING TESTS --------------------------------------------------

    #[test]
    fn test_user_mapping_slot_is_direct() {
        let user = Address::random();
        let contract_addr = Address::random();
        let mapping = UserMapping::<U256>::new(contract_addr);

        let handler = mapping.at(user);
        let expected_slot = U256::from_be_slice(user.as_slice()) << 96;
        assert_eq!(handler.slot(), expected_slot);
    }

    #[test]
    fn test_user_mapping_different_addresses_different_slots() {
        let contract_addr = Address::random();
        let mapping = UserMapping::<U256>::new(contract_addr);

        let addr1 = Address::random();
        let addr2 = Address::random();

        assert_ne!(mapping.at(addr1).slot(), mapping.at(addr2).slot());
    }

    #[test]
    fn test_user_mapping_deterministic() {
        let contract_addr = Address::random();
        let mapping = UserMapping::<U256>::new(contract_addr);
        let user = Address::random();

        // Same user always gets same slot
        assert_eq!(mapping.at(user).slot(), mapping.at(user).slot());
    }

    #[test]
    fn test_user_mapping_size() {
        // `UserMapping` contains: Address + PhantomData (0) = 20 bytes
        assert_eq!(std::mem::size_of::<UserMapping<U256>>(), 20);
        assert_eq!(std::mem::size_of::<UserMapping<Address>>(), 20);
    }

    #[test]
    fn test_user_mapping_storable_type() {
        // Verify `StorableType` implementation
        assert_eq!(
            <UserMapping<U256> as crate::storage::StorableType>::SLOTS,
            1
        );
        assert_eq!(
            <UserMapping<U256> as crate::storage::StorableType>::LAYOUT,
            crate::storage::Layout::Slots(1)
        );
    }
}
