use alloy::primitives::U256;
use std::marker::PhantomData;

use crate::{
    error::Result,
    storage::{
        Storable, StorageKey, StorageOps,
        slots::{double_mapping_slot, mapping_slot},
        types::slot::SlotId,
    },
};

/// Type-safe wrapper for EVM storage mappings (hash-based key-value storage).
///
/// # Type Parameters
///
/// - `K`: Key type (must implement `StorageKey`)
/// - `V`: Value type (must implement `Storable<N>`)
/// - `Id`: Zero-sized marker type identifying the base slot (implements `SlotId`)
///
/// # Storage Layout
///
/// Mappings use Solidity's storage layout:
/// - Base slot: `Id::SLOT`
/// - Actual slot for key `k`: `keccak256(k || base_slot)`
///
/// # Compile-Time Guarantees
///
/// - Different mappings have distinct types even with same K,V
/// - Base slot encoded in type system via `Id::SLOT`
///
/// # Example
///
/// ```ignore
/// // Generated by #[contract] macro:
/// pub struct BalancesSlotId;
/// impl SlotId for BalancesSlotId {
///     const SLOT: U256 = uint!(10_U256);
/// }
/// ```
#[derive(Debug, Clone, Copy)]
pub struct Mapping<K, V, Id: SlotId> {
    _phantom: PhantomData<(K, V, Id)>,
}

impl<K, V, Id: SlotId> Mapping<K, V, Id> {
    /// Creates a new `Mapping` marker.
    ///
    /// This is typically not called directly; instead, mappings are declared
    /// as struct fields and accessed via macro-generated methods.
    #[inline]
    pub const fn new() -> Self {
        Self {
            _phantom: PhantomData,
        }
    }

    /// Returns the U256 base storage slot number for this mapping.
    ///
    /// Returns the slot number from the `SlotId` associated const.
    #[inline]
    pub const fn slot() -> U256 {
        Id::SLOT
    }

    /// Reads a value from the mapping at the given key.
    ///
    /// This method:
    /// 1. Computes the storage slot via keccak256(key || base_slot)
    /// 2. Delegates to `Storable::load`, which reads `N` consecutive slots
    ///
    /// # Example
    ///
    /// ```ignore
    /// type NamedMapping = Mapping<Address, U256, BalancesSlotId>;
    /// let name = NamedMapping::read(&mut contract, user_address)?;
    /// ```
    #[inline]
    pub fn read<S: StorageOps, const N: usize>(storage: &mut S, key: K) -> Result<V>
    where
        K: StorageKey,
        V: Storable<N>,
    {
        let slot = mapping_slot(key.as_storage_bytes(), Id::SLOT);
        V::load(storage, slot)
    }

    /// Writes a value to the mapping at the given key.
    ///
    /// This method:
    /// 1. Computes the storage slot via keccak256(key || base_slot)
    /// 2. Delegates to `Storable::store`, which writes to `N` consecutive slots
    ///
    /// # Example
    ///
    /// ```ignore
    /// type NamedMapping = Mapping<Address, U256, BalancesSlotId>;
    /// NamedMapping::write(&mut contract, user_address, U256::from(100))?;
    /// ```
    #[inline]
    pub fn write<S: StorageOps, const N: usize>(storage: &mut S, key: K, value: V) -> Result<()>
    where
        K: StorageKey,
        V: Storable<N>,
    {
        let slot = mapping_slot(key.as_storage_bytes(), Id::SLOT);
        value.store(storage, slot)
    }

    /// Deletes the value from the mapping at the given key (sets all slots to zero).
    ///
    /// This method:
    /// 1. Computes the storage slot via keccak256(key || base_slot)
    /// 2. Delegates to `Storable::delete`, which sets `N` consecutive slots to zero
    ///
    /// # Example
    ///
    /// ```ignore
    /// type NamedMapping = Mapping<Address, U256, BalancesSlotId>;
    /// NamedMapping::delete(&mut contract, user_address)?;
    /// ```
    #[inline]
    pub fn delete<S: StorageOps, const N: usize>(storage: &mut S, key: K) -> Result<()>
    where
        K: StorageKey,
        V: Storable<N>,
    {
        let slot = mapping_slot(key.as_storage_bytes(), Id::SLOT);
        V::delete(storage, slot)
    }
}

impl<K1, K2, V, Id: SlotId, DummyId: SlotId> Mapping<K1, Mapping<K2, V, DummyId>, Id> {
    /// Reads a value from a nested mapping at the given keys.
    ///
    /// This method:
    /// 1. Computes the storage slot using: `keccak256(k2 || keccak256(k1 || base_slot))`
    /// 2. Delegates to `Storable::load`, which may read one or more consecutive slots
    ///
    /// # Example
    ///
    /// ```ignore
    /// type NestedMapping = Mapping<Address, Mapping<Address, U256, DummySlotId>, AllowancesSlotId>;
    /// let nested = NestedMapping::read_nested(
    ///     &mut contract,
    ///     owner_address,
    ///     spender_address
    /// )?;
    /// ```
    #[inline]
    pub fn read_nested<S: StorageOps, const N: usize>(
        storage: &mut S,
        key1: K1,
        key2: K2,
    ) -> Result<V>
    where
        K1: StorageKey,
        K2: StorageKey,
        V: Storable<N>,
    {
        let slot = double_mapping_slot(key1.as_storage_bytes(), key2.as_storage_bytes(), Id::SLOT);
        V::load(storage, slot)
    }

    /// Writes a value to a nested mapping at the given keys.
    ///
    /// This method:
    /// 1. Computes the storage slot using: `keccak256(k2 || keccak256(k1 || base_slot))`
    /// 2. Delegates to `Storable::store`, which may write one or more consecutive slots
    ///
    /// # Example
    ///
    /// ```ignore
    /// type NestedMapping = Mapping<Address, Mapping<Address, U256, DummySlotId>, AllowancesSlotId>;
    /// NestedMapping::write_nested(
    ///     &mut contract,
    ///     owner_address,
    ///     spender_address,
    ///     U256::from(1000)
    /// )?;
    /// ```
    #[inline]
    pub fn write_nested<S: StorageOps, const N: usize>(
        storage: &mut S,
        key1: K1,
        key2: K2,
        value: V,
    ) -> Result<()>
    where
        K1: StorageKey,
        K2: StorageKey,
        V: Storable<N>,
    {
        let slot = double_mapping_slot(key1.as_storage_bytes(), key2.as_storage_bytes(), Id::SLOT);
        value.store(storage, slot)
    }

    /// Deletes a value from a nested mapping at the given keys (sets all slots to zero).
    ///
    /// This method:
    /// 1. Computes the storage slot using: `keccak256(k2 || keccak256(k1 || base_slot))`
    /// 2. Delegates to `Storable::delete`, which sets `N` consecutive slots to zero
    ///
    /// # Example
    ///
    /// ```ignore
    /// type NestedMapping = Mapping<Address, Mapping<Address, U256, DummySlotId>, AllowancesSlotId>;
    /// NestedMapping::delete_nested(
    ///     &mut contract,
    ///     owner_address,
    ///     spender_address
    /// )?;
    /// ```
    #[inline]
    pub fn delete_nested<S: StorageOps, const N: usize>(
        storage: &mut S,
        key1: K1,
        key2: K2,
    ) -> Result<()>
    where
        K1: StorageKey,
        K2: StorageKey,
        V: Storable<N>,
    {
        let slot = double_mapping_slot(key1.as_storage_bytes(), key2.as_storage_bytes(), Id::SLOT);
        V::delete(storage, slot)
    }
}

impl<K, V, Id: SlotId> Default for Mapping<K, V, Id> {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::storage::{PrecompileStorageProvider, hashmap::HashMapStorageProvider};
    use alloy::primitives::Address;
    use proptest::prelude::*;

    // Test helper that implements StorageOps
    struct TestContract<'a, S> {
        address: Address,
        storage: &'a mut S,
    }

    impl<'a, S: PrecompileStorageProvider> StorageOps for TestContract<'a, S> {
        fn sstore(&mut self, slot: U256, value: U256) -> Result<()> {
            self.storage.sstore(self.address, slot, value)
        }

        fn sload(&mut self, slot: U256) -> Result<U256> {
            self.storage.sload(self.address, slot)
        }
    }

    /// Helper to create a test contract with fresh storage.
    fn setup_test_contract<'a>(
        storage: &'a mut HashMapStorageProvider,
    ) -> TestContract<'a, HashMapStorageProvider> {
        TestContract {
            address: Address::random(),
            storage,
        }
    }

    // Test SlotId implementations
    struct TestSlot0;
    impl SlotId for TestSlot0 {
        const SLOT: U256 = U256::ZERO;
    }

    struct TestSlot1;
    impl SlotId for TestSlot1 {
        const SLOT: U256 = U256::from_limbs([1, 0, 0, 0]);
    }

    struct TestSlot2;
    impl SlotId for TestSlot2 {
        const SLOT: U256 = U256::from_limbs([2, 0, 0, 0]);
    }

    struct TestSlotMax;
    impl SlotId for TestSlotMax {
        const SLOT: U256 = U256::MAX;
    }

    struct DummySlotId;
    impl SlotId for DummySlotId {
        const SLOT: U256 = U256::ZERO;
    }

    // Property test strategies
    fn arb_address() -> impl Strategy<Value = Address> {
        any::<[u8; 20]>().prop_map(Address::from)
    }

    fn arb_u256() -> impl Strategy<Value = U256> {
        any::<[u64; 4]>().prop_map(U256::from_limbs)
    }

    #[test]
    fn test_mapping_is_zero_sized() {
        assert_eq!(std::mem::size_of::<Mapping<Address, U256, TestSlot1>>(), 0);
        assert_eq!(std::mem::size_of::<Mapping<U256, Address, TestSlot2>>(), 0);
        // Nested mapping
        type NestedMapping = Mapping<Address, Mapping<Address, U256, DummySlotId>, TestSlotMax>;
        assert_eq!(std::mem::size_of::<NestedMapping>(), 0);
    }

    #[test]
    fn test_mapping_creation() {
        let _simple: Mapping<Address, U256, TestSlot1> = Mapping::new();
        let _another: Mapping<U256, bool, TestSlot2> = Mapping::default();
    }

    #[test]
    fn test_mapping_slot_extraction() {
        assert_eq!(Mapping::<Address, U256, TestSlot1>::slot(), U256::from(1));
        assert_eq!(Mapping::<U256, Address, TestSlot2>::slot(), U256::from(2));

        // Test with larger slot number
        assert_eq!(Mapping::<Address, U256, TestSlotMax>::slot(), U256::MAX);
    }

    #[test]
    fn test_mapping_edge_case_zero() {
        // Explicit test for U256::ZERO base slot
        assert_eq!(Mapping::<Address, U256, TestSlot0>::slot(), U256::ZERO);

        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);
        let user = Address::random();

        type ZeroMapping = Mapping<Address, U256, TestSlot0>;
        let value = U256::from(1000u64);

        _ = ZeroMapping::write(&mut contract, user, value);
        let loaded = ZeroMapping::read(&mut contract, user).unwrap();
        assert_eq!(loaded, value);
    }

    #[test]
    fn test_mapping_edge_case_max() {
        // Explicit test for U256::MAX base slot
        type MaxMapping = Mapping<Address, U256, TestSlotMax>;
        assert_eq!(MaxMapping::slot(), U256::MAX);

        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);
        let user = Address::random();

        let value = U256::from(999u64);
        _ = MaxMapping::write(&mut contract, user, value);
        let loaded = MaxMapping::read(&mut contract, user).unwrap();
        assert_eq!(loaded, value);
    }

    #[test]
    fn test_mapping_read_write_balances() {
        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);
        let user1 = Address::random();
        let user2 = Address::random();

        type NamedMapping = Mapping<Address, U256, TestSlot1>;

        let balance1 = U256::from(1000u64);
        let balance2 = U256::from(2000u64);

        // Write balances
        _ = NamedMapping::write(&mut contract, user1, balance1);
        _ = NamedMapping::write(&mut contract, user2, balance2);

        // Read balances
        let loaded1 = NamedMapping::read(&mut contract, user1).unwrap();
        let loaded2 = NamedMapping::read(&mut contract, user2).unwrap();

        assert_eq!(loaded1, balance1);
        assert_eq!(loaded2, balance2);
    }

    #[test]
    fn test_mapping_read_default_is_zero() {
        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);
        let user = Address::random();

        type NamedMapping = Mapping<Address, U256, TestSlot1>;

        // Reading uninitialized mapping slot should return zero
        let balance = NamedMapping::read(&mut contract, user).unwrap();
        assert_eq!(balance, U256::ZERO);
    }

    #[test]
    fn test_mapping_overwrite() {
        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);
        let user = Address::random();

        type NamedMapping = Mapping<Address, U256, TestSlot1>;

        // Write initial balance
        _ = NamedMapping::write(&mut contract, user, U256::from(100));
        assert_eq!(NamedMapping::read(&mut contract, user), Ok(U256::from(100)));

        // Overwrite with new balance
        _ = NamedMapping::write(&mut contract, user, U256::from(200));
        assert_eq!(NamedMapping::read(&mut contract, user), Ok(U256::from(200)));
    }

    #[test]
    fn test_nested_mapping_read_write_allowances() {
        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);
        let owner = Address::random();
        let spender1 = Address::random();
        let spender2 = Address::random();

        // Nested mapping: outer slot is 11, inner slot is dummy (unused)
        type NestedMapping = Mapping<Address, Mapping<Address, U256, DummySlotId>, TestSlot2>;

        let allowance1 = U256::from(500u64);
        let allowance2 = U256::from(1500u64);

        // Write allowances using nested API
        _ = NestedMapping::write_nested(&mut contract, owner, spender1, allowance1);
        _ = NestedMapping::write_nested(&mut contract, owner, spender2, allowance2);

        // Read allowances using nested API
        let loaded1 = NestedMapping::read_nested(&mut contract, owner, spender1).unwrap();
        let loaded2 = NestedMapping::read_nested(&mut contract, owner, spender2).unwrap();

        assert_eq!(loaded1, allowance1);
        assert_eq!(loaded2, allowance2);
    }

    #[test]
    fn test_nested_mapping_default_is_zero() {
        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);
        let owner = Address::random();
        let spender = Address::random();

        type NestedMapping = Mapping<Address, Mapping<Address, U256, DummySlotId>, TestSlot1>;

        // Reading uninitialized nested mapping should return zero
        let allowance = NestedMapping::read_nested(&mut contract, owner, spender).unwrap();
        assert_eq!(allowance, U256::ZERO);
    }

    #[test]
    fn test_nested_mapping_independence() {
        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);
        let owner1 = Address::random();
        let owner2 = Address::random();
        let spender = Address::random();

        type NestedMapping = Mapping<Address, Mapping<Address, U256, DummySlotId>, TestSlot2>;

        // Set allowance for owner1 -> spender
        _ = NestedMapping::write_nested(&mut contract, owner1, spender, U256::from(100));

        // Verify owner2 -> spender is still zero (independent slot)
        let allowance2 = NestedMapping::read_nested(&mut contract, owner2, spender).unwrap();
        assert_eq!(allowance2, U256::ZERO);

        // Verify owner1 -> spender is unchanged
        let allowance1 = NestedMapping::read_nested(&mut contract, owner1, spender).unwrap();
        assert_eq!(allowance1, U256::from(100));
    }

    #[test]
    fn test_mapping_with_different_key_types() {
        let mut storage = HashMapStorageProvider::new(1);
        let mut contract = setup_test_contract(&mut storage);

        // Mapping with U256 key
        type NoncesMapping = Mapping<Address, U256, TestSlot2>;
        let user = Address::random();
        let nonce = U256::from(42);

        _ = NoncesMapping::write(&mut contract, user, nonce);
        let loaded_nonce = NoncesMapping::read(&mut contract, user).unwrap();
        assert_eq!(loaded_nonce, nonce);

        // Mapping with bool value
        type FlagsMapping = Mapping<Address, bool, TestSlotMax>;
        _ = FlagsMapping::write(&mut contract, user, true);
        let loaded_flag = FlagsMapping::read(&mut contract, user).unwrap();
        assert!(loaded_flag);
    }

    proptest! {
        #![proptest_config(ProptestConfig::with_cases(500))]

        #[test]
        fn proptest_mapping_read_write(
            key in arb_address(),
            value in arb_u256()
        ) {
            let mut storage = HashMapStorageProvider::new(1);
            let mut contract = setup_test_contract(&mut storage);

            // Test with TestSlot10
            type TestMapping = Mapping<Address, U256, TestSlot0>;

            // Write and read back
            TestMapping::write(&mut contract, key, value)?;
            let loaded = TestMapping::read(&mut contract, key)?;
            prop_assert_eq!(loaded, value, "roundtrip failed");

            // Delete and verify
            TestMapping::delete(&mut contract, key)?;
            let after_delete = TestMapping::read(&mut contract, key)?;
            prop_assert_eq!(after_delete, U256::ZERO, "not zero after delete");
        }

        #[test]
        fn proptest_mapping_key_isolation(
            key1 in arb_address(),
            key2 in arb_address(),
            value1 in arb_u256(),
            value2 in arb_u256()
        ) {
            // Skip if keys are the same
            prop_assume!(key1 != key2);

            let mut storage = HashMapStorageProvider::new(1);
            let mut contract = setup_test_contract(&mut storage);

            type TestMapping = Mapping<Address, U256, TestSlot0>;

            // Write different values to different keys
            TestMapping::write(&mut contract, key1, value1)?;
            TestMapping::write(&mut contract, key2, value2)?;

            // Verify both keys retain their independent values
            let loaded1 = TestMapping::read(&mut contract, key1)?;
            let loaded2 = TestMapping::read(&mut contract, key2)?;

            prop_assert_eq!(loaded1, value1, "key1 value changed");
            prop_assert_eq!(loaded2, value2, "key2 value changed");

            // Delete key1, verify key2 unaffected
            TestMapping::delete(&mut contract, key1)?;
            let after_delete1 = TestMapping::read(&mut contract, key1)?;
            let after_delete2 = TestMapping::read(&mut contract, key2)?;

            prop_assert_eq!(after_delete1, U256::ZERO, "key1 not deleted");
            prop_assert_eq!(after_delete2, value2, "key2 affected by key1 delete");
        }

        #[test]
        fn proptest_nested_mapping_isolation(
            owner1 in arb_address(),
            owner2 in arb_address(),
            spender in arb_address(),
            allowance1 in arb_u256(),
            allowance2 in arb_u256()
        ) {
            // Skip if owners are the same
            prop_assume!(owner1 != owner2);

            let mut storage = HashMapStorageProvider::new(1);
            let mut contract = setup_test_contract(&mut storage);

            type NestedMapping =
                Mapping<Address, Mapping<Address, U256, DummySlotId>, TestSlot1>;

            // Write different allowances for different owners
            NestedMapping::write_nested(&mut contract, owner1, spender, allowance1)?;
            NestedMapping::write_nested(&mut contract, owner2, spender, allowance2)?;

            // Verify both owners' allowances are independent
            let loaded1 = NestedMapping::read_nested(&mut contract, owner1, spender)?;
            let loaded2 = NestedMapping::read_nested(&mut contract, owner2, spender)?;

            prop_assert_eq!(loaded1, allowance1, "owner1 allowance changed");
            prop_assert_eq!(loaded2, allowance2, "owner2 allowance changed");

            // Delete owner1's allowance, verify owner2 unaffected
            NestedMapping::delete_nested(&mut contract, owner1, spender)?;
            let after_delete1 = NestedMapping::read_nested(&mut contract, owner1, spender)?;
            let after_delete2 = NestedMapping::read_nested(&mut contract, owner2, spender)?;

            prop_assert_eq!(after_delete1, U256::ZERO, "owner1 allowance not deleted");
            prop_assert_eq!(after_delete2, allowance2, "owner2 allowance affected");
        }
    }
}
