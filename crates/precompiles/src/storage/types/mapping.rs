//! Type-safe wrapper for EVM storage mappings (hash-based key-value storage).

use alloy::primitives::{Address, U256};
use std::{marker::PhantomData, rc::Rc};

use crate::storage::{Layout, LayoutCtx, StorableType, StorageKey};

/// Type-safe access wrapper for EVM storage mappings (hash-based key-value storage).
///
/// This struct does not store data itself. Instead, it provides a zero-cost abstraction
/// for accessing mapping storage slots using Solidity's hash-based layout. It wraps a
/// base slot number and provides methods to compute the actual storage slots for keys.
///
/// # Type Parameters
///
/// - `K`: Key type (must implement `StorageKey`)
/// - `V`: Value type (must implement `StorableType`)
///
/// `Mapping<K, V>` is essentially a slot computation helper. The `.at(key)` method
/// performs the keccak256 hash to compute the actual storage slot and returns a
/// `Handler` that can be used for read/write operations.
///
/// # Storage Layout
///
/// Mappings use Solidity's storage layout:
/// - Base slot: stored in `base_slot` field (never accessed directly)
/// - Actual slot for key `k`: `keccak256(k || base_slot)`
///
/// # Usage Pattern
///
/// The typical usage follows a composable pattern:
/// 1. Create a `Mapping<K, V>` with a base slot (usually from generated constants)
/// 2. Call `.at(key)` to compute and obtain a `Handler` for that key
/// 3. Use `.read()`, `.write()`, or `.delete()` on the resulting slot
///
/// # Accessing Mapping Fields Within Structs
///
/// When a mapping is a field within a struct stored in another mapping, use the static
/// `at_offset` method to compute the slot without creating a `Mapping` instance:
#[derive(Debug, Clone)]
pub struct Mapping<K, V> {
    base_slot: U256,
    address: Rc<Address>,
    _phantom: PhantomData<(K, V)>,
}

impl<K, V> Mapping<K, V> {
    /// Creates a new `Mapping` with the given base slot number and address.
    ///
    /// This is typically called with slot constants generated by the `#[contract]` macro.
    #[inline]
    pub fn new(base_slot: U256, address: Rc<Address>) -> Self {
        Self {
            base_slot,
            address,
            _phantom: PhantomData,
        }
    }

    /// Returns the U256 base storage slot number for this mapping.
    #[inline]
    pub const fn slot(&self) -> U256 {
        self.base_slot
    }

    /// Returns a `Handler` for the given key.
    ///
    /// This enables the composable pattern: `mapping.at(key).read()`
    /// where the mapping slot computation happens once, and the resulting slot
    /// can be used for multiple operations.
    pub fn at(&self, key: K) -> V::Handler
    where
        K: StorageKey,
        V: StorableType,
    {
        V::handle(
            key.mapping_slot(self.base_slot),
            LayoutCtx::FULL,
            Rc::clone(&self.address),
        )
    }

    /// Returns a `Handler` for a mapping field within a struct at a given base slot.
    ///
    /// This method enables accessing mapping fields within structs when you have
    /// the struct's base slot at runtime and know the field's offset.
    #[inline]
    pub fn at_offset(
        struct_base_slot: U256,
        field_offset_slots: usize,
        address: Rc<Address>,
        key: K,
    ) -> V::Handler
    where
        K: StorageKey,
        V: StorableType,
    {
        let field_slot = struct_base_slot + U256::from(field_offset_slots);
        V::handle(key.mapping_slot(field_slot), LayoutCtx::FULL, address)
    }
}

impl<K, V> Default for Mapping<K, V> {
    fn default() -> Self {
        Self::new(U256::ZERO, Rc::new(Address::ZERO))
    }
}

// Mappings occupy a full 32-byte slot in the layout (used as a base for hashing),
// even though they don't store data in that slot directly.
//
// **NOTE:** Necessary to allow it to participate in struct layout calculations.
impl<K, V> StorableType for Mapping<K, V> {
    const LAYOUT: Layout = Layout::Slots(1);
    type Handler = Self;

    fn handle(slot: U256, _ctx: LayoutCtx, address: Rc<Address>) -> Self::Handler {
        Self::new(slot, address)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::storage::StorageKey;
    use alloy::primitives::{Address, B256, keccak256};
    use std::rc::Rc;

    // Backward compatibility helper to verify the trait impl.
    fn old_mapping_slot<K: AsRef<[u8]>>(key: K, slot: U256) -> U256 {
        let key = key.as_ref();
        let mut buf = [0u8; 64];
        buf[32 - key.len()..32].copy_from_slice(key);
        buf[32..].copy_from_slice(&slot.to_be_bytes::<32>());
        U256::from_be_bytes(keccak256(&buf).0)
    }

    #[test]
    fn test_mapping_slot_encoding() {
        let key = Address::random();
        let base_slot = U256::random();

        // Manual computation to validate
        let mut buf = [0u8; 64];
        // Left-pad the address to 32 bytes
        buf[12..32].copy_from_slice(key.as_ref());
        // Slot in big-endian
        buf[32..].copy_from_slice(&base_slot.to_be_bytes::<32>());

        let expected = U256::from_be_bytes(keccak256(buf).0);
        let computed = key.mapping_slot(base_slot);

        assert_eq!(computed, expected, "mapping_slot encoding mismatch");
    }

    #[test]
    fn test_mapping_slot_matches_old_impl() {
        let slot = U256::random();

        let addr = Address::random();
        assert_eq!(
            addr.mapping_slot(slot),
            old_mapping_slot(addr.as_slice(), slot),
        );

        let b256 = B256::random();
        assert_eq!(
            b256.mapping_slot(slot),
            old_mapping_slot(b256.as_slice(), slot),
        );

        let u256 = U256::random();
        assert_eq!(
            u256.mapping_slot(slot),
            old_mapping_slot(&u256.to_be_bytes::<32>(), slot),
        );
    }

    #[test]
    fn test_mapping_size() {
        // Mapping contains: U256 base_slot (32 bytes) + Rc<Address> (8 bytes) + PhantomData (0 bytes) = 40 bytes
        assert_eq!(std::mem::size_of::<Mapping<Address, U256>>(), 40);
        assert_eq!(std::mem::size_of::<Mapping<U256, Address>>(), 40);
        // Nested mappings are just Mapping<K, Mapping<K2, V>>, same size
        assert_eq!(
            std::mem::size_of::<Mapping<Address, Mapping<Address, U256>>>(),
            40
        );
    }

    #[test]
    fn test_mapping_basic_properties() {
        let address = Rc::new(Address::random());
        let base_slot = U256::random();
        let mapping = Mapping::<Address, U256>::new(base_slot, Rc::clone(&address));

        // Property 1: Determinism - same key always produces same slot
        let key = Address::random();
        let slot1 = mapping.at(key);
        let slot2 = mapping.at(key);
        assert_eq!(
            slot1.slot(),
            slot2.slot(),
            "same key should produce same slot"
        );

        // Property 2: Different keys produce different slots
        let key1 = Address::random();
        let key2 = Address::random();
        let slot_a = mapping.at(key1);
        let slot_b = mapping.at(key2);
        assert_ne!(
            slot_a.slot(),
            slot_b.slot(),
            "different keys should produce different slots"
        );

        // Property 3: Derived slot matches manual computation
        let test_key = Address::random();
        let derived_slot = mapping.at(test_key);
        let expected_slot = test_key.mapping_slot(base_slot);
        assert_eq!(
            derived_slot.slot(),
            expected_slot,
            ".at() should derive correct slot"
        );
    }

    #[test]
    fn test_nested_mapping_basic_properties() {
        let address = Rc::new(Address::random());
        let base_slot = U256::random();
        // Nested mappings use recursive Mapping<K, Mapping<K2, V>> type
        let nested = Mapping::<Address, Mapping<B256, U256>>::new(base_slot, Rc::clone(&address));

        let key1 = Address::random();
        let key2 = B256::random();

        // Property 1: Chaining - first .at() returns intermediate Mapping with correct slot
        let intermediate = nested.at(key1);
        let expected_intermediate_slot = key1.mapping_slot(base_slot);
        assert_eq!(
            intermediate.slot(),
            expected_intermediate_slot,
            "intermediate mapping should have correct slot"
        );

        // Property 2: Double-hash - second .at() returns final Slot with correct double-derived slot
        let final_slot = intermediate.at(key2);
        let expected_final_slot = key2.mapping_slot(expected_intermediate_slot);
        assert_eq!(
            final_slot.slot(),
            expected_final_slot,
            "final slot should use double-hash"
        );

        // Property 3: Determinism - same keys always produce same slot
        let slot_a = nested.at(key1).at(key2);
        let slot_b = nested.at(key1).at(key2);
        assert_eq!(
            slot_a.slot(),
            slot_b.slot(),
            "same keys should produce same slot"
        );

        // Property 4: Different first-level keys produce different final slots
        let different_key1 = Address::random();
        let different_slot = nested.at(different_key1).at(key2);
        assert_ne!(
            final_slot.slot(),
            different_slot.slot(),
            "different first-level keys should produce different slots"
        );

        // Property 5: Different second-level keys produce different final slots
        let different_key2 = B256::random();
        let another_slot = nested.at(key1).at(different_key2);
        assert_ne!(
            final_slot.slot(),
            another_slot.slot(),
            "different second-level keys should produce different slots"
        );
    }

    #[test]
    fn test_mapping_slot_boundaries() {
        let address = Rc::new(Address::random());

        // Test .slot() getter with ZERO boundary
        let zero_mapping = Mapping::<Address, U256>::new(U256::ZERO, Rc::clone(&address));
        assert_eq!(zero_mapping.slot(), U256::ZERO);
        let user = Address::random();
        let slot = zero_mapping.at(user);
        assert_eq!(slot.slot(), user.mapping_slot(U256::ZERO));

        // Test .slot() getter with MAX boundary
        let max_mapping = Mapping::<Address, U256>::new(U256::MAX, Rc::clone(&address));
        assert_eq!(max_mapping.slot(), U256::MAX);
        let user2 = Address::random();
        let slot2 = max_mapping.at(user2);
        assert_eq!(slot2.slot(), user2.mapping_slot(U256::MAX));

        // Test .slot() getter with arbitrary values
        let random_slot = U256::random();
        let arbitrary_mapping = Mapping::<Address, U256>::new(random_slot, Rc::clone(&address));
        assert_eq!(arbitrary_mapping.slot(), random_slot);
    }

    #[test]
    fn test_mapping_at_offset() {
        // Simulate: mapping(bytes32 => Orderbook) books
        // where Orderbook has a mapping field `bids` at field offset 1
        let pair_key = B256::random();
        let books_base_slot = U256::random();
        let orderbook_base_slot = pair_key.mapping_slot(books_base_slot);

        // Test that Mapping::at_offset() computes the correct slot
        let tick: i16 = 123;
        let address = Rc::new(Address::random());

        let slot = Mapping::<i16, U256>::at_offset(
            orderbook_base_slot,
            1, // bids field is at offset 1 in Orderbook
            Rc::clone(&address),
            tick,
        );

        // Verify the slot was computed correctly:
        // 1. Field slot = orderbook_base_slot + 1
        // 2. Mapping slot = keccak256(tick || field_slot)
        let field_slot = orderbook_base_slot + U256::from(1);
        let expected_slot = tick.mapping_slot(field_slot);
        assert_eq!(slot.slot(), expected_slot);
    }

    #[test]
    fn test_nested_mapping_at_offset() {
        // Simulate a struct with nested mapping at field offset 3
        let struct_key = B256::random();
        let mapping_base_slot = U256::random();
        let struct_base_slot = struct_key.mapping_slot(mapping_base_slot);

        let owner = Address::random();
        let spender = Address::random();

        // Nested mappings use recursive `Mapping<K, Mapping<K2, V>>` type
        let field_slot = struct_base_slot + U256::from(3); // nested mapping at field offset 3
        let nested_mapping =
            Mapping::<Address, Mapping<Address, U256>>::new(field_slot, Rc::new(Address::random()));

        // Verify double-hash computation is correct
        let final_slot = nested_mapping.at(owner).at(spender);

        // Expected: keccak256(spender || keccak256(owner || field_slot))
        let intermediate_slot = owner.mapping_slot(field_slot);
        let expected_slot = spender.mapping_slot(intermediate_slot);
        assert_eq!(final_slot.slot(), expected_slot);
    }

    #[test]
    fn test_multiple_fields_at_different_offsets() {
        // Simulate Orderbook with multiple mapping fields at different offsets
        let pair_key = B256::random();
        let books_base_slot = U256::random();
        let orderbook_base = pair_key.mapping_slot(books_base_slot);
        let address = Rc::new(Address::random());

        // bids at offset 1
        let tick1: i16 = 111;
        let bids_slot =
            Mapping::<i16, U256>::at_offset(orderbook_base, 1, Rc::clone(&address), tick1);

        // asks at offset 2
        let tick2: i16 = 222;
        let asks_slot =
            Mapping::<i16, U256>::at_offset(orderbook_base, 2, Rc::clone(&address), tick2);

        // bidBitmap at offset 3
        let bitmap_key: i16 = 333;
        let bitmap_slot =
            Mapping::<i16, U256>::at_offset(orderbook_base, 3, Rc::clone(&address), bitmap_key);

        // Verify all fields compute different slots (they're independent)
        let bids_expected = tick1.mapping_slot(orderbook_base + U256::from(1));
        let asks_expected = tick2.mapping_slot(orderbook_base + U256::from(2));
        let bitmap_expected = bitmap_key.mapping_slot(orderbook_base + U256::from(3));

        assert_eq!(bids_slot.slot(), bids_expected);
        assert_eq!(asks_slot.slot(), asks_expected);
        assert_eq!(bitmap_slot.slot(), bitmap_expected);

        // Verify they're all different
        assert_ne!(bids_slot.slot(), asks_slot.slot());
        assert_ne!(bids_slot.slot(), bitmap_slot.slot());
        assert_ne!(asks_slot.slot(), bitmap_slot.slot());
    }
}
