//! Type-safe wrapper for EVM storage mappings (hash-based key-value storage).

use alloy::primitives::{Address, U256};
use std::{
    hash::Hash,
    ops::{Index, IndexMut},
};

use crate::storage::{Layout, LayoutCtx, StorableType, StorageKey, types::HandlerCache};

/// Type-safe access wrapper for EVM storage mappings (hash-based key-value storage).
///
/// This struct does not store data itself. Instead, it provides a zero-cost abstraction
/// for accessing mapping storage slots using Solidity's hash-based layout. It wraps a
/// base slot number and provides methods to compute the actual storage slots for keys.
///
/// # Type Parameters
///
/// - `K`: Key type (must implement `StorageKey`)
/// - `V`: Value type (must implement `StorableType`)
///
/// `Mapping<K, V>` is essentially a slot computation helper. The `[key]` method
/// performs the keccak256 hash to compute the actual storage slot and returns a
/// `Handler` that can be used for read/write operations.
///
/// # Storage Layout
///
/// Mappings use Solidity's storage layout:
/// - Base slot: stored in `base_slot` field (never accessed directly)
/// - Actual slot for key `k`: `keccak256(k || base_slot)`
///
/// # Usage Pattern
///
/// The typical usage follows a composable pattern:
/// 1. Create a `Mapping<K, V>` with a base slot (usually from generated constants)
/// 2. Call `[key]` to compute and obtain a `Handler` for that key
/// 3. Use `.read()`, `.write()`, or `.delete()` on the resulting slot
///
/// # Accessing Mapping Fields Within Structs
///
/// When a mapping is a field within a struct stored in another mapping, use the static
/// `at_offset` method to compute the slot without creating a `Mapping` instance:
#[derive(Debug, Clone)]
pub struct Mapping<K, V: StorableType> {
    base_slot: U256,
    address: Address,
    cache: HandlerCache<K, V::Handler>,
}

impl<K, V: StorableType> Mapping<K, V> {
    /// Creates a new `Mapping` with the given base slot number and address.
    ///
    /// This is typically called with slot constants generated by the `#[contract]` macro.
    #[inline]
    pub fn new(base_slot: U256, address: Address) -> Self {
        Self {
            base_slot,
            address,
            cache: HandlerCache::new(),
        }
    }

    /// Returns the U256 base storage slot number for this mapping.
    #[inline]
    pub const fn slot(&self) -> U256 {
        self.base_slot
    }

    /// Returns a `Handler` for the given key.
    ///
    /// This enables the composable pattern: `mapping.at(&key).read()`
    /// where the mapping slot computation happens once, and the resulting slot
    /// can be used for multiple operations.
    ///
    /// The handler is computed on first access and cached for subsequent accesses.
    /// Takes a reference to avoid cloning on cache hits.
    pub fn at(&self, key: &K) -> &V::Handler
    where
        K: StorageKey + Hash + Eq + Clone,
    {
        let (base_slot, address) = (self.base_slot, self.address);
        self.cache.get_or_insert(key, || {
            V::handle(key.mapping_slot(base_slot), LayoutCtx::FULL, address)
        })
    }

    /// Returns a mutable `Handler` for the given key.
    ///
    /// Use this when you need to call mutable methods like `write()` or `delete()`.
    ///
    /// The handler is computed on first access and cached for subsequent accesses.
    /// Takes a reference to avoid cloning on cache hits.
    pub fn at_mut(&mut self, key: &K) -> &mut V::Handler
    where
        K: StorageKey + Hash + Eq + Clone,
    {
        let (base_slot, address) = (self.base_slot, self.address);
        self.cache.get_or_insert_mut(key, || {
            V::handle(key.mapping_slot(base_slot), LayoutCtx::FULL, address)
        })
    }
}

impl<K, V: StorableType> Default for Mapping<K, V> {
    fn default() -> Self {
        Self::new(U256::ZERO, Address::ZERO)
    }
}

impl<K, V: StorableType> Index<K> for Mapping<K, V>
where
    K: StorageKey + Hash + Eq + Clone,
{
    type Output = V::Handler;

    /// Returns a reference to the cached handler for the given key.
    ///
    /// The handler is computed on first access and cached for subsequent accesses.
    fn index(&self, key: K) -> &Self::Output {
        let (base_slot, address) = (self.base_slot, self.address);
        self.cache.get_or_insert(&key, || {
            V::handle(key.mapping_slot(base_slot), LayoutCtx::FULL, address)
        })
    }
}

impl<K, V: StorableType> IndexMut<K> for Mapping<K, V>
where
    K: StorageKey + Hash + Eq + Clone,
{
    /// Returns a mutable reference to the cached handler for the given key.
    fn index_mut(&mut self, key: K) -> &mut Self::Output {
        let (base_slot, address) = (self.base_slot, self.address);
        self.cache.get_or_insert_mut(&key, || {
            V::handle(key.mapping_slot(base_slot), LayoutCtx::FULL, address)
        })
    }
}

// Mappings occupy a full 32-byte slot in the layout (used as a base for hashing),
// even though they don't store data in that slot directly.
//
// **NOTE:** Necessary to allow it to participate in struct layout calculations.
impl<K, V> StorableType for Mapping<K, V>
where
    V: StorableType,
{
    const LAYOUT: Layout = Layout::Slots(1);
    type Handler = Self;

    fn handle(slot: U256, _ctx: LayoutCtx, address: Address) -> Self::Handler {
        Self::new(slot, address)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::storage::StorageKey;
    use alloy::primitives::{Address, B256, keccak256};

    // Backward compatibility helper to verify the trait impl.
    fn old_mapping_slot<K: AsRef<[u8]>>(key: K, slot: U256) -> U256 {
        let key = key.as_ref();
        let mut buf = [0u8; 64];
        buf[32 - key.len()..32].copy_from_slice(key);
        buf[32..].copy_from_slice(&slot.to_be_bytes::<32>());
        U256::from_be_bytes(keccak256(buf).0)
    }

    #[test]
    fn test_mapping_slot_encoding() {
        let key = Address::random();
        let base_slot = U256::random();

        // Manual computation to validate
        let mut buf = [0u8; 64];
        // Left-pad the address to 32 bytes
        buf[12..32].copy_from_slice(key.as_ref());
        // Slot in big-endian
        buf[32..].copy_from_slice(&base_slot.to_be_bytes::<32>());

        let expected = U256::from_be_bytes(keccak256(buf).0);
        let computed = key.mapping_slot(base_slot);

        assert_eq!(computed, expected, "mapping_slot encoding mismatch");
    }

    #[test]
    fn test_mapping_slot_matches_old_impl() {
        let slot = U256::random();

        let addr = Address::random();
        assert_eq!(
            addr.mapping_slot(slot),
            old_mapping_slot(addr.as_slice(), slot),
        );

        let b256 = B256::random();
        assert_eq!(
            b256.mapping_slot(slot),
            old_mapping_slot(b256.as_slice(), slot),
        );

        let u256 = U256::random();
        assert_eq!(
            u256.mapping_slot(slot),
            old_mapping_slot(u256.to_be_bytes::<32>(), slot),
        );
    }

    #[test]
    fn test_mapping_basic_properties() {
        let address = Address::random();
        let base_slot = U256::random();
        let mapping = Mapping::<Address, U256>::new(base_slot, address);

        // Property 1: Determinism - same key always produces same slot
        let key = Address::random();
        let slot1 = &mapping[key];
        let slot2 = &mapping[key];
        assert_eq!(
            slot1.slot(),
            slot2.slot(),
            "same key should produce same slot"
        );

        // Property 2: Different keys produce different slots
        let key1 = Address::random();
        let key2 = Address::random();
        let slot_a = &mapping[key1];
        let slot_b = &mapping[key2];
        assert_ne!(
            slot_a.slot(),
            slot_b.slot(),
            "different keys should produce different slots"
        );

        // Property 3: Derived slot matches manual computation
        let test_key = Address::random();
        let derived_slot = &mapping[test_key];
        let expected_slot = test_key.mapping_slot(base_slot);
        assert_eq!(derived_slot.slot(), expected_slot);
    }

    #[test]
    fn test_nested_mapping_basic_properties() {
        let address = Address::random();
        let base_slot = U256::random();
        // Nested mappings use recursive Mapping<K, Mapping<K2, V>> type
        let nested = Mapping::<Address, Mapping<B256, U256>>::new(base_slot, address);

        let key1 = Address::random();
        let key2 = B256::random();

        // Property 1: Chaining - first .at() returns intermediate Mapping with correct slot
        let intermediate = &nested[key1];
        let expected_intermediate_slot = key1.mapping_slot(base_slot);
        assert_eq!(
            intermediate.slot(),
            expected_intermediate_slot,
            "intermediate mapping should have correct slot"
        );

        // Property 2: Double-hash - second .at() returns final Slot with correct double-derived slot
        let final_slot = &intermediate[key2];
        let expected_final_slot = key2.mapping_slot(expected_intermediate_slot);
        assert_eq!(
            final_slot.slot(),
            expected_final_slot,
            "final slot should use double-hash"
        );

        // Property 3: Determinism - same keys always produce same slot
        let slot_a = &nested[key1][key2];
        let slot_b = &nested[key1][key2];
        assert_eq!(
            slot_a.slot(),
            slot_b.slot(),
            "same keys should produce same slot"
        );

        // Property 4: Different first-level keys produce different final slots
        let different_key1 = Address::random();
        let different_slot = &nested[different_key1][key2];
        assert_ne!(
            final_slot.slot(),
            different_slot.slot(),
            "different first-level keys should produce different slots"
        );

        // Property 5: Different second-level keys produce different final slots
        let different_key2 = B256::random();
        let another_slot = &nested[key1][different_key2];
        assert_ne!(
            final_slot.slot(),
            another_slot.slot(),
            "different second-level keys should produce different slots"
        );
    }

    #[test]
    fn test_mapping_slot_boundaries() {
        let address = Address::random();

        // Test .slot() getter with ZERO boundary
        let zero_mapping = Mapping::<Address, U256>::new(U256::ZERO, address);
        assert_eq!(zero_mapping.slot(), U256::ZERO);
        let user = Address::random();
        let slot = &zero_mapping[user];
        assert_eq!(slot.slot(), user.mapping_slot(U256::ZERO));

        // Test .slot() getter with MAX boundary
        let max_mapping = Mapping::<Address, U256>::new(U256::MAX, address);
        assert_eq!(max_mapping.slot(), U256::MAX);
        let user2 = Address::random();
        let slot2 = &max_mapping[user2];
        assert_eq!(slot2.slot(), user2.mapping_slot(U256::MAX));

        // Test .slot() getter with arbitrary values
        let random_slot = U256::random();
        let arbitrary_mapping = Mapping::<Address, U256>::new(random_slot, address);
        assert_eq!(arbitrary_mapping.slot(), random_slot);
    }
}
