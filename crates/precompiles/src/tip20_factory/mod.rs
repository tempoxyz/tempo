//! TIP20 Factory module.
//!
//! This module contains the TIP20 token factory implementation.

use crate::{
    TIP20_FACTORY_ADDRESS,
    error::Result,
    tip20::{TIP20Error, TIP20Token, USD_CURRENCY, abi::IToken as _, is_tip20_prefix},
};
use alloy::{
    primitives::{Address, B256, keccak256},
    sol_types::SolValue,
};
use tempo_precompiles_macros::{abi, contract};
use tracing::trace;

/// Number of reserved addresses (0 to RESERVED_SIZE-1) that cannot be deployed via factory
const RESERVED_SIZE: u64 = 1024;

/// TIP20 token address prefix (12 bytes): 0x20C000000000000000000000
const TIP20_PREFIX_BYTES: [u8; 12] = [
    0x20, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];

#[contract(abi, dispatch, addr = TIP20_FACTORY_ADDRESS)]
pub struct TIP20Factory {}

/// Computes the deterministic TIP20 address from sender and salt.
/// Returns the address and the lower bytes used for derivation.
fn compute_tip20_address(sender: Address, salt: B256) -> (Address, u64) {
    let hash = keccak256((sender, salt).abi_encode());

    let mut padded = [0u8; 8];
    padded.copy_from_slice(&hash[..8]);
    let lower_bytes = u64::from_be_bytes(padded);

    let mut address_bytes = [0u8; 20];
    address_bytes[..12].copy_from_slice(&TIP20_PREFIX_BYTES);
    address_bytes[12..].copy_from_slice(&hash[..8]);

    (Address::from(address_bytes), lower_bytes)
}

#[abi(dispatch)]
#[rustfmt::skip]
pub mod abi {
    use super::*;

    pub trait IFactory {
        fn create_token(
            &mut self,
            name: String,
            symbol: String,
            currency: String,
            quote_token: Address,
            admin: Address,
            salt: B256,
        ) -> Result<Address>;
        fn is_tip20(&self, token: Address) -> Result<bool>;
        fn get_token_address(&self, sender: Address, salt: B256) -> Result<Address>;
    }

    pub enum Error {
        AddressReserved,
        AddressNotReserved,
        InvalidQuoteToken,
        TokenAlreadyExists { token: Address },
    }

    pub enum Event {
        TokenCreated {
            #[indexed] token: Address,
            name: String,
            symbol: String,
            currency: String,
            quote_token: Address,
            admin: Address,
            salt: B256,
        },
    }
}

// Type aliases for backward compatibility (generated by #[contract] macro)
// pub type TIP20FactoryError = abi::Error;
// pub type TIP20FactoryEvent = abi::Event;
pub use IAbi as ITIP20Factory;

// Precompile functions
impl TIP20Factory {
    /// Initializes the TIP20 factory contract.
    pub fn initialize(&mut self) -> Result<()> {
        self.__initialize()
    }

    /// Returns true if the factory has been initialized (has code set).
    pub fn is_initialized(&self) -> Result<bool> {
        self.storage
            .with_account_info(TIP20_FACTORY_ADDRESS, |info| Ok(info.code.is_some()))
    }

    /// Returns true if the address is a valid TIP20 token (internal helper).
    fn is_tip20_internal(&self, token: Address) -> Result<bool> {
        if !is_tip20_prefix(token) {
            return Ok(false);
        }
        self.storage
            .with_account_info(token, |info| Ok(!info.is_empty_code_hash()))
    }

    /// Creates a token at a reserved address
    /// Internal function used to deploy TIP20s at reserved addresses at genesis or hardforks
    pub fn create_token_reserved_address(
        &mut self,
        address: Address,
        name: &str,
        symbol: &str,
        currency: &str,
        quote_token: Address,
        admin: Address,
    ) -> Result<Address> {
        if !is_tip20_prefix(address) {
            return Err(TIP20Error::invalid_token().into());
        }

        if self.is_tip20_internal(address)? {
            return Err(TIP20FactoryError::token_already_exists(address).into());
        }

        if !quote_token.is_zero() {
            if !self.is_tip20_internal(quote_token)? {
                return Err(TIP20Error::invalid_quote_token().into());
            }
            if currency == USD_CURRENCY
                && TIP20Token::from_address(quote_token)?.currency()? != USD_CURRENCY
            {
                return Err(TIP20Error::invalid_quote_token().into());
            }
        }

        let mut padded = [0u8; 8];
        padded.copy_from_slice(&address.as_slice()[12..]);
        let lower_bytes = u64::from_be_bytes(padded);
        if lower_bytes >= RESERVED_SIZE {
            return Err(TIP20FactoryError::address_not_reserved().into());
        }

        let mut token = TIP20Token::from_address(address)?;
        token.initialize(admin, name, symbol, currency, quote_token, admin)?;

        self.emit_event(TIP20FactoryEvent::token_created(
            address,
            name.into(),
            symbol.into(),
            currency.into(),
            quote_token,
            admin,
            B256::ZERO,
        ))?;

        Ok(address)
    }
}

impl abi::IFactory for TIP20Factory {
    fn create_token(
        &mut self,
        msg_sender: Address,
        name: String,
        symbol: String,
        currency: String,
        quote_token: Address,
        admin: Address,
        salt: B256,
    ) -> Result<Address> {
        trace!(%msg_sender, name, symbol, currency, %quote_token, %admin, ?salt, "Create token");

        let (token_address, lower_bytes) = compute_tip20_address(msg_sender, salt);

        if self.is_tip20_internal(token_address)? {
            return Err(TIP20FactoryError::token_already_exists(token_address).into());
        }

        if !self.is_tip20_internal(quote_token)? {
            return Err(TIP20Error::invalid_quote_token().into());
        }

        if currency == USD_CURRENCY
            && TIP20Token::from_address(quote_token)?.currency()? != USD_CURRENCY
        {
            return Err(TIP20Error::invalid_quote_token().into());
        }

        if lower_bytes < RESERVED_SIZE {
            return Err(TIP20FactoryError::address_reserved().into());
        }

        TIP20Token::from_address(token_address)?.initialize(
            msg_sender,
            &name,
            &symbol,
            &currency,
            quote_token,
            admin,
        )?;

        self.emit_event(TIP20FactoryEvent::token_created(
            token_address,
            name,
            symbol,
            currency,
            quote_token,
            admin,
            salt,
        ))?;

        Ok(token_address)
    }

    fn is_tip20(&self, token: Address) -> Result<bool> {
        self.is_tip20_internal(token)
    }

    fn get_token_address(&self, sender: Address, salt: B256) -> Result<Address> {
        let (address, lower_bytes) = compute_tip20_address(sender, salt);

        if lower_bytes < RESERVED_SIZE {
            return Err(TIP20FactoryError::address_reserved().into());
        }

        Ok(address)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{
        PATH_USD_ADDRESS,
        error::TempoPrecompileError,
        storage::{ContractStorage, StorageCtx, hashmap::HashMapStorageProvider},
        test_util::TIP20Setup,
    };
    use alloy::primitives::Address;

    #[test]
    fn test_create_token() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        let sender = Address::random();
        StorageCtx::enter(&mut storage, || {
            let mut factory = TIP20Setup::factory()?;
            let path_usd = TIP20Setup::path_usd(sender).apply()?;
            factory.clear_emitted_events();

            let salt1 = B256::random();
            let salt2 = B256::random();

            let token_addr_1 = abi::IFactory::create_token(
                &mut factory,
                sender,
                "Test Token 1".to_string(),
                "TEST1".to_string(),
                "USD".to_string(),
                path_usd.address(),
                sender,
                salt1,
            )?;
            let token_addr_2 = abi::IFactory::create_token(
                &mut factory,
                sender,
                "Test Token 2".to_string(),
                "TEST2".to_string(),
                "USD".to_string(),
                path_usd.address(),
                sender,
                salt2,
            )?;

            assert_ne!(token_addr_1, token_addr_2);
            assert!(is_tip20_prefix(token_addr_1));
            assert!(is_tip20_prefix(token_addr_2));
            assert!(abi::IFactory::is_tip20(&factory, token_addr_1)?);
            assert!(abi::IFactory::is_tip20(&factory, token_addr_2)?);

            factory.assert_emitted_events(vec![
                TIP20FactoryEvent::token_created(
                    token_addr_1,
                    "Test Token 1".to_string(),
                    "TEST1".to_string(),
                    "USD".to_string(),
                    path_usd.address(),
                    sender,
                    salt1,
                ),
                TIP20FactoryEvent::token_created(
                    token_addr_2,
                    "Test Token 2".to_string(),
                    "TEST2".to_string(),
                    "USD".to_string(),
                    path_usd.address(),
                    sender,
                    salt2,
                ),
            ]);

            Ok(())
        })
    }

    #[test]
    fn test_create_token_invalid_quote_token() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        let sender = Address::random();
        StorageCtx::enter(&mut storage, || {
            let mut factory = TIP20Setup::factory()?;
            TIP20Setup::path_usd(sender).apply()?;

            let result = abi::IFactory::create_token(
                &mut factory,
                sender,
                "Test Token".to_string(),
                "TEST".to_string(),
                "USD".to_string(),
                Address::random(),
                sender,
                B256::random(),
            );
            assert_eq!(
                result.unwrap_err(),
                TempoPrecompileError::TIP20(TIP20Error::invalid_quote_token())
            );
            Ok(())
        })
    }

    #[test]
    fn test_create_token_quote_token_not_deployed() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        let sender = Address::random();
        StorageCtx::enter(&mut storage, || {
            let mut factory = TIP20Setup::factory()?;
            TIP20Setup::path_usd(sender).apply()?;

            let non_existent_tip20 =
                Address::from(alloy::hex!("20C0000000000000000000000000000000009999"));
            let result = abi::IFactory::create_token(
                &mut factory,
                sender,
                "Test Token".to_string(),
                "TEST".to_string(),
                "USD".to_string(),
                non_existent_tip20,
                sender,
                B256::random(),
            );
            assert_eq!(
                result.unwrap_err(),
                TempoPrecompileError::TIP20(TIP20Error::invalid_quote_token())
            );
            Ok(())
        })
    }

    #[test]
    fn test_create_token_already_deployed() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        let sender = Address::random();
        StorageCtx::enter(&mut storage, || {
            let mut factory = TIP20Setup::factory()?;
            TIP20Setup::path_usd(sender).apply()?;

            let salt = B256::random();

            let token = abi::IFactory::create_token(
                &mut factory,
                sender,
                "Test Token".to_string(),
                "TEST".to_string(),
                "USD".to_string(),
                PATH_USD_ADDRESS,
                sender,
                salt,
            )?;
            let result = abi::IFactory::create_token(
                &mut factory,
                sender,
                "Test Token".to_string(),
                "TEST".to_string(),
                "USD".to_string(),
                PATH_USD_ADDRESS,
                sender,
                salt,
            );
            assert_eq!(
                result.unwrap_err(),
                TempoPrecompileError::TIP20Factory(TIP20FactoryError::token_already_exists(token))
            );

            Ok(())
        })
    }

    #[test]
    fn test_is_tip20() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);
        let sender = Address::random();

        StorageCtx::enter(&mut storage, || {
            let _path_usd = TIP20Setup::path_usd(sender).apply()?;

            let factory = TIP20Factory::new();

            assert!(abi::IFactory::is_tip20(&factory, PATH_USD_ADDRESS)?);

            let no_code_tip20 =
                Address::from(alloy::hex!("20C0000000000000000000000000000000009999"));
            assert!(!abi::IFactory::is_tip20(&factory, no_code_tip20)?);

            assert!(!abi::IFactory::is_tip20(&factory, Address::random())?);

            let token = TIP20Setup::create("Test", "TST", sender).apply()?;
            assert!(abi::IFactory::is_tip20(&factory, token.address())?);

            Ok(())
        })
    }

    #[test]
    fn test_is_tip20_prefix() -> eyre::Result<()> {
        let mut storage = HashMapStorageProvider::new(1);

        StorageCtx::enter(&mut storage, || {
            assert!(is_tip20_prefix(PATH_USD_ADDRESS));

            let tip20_addr = Address::from(alloy::hex!("20C0000000000000000000000000000000001234"));
            assert!(is_tip20_prefix(tip20_addr));

            let random = Address::random();
            assert!(!is_tip20_prefix(random));

            Ok(())
        })
    }

    #[test]
    fn test_compute_tip20_address_deterministic() {
        let sender1 = Address::random();
        let sender2 = Address::random();
        let salt1 = B256::random();
        let salt2 = B256::random();

        let (addr0, lower0) = compute_tip20_address(sender1, salt1);
        let (addr1, lower1) = compute_tip20_address(sender1, salt1);
        assert_eq!(addr0, addr1);
        assert_eq!(lower0, lower1);

        let (addr2, lower2) = compute_tip20_address(sender1, salt1);
        let (addr3, lower3) = compute_tip20_address(sender2, salt1);
        assert_ne!(addr2, addr3);
        assert_ne!(lower2, lower3);

        let (addr4, lower4) = compute_tip20_address(sender1, salt1);
        let (addr5, lower5) = compute_tip20_address(sender1, salt2);
        assert_ne!(addr4, addr5);
        assert_ne!(lower4, lower5);

        assert!(is_tip20_prefix(addr1));
        assert!(is_tip20_prefix(addr2));
        assert!(is_tip20_prefix(addr3));
        assert!(is_tip20_prefix(addr4));
        assert!(is_tip20_prefix(addr5));
    }
}
