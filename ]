// Module for tip20_rewards_registry precompile
pub mod dispatch;

use alloy::{
    primitives::{Address, Bytes, U256, uint},
    sol_types::SolValue,
};
use alloy_primitives::keccak256;
use revm::state::Bytecode;
use tempo_contracts::precompiles::TIP20RewardsRegistryError;

use crate::{
    TIP20_REWARDS_REGISTRY_ADDRESS,
    error::TempoPrecompileError,
    storage::{PrecompileStorageProvider, slots::mapping_slot},
};

pub mod slots {
    use alloy::primitives::{U256, uint};

    pub const LAST_UPDATED_TIMESTAMP: U256 = uint!(0_U256);
    // Mapping of (uint128 => []address) to inidicate all tip20 tokens with reward streams
    // ending at the specified timestamp
    pub const STREAMS_ENDING_AT: U256 = uint!(1_U256);
    // Mapping of (bytes32 => bool) to inidicate if a rewards stream exists.
    // Mapping key is derived via keccak256(abi.encode(tip20_address, end_time))
    pub const STREAM_REGISTERED: U256 = uint!(2_U256);
}

/// TIPRewardsRegistry precompile that tracks stream end times
/// Maps timestamp -> Vec of token addresses with streams ending at that time
pub struct TIP20RewardsRegistry<'a, S: PrecompileStorageProvider> {
    storage: &'a mut S,
    address: Address,
}

impl<'a, S: PrecompileStorageProvider> TIP20RewardsRegistry<'a, S> {
    pub fn new(address: Address, storage: &'a mut S) -> Self {
        Self { storage, address }
    }

    /// Initializes the TIP20 rewards registry contract.
    ///
    /// Ensures the [`TIP20RewardsRegistry`] account isn't empty and prevents state clear.
    pub fn initialize(&mut self) -> Result<(), TempoPrecompileError> {
        self.storage.set_code(
            TIP20_REWARDS_REGISTRY_ADDRESS,
            Bytecode::new_legacy(Bytes::from_static(&[0xef])),
        )
    }

    /// Get the last updated timestamp
    fn get_last_updated_timestamp(&mut self) -> Result<u128, TempoPrecompileError> {
        let val = self
            .storage
            .sload(self.address, slots::LAST_UPDATED_TIMESTAMP)?;
        Ok(val.to::<u128>())
    }

    /// Set the last updated timestamp
    fn set_last_updated_timestamp(&mut self, timestamp: u128) -> Result<(), TempoPrecompileError> {
        self.storage.sstore(
            self.address,
            slots::LAST_UPDATED_TIMESTAMP,
            U256::from(timestamp),
        )
    }

    fn get_stream_registered(
        &mut self,
        token: &Address,
        end_time: u128,
    ) -> Result<bool, TempoPrecompileError> {
        let key = keccak256((token, end_time).abi_encode());
        let slot = mapping_slot(key, slots::STREAM_REGISTERED);
        Ok(self.storage.sload(self.address, slot)?.to::<bool>())
    }

    fn set_stream_registered(
        &mut self,
        token: &Address,
        end_time: u128,
    ) -> Result<(), TempoPrecompileError> {
        let key = keccak256((token, end_time).abi_encode());
        let slot = mapping_slot(key, slots::STREAM_REGISTERED);
        self.storage.sstore(self.address, slot, U256::from(true))
    }

    /// Add a token to the registry for a given stream end time
    pub fn add_stream(
        &mut self,
        token: &Address,
        end_time: u128,
    ) -> Result<(), TempoPrecompileError> {
        // Check if already registered
        if self.get_stream_registered(token, end_time)? {
            return Ok(());
        }

        self.set_stream_registered(token, end_time)?;

        // TODO: add stream to streams

        Ok(())
    }

    pub fn get_streams_ending_at_timestamp(
        &mut self,
        timestamp: u128,
    ) -> Result<Vec<Address>, TempoPrecompileError> {
        todo!()
    }

    /// Finalize streams for all tokens ending at the current timestamp
    pub fn finalize_streams(&mut self, sender: &Address) -> Result<(), TempoPrecompileError> {
        if *sender != Address::ZERO {
            return Err(TIP20RewardsRegistryError::unauthorized().into());
        }

        let current_timestamp = self.storage.timestamp().to::<u128>();
        let mut current_timestamp = self.get_last_updated_timestamp()? + 1;

        while  >= timestamp {
            let tokens = self.get_streams_ending_at_timestamp(timestamp)?;
            // TODO: finalize each stream

            last_updated_timestamp += 1;
        }

        self.set_last_updated_timestamp(timestamp)?;

        Ok(())
    }
}
