# Network reconfiguration

This document defines how the Tempo network reconfigures its set of active
validators through the a distribute key generation ceremony.

## Definitions and network state

Tempo is running Simplex consensus using the commonwarexyz stack with
BLS12-381 threshold signatures. For a high level overview of the protocol,
see [1] and [2]. Node-to-node communication is done using direct p2p, with their
identities (in the form of ed25519 public keys) and socket addresses of all
validators known. In the context of commonwarexyz, this is known as authenticated
lookup p2p [3].

The network state evolves in epochs, where epochs are numbered 0, 1, 2, ... and
where each epoch has the same length of blocks `E` defined at genesis. For a
given `E`, epoch 0 runs from blocks 0 to E-1, epoch 1 from E to 2E-1, epoch 2
from 2E to 3E-1 and so on. During an epoch, the network runs a so-called DKG
(dynamic key generation) ceremony, transitioning to the new epoch with the
result of this DKG ceremony.

The state of a network (and thus the outcome of a DKG ceremony) for a given
epoch is then defined by:

1. the public threshold key polynomial;
2. the set of private threshold key shares (one per validator);
3. the list `[ed25519-public-key]` of public ed25519 keys uniquely identifying
   each validator, socket-address)`.

At genesis, the network is launched with a known public threshold key
polynomial, a set of private threshold key shares (one per validator), a list
of `(ed25519-public-key, socket-address)` to identify and coontact each
validator, and a so-called `epoch_length`, a fixed number of blocks definining
the length of an epoch.

Note that for the purpose of the ceremony outcome, only the ed25519 public keys
are relevant. The socket addresses are also noted here as a side-effect of the
choice of P2P network, binding key and address closely together.

Note that for the purpose of this document the initial state is assumed to be
generated by an external process. For production environments, this can be a
separate purpose-build chain to generate the initial public polynomial and set
of initial key shares without revealing them.

[1]: https://docs.rs/commonware-consensus/0.0.63/commonware_consensus/simplex/index.html#protocol-description
[2]: https://docs.rs/commonware-consensus/0.0.63/commonware_consensus/simplex/index.html#signing_schemebls12381_threshold
[3]: https://docs.rs/commonware-p2p/0.0.63/commonware_p2p/authenticated/lookup/index.html

## Genesis data

At genesis, `epoch_length` is read from `genesis.config.extra_fields`. The
initial public polynomial is read from `genesis.extra_data`. And the set of
validators is read from the `ValidatorConfig` smart contract using the
`getValidators` call. The data written to `extra_fields` is a JSON object of
the `{epochLength: <NUMBER>}`, see `TempoGenesisInfo` in [4] for the underlying
Rust struct. The `extra_data` field contains a binary encoding of a triple
`{epoch: <NUMBER>, participants: [<ed25519 pubkey>], public: <bytes>}` using
the commonware codec, see `PublicOutcome` in [5]. And for the validator config
see [6].

[4]: ../crates/chainspec/src/spec.rs
[5]: ../crates/dkg-onchain-artifacts/src/lib.rs
[6]: ../crates/contracts/src/precompiles/validator_config.rs

## Protocol of a DKG ceremony

The process of initializing, running, and completing a DKG ceremony is closely
coupled to finalized blocks. The steps below are for the DKG ceremony of epoch
`C`. The term "boundary block" referred to below describes the last block of an
epoch (for example, for a given epoch length `E`, the last block before epoch
`C` commences is `C*E - 1`, and the last block of `C` is `(C+1)*E - 1`). For
epoch `C`, the boundary block is `B = (C+1)*E-1`

The *dealers* of the DKG ceremony are the validators of the current/outgoing
epoch. The *players* of the DKG ceremony are the validators stored in the
smart contract on-chain. On success, they will become the validators of the
next epoch.

For each finalized block, the following actions will be taken depending on its
height H.

1. on `H == C*E` (first height of the epoch):
   a. read the ceremony players using the `getValidators` call. Note:
      `getValidators` is done using the boundary block of the previous epoch
      `C-1`.
   b. initialize the DKG ceremony with `dealers = <current validators`,
      `players = <from contract>`,
      `previous_polynomial = <public polynomial of current epoch>`.
   c. if a dealer: generate public polynomial and n private key shares (one
      per player).
2. on `C*E <= H < (C+1/2)*E` (first half of the epoch):
   a. if a dealer: send a key share to each player in the ceremony.
   b. if a dealer: receive the acknowledgments (`acks`) from each player that
      they have received a key share.
   c. if a player: receive a key share from each dealer, construct and sign
      and `ack` message, and return it to the respective dealer.
3. on `H = (C+1/2)*E` (exact middle of the epoch):
   a. if a dealer: construct the *dealing* or intermediate outcome of the
      ceremony.
4. on `(C+1/2)*E < H <= B-1` (second half of the epoch up to one before boundary):
   a. if a dealer: once the dealer is a proposer, write the dealing/intermediate
      outcome to the `extra_data` field of the block header.
   b: dealer or player: read and store the dealings of the dealers from the
     `extra_data` field.
5. on `H = B-1` (one before the boundary block):
  a. dealer or player: finalize the ceremony, determine its overall outcome
     in the from of a group polynomial (a combination of all polynomials
     generated by the dealers).
  b. on success: store the new polynomial, private key share (if a player), and
     participants in the next ceremony.
  c. on failure: keep the old polynomial, private key share (if a dealer), and
     participants of the old ceremony.
6. on `H = (C+1)*E - 1` (the boundary block):
   a. if a dealer && proposer: write the overall outcome of the DKG ceremony to
      the `extra_data` field of the block header.
   b. if a dealer && verifier: verify that the overall outcome in the
      `extra_data` matches.
   c. dealer or player: enter epoch `C+1` with the outcome of the ceremony in
      epoch `C`.
   
### On determining ceremony players on the boundary block

Because a finalized block is forwarded to the execution layer and to the DKG
manager (the actor responsible for managing DKG ceremonies) at the same time,
there is no guarantee that the block is executed on the execution layer before
the DKG manager makes the `getValidators` call. However, it is guaranteed that
processing of block `B-1` happened before `B` was forwarded. Thus, when
initializing the DKG ceremony, the DKG manager is reading the state of `B-1` (or
in this, on the first height `C*E` of the current epoch `C`, the boundary block
`C*E-1` of the previous epoch `C-1` will be read).

## Adding a validator to the network

A validator is added to the network using the `ValidatorConfig::addValidator`
contract call, see also [6]. The values written to this contract are read on
the first block of each epoch, as described in the protocol.
