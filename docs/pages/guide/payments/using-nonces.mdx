import * as Demo from '../../../components/guides/Demo.tsx'
import * as Step from '../../../components/guides/steps'
import * as Token from '../../../components/guides/tokens'
import * as Card from '../../../components/Card.tsx'
import LucideCode from '~icons/lucide/code'
import LucideSend from '~icons/lucide/send'
import LucideGitBranch from '~icons/lucide/git-branch'

# Using Nonces

Submit multiple transactions in parallel using Tempo's [2D nonces](/protocol/transactions/spec-tempo-transaction). The `nonceKey` property allow you to send concurrent transactions without waiting for each one to confirm sequentially.

### Understanding Nonce Keys

Tempo uses a **2D nonce system** that enables parallel transaction execution:

- **Protocol nonce (key 0)**: The default sequential nonce. Transactions must be processed in order.
- **User nonces (keys 1+)**: Independent nonce sequences that allow concurrent transaction submission.

When you send a transaction without specifying a `nonceKey`, it uses the protocol nonce and behaves like a standard sequential transaction. By specifying different nonce keys, you can submit multiple transactions simultaneously without waiting for confirmations.

### Key management strategies

There are two ways to speicify a `nonceKey` for a transaction:

#### Explicit keys

Explicit keys (1n, 2n, etc.) are best when you want to reuse keys. For high-throughput applications, these keys can be used to load-balance transaction submission to the network in a gas-efficient way. You can track the most recent call on each key in your application, and, once that transaction confirms, the same key can be used for new transactions. This approach is more gas efficient, as provisioning a new `nonceKey` [costs gas](/protocol/transactions/spec-tempo-transaction#gas-schedule).

#### `'random'` keys
For simple cases where you don't need to track keys. This approach is recommended when handling bursts of high activity, in which you need to submit transfers to the network and don't care about the added gas costs for provisioning multiple keys.

## Demo

By the end of this guide you will understand how to send parallel payments using nonce keys.

<Demo.Container name="Send Parallel Payments" footerVariant="balances" tokens={[Token.alphaUsd]}>
  <Step.Connect stepNumber={1} />
  <Step.AddFunds stepNumber={2} />
  <Step.SendParallelPayments stepNumber={3} />
</Demo.Container>

## Steps

::::steps

### Set up Wagmi & integrate accounts

Ensure that you have set up your project with Wagmi and integrated accounts by following either of the guides:

- [Embed Passkey accounts](/guide/use-accounts/embed-passkeys)
- [Connect to wallets](/guide/use-accounts/connect-to-wallets)

### Fetch current nonces

In order to send a transfer on a custom `nonceKey`, you need to know the current nonce value for the keys you will send on. 

:::code-group

```ts twoslash [example.ts]
import { Actions } from 'tempo.ts/wagmi'
import { parseUnits } from 'viem'
import { config } from './wagmi.config'

// @noErrors

// Fetch nonces for each key in parallel
const [nonce1, nonce2] = await Promise.all([
  Actions.nonce.getNonce(config, { account, nonceKey: 1n }), // [!code hl]
  Actions.nonce.getNonce(config, { account, nonceKey: 2n }), // [!code hl]
])

console.log('Current nonce for nonceKey 1:', nonce1)
console.log('Current nonce for nonceKey 2:', nonce2)
```

```tsx twoslash [wagmi.config.ts] filename="wagmi.config.ts"
// @noErrors
// [!include ~/snippets/wagmi.config.ts:setup]
```

:::

:::warning

This nonce-fetching behavior is temporary: a forthcoming update will let the network automatically determine the nonce for a user `nonceKey`.

:::

### Send concurrent transactions with nonce keys

To send multiple transactions in parallel, specify different `nonceKey` values. Each nonce key maintains its own independent sequence:

:::code-group

```ts twoslash [example.ts]
import { Actions } from 'tempo.ts/wagmi'
import { parseUnits } from 'viem'
import { config } from './wagmi.config'

// @noErrors
const account = '0x...' // your sender account
const alphaUsd = '0x20c0000000000000000000000000000000000001'

const [nonce1, nonce2] = await Promise.all([
  Actions.nonce.getNonce(config, { account, nonceKey: 1n }),
  Actions.nonce.getNonce(config, { account, nonceKey: 2n }),
])

// Send both transfers in parallel using different nonce keys
const [hash1, hash2] = await Promise.all([
  Actions.token.transfer(config, {
    amount: parseUnits('100', 6),
    to: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',
    token: alphaUsd,
    nonceKey: 1n, // [!code hl]
    nonce: Number(nonce1), // [!code hl]
  }),
  Actions.token.transfer(config, {
    amount: parseUnits('50', 6),
    to: '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC',
    token: alphaUsd,
    nonceKey: 2n, // [!code hl]
    nonce: Number(nonce2), // [!code hl]
  }),
])

console.log('Transaction 1:', hash1)
console.log('Transaction 2:', hash2)
```

```tsx twoslash [wagmi.config.ts] filename="wagmi.config.ts"
// @noErrors
// [!include ~/snippets/wagmi.config.ts:setup]
```

:::

::::

## Recipes

### Use random nonce keys

For simple cases where you don't need to manage specific keys, use `'random'` to automatically generate a unique nonce key:

:::code-group

```ts twoslash [example.ts]
import { Actions } from 'tempo.ts/wagmi'
import { parseUnits } from 'viem'
import { config } from './wagmi.config'

// @noErrors
// Using 'random' automatically generates a unique nonce key
const hash = await Actions.token.transfer(config, {
  amount: parseUnits('100', 6),
  to: '0x742d35Cc6634C0532925a3b844Bc9e7595f0bEbb',
  token: '0x20c0000000000000000000000000000000000001',
  nonceKey: 'random', // [!code hl]
})

console.log('Transaction hash:', hash)
```

```tsx twoslash [wagmi.config.ts] filename="wagmi.config.ts"
// @noErrors
// [!include ~/snippets/wagmi.config.ts:setup]
```

:::

### Query active nonce keys

Track how many nonce keys your account is using:

:::code-group

```ts [example.ts]
import { client } from './viem.config'

// Get the count of active nonce keys for an account
const count = await client.nonce.getNonceKeyCount({
  account: '0x742d35Cc6634C0532925a3b844Bc9e7595f0bEbb',
})

console.log('Active nonce keys:', count)
```

```ts [viem.config.ts] filename="viem.config.ts"
// [!include ~/snippets/viem.config.ts:setup]
```

:::

## Best Practices

### When to use nonce keys

Use nonce keys when you need to:
- Send multiple independent transactions simultaneously
- Build high-throughput applications that can't wait for sequential confirmations
- Process payments to multiple recipients concurrently

### When to use batch transactions instead

Use [batch transactions](/guide/use-accounts/batch-transactions) instead of nonce keys when:
- Operations need to be atomic
- Calls have sequential dependencies
- You want a single transaction fee for multiple operations

Batch transactions are not as appropriate for the payments to multiple recipients use case, because if a single payment fails, all the calls in the batch transaction roll back.


## Learning Resources

<Card.Container>
  <Card.Link
    description="View nonce actions in the TypeScript SDK"
    href="/sdk/typescript/wagmi/actions/nonce.getNonce"
    icon={LucideCode}
    title="Nonce SDK Documentation"
  />
  <Card.Link
    description="Learn more about transactions on Tempo"
    href="/protocol/transactions"
    icon={LucideSend}
    title="Transactions"
  />
</Card.Container>
