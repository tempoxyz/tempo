import { Callout } from 'vocs/components'
import * as Demo from '../../../components/guides/Demo.tsx'
import * as Step from '../../../components/guides/steps'

# Transfer Memos [Attach payment references to transactions for easy reconciliation.]

Transfer memos let you attach a 32-byte reference to any TIP-20 transfer, mint, or burn operation. Use them to link onchain transactions to your internal records—customer IDs, invoice numbers, payment references, or any identifier that helps you reconcile payments.

## Try it

Send a payment with a memo attached. After sending, check the transaction on the block explorer to see the memo in the `TransferWithMemo` event.

<Demo.Container name="Transfer with Memo" footerVariant="source" src="tempoxyz/tempo-ts/tree/main/examples/payments">
  <Step.Connect stepNumber={1} />
  <Step.AddFunds stepNumber={2} />
  <Step.SendPaymentWithMemo stepNumber={3} last />
</Demo.Container>

## Use cases

### Exchange and on-ramp deposit reconciliation

Exchanges and fiat on-ramps traditionally generate a unique deposit address for each customer. This requires managing thousands of addresses, monitoring each for incoming funds, and sweeping balances—all adding operational complexity and cost.

With transfer memos, you can use a **single deposit address** for all customers. Each customer includes their customer ID as a memo when depositing, and you reconcile by filtering `TransferWithMemo` events:

```ts
// Customer deposits to your single deposit address with their customer ID
await token.write.transferWithMemo([
  depositAddress,           // Your single deposit address
  parseUnits('100', 6),     // Amount
  toHex('CUST-12345', { size: 32 })  // Customer ID as memo
])
```

Watch for deposits and credit the right customer:

```ts
const unwatch = watchContractEvent(client, {
  address: tokenAddress,
  abi: tip20Abi,
  eventName: 'TransferWithMemo',
  onLogs: (logs) => {
    for (const log of logs) {
      if (log.args.to === depositAddress) {
        const customerId = fromHex(log.args.memo, 'string').replace(/\0/g, '')
        creditCustomerAccount(customerId, log.args.value)
      }
    }
  },
})
```

This pattern eliminates per-user address generation, simplifies key management, and reduces monitoring overhead.

### Linking related transactions

When multiple transactions belong to the same business operation, use the same memo to correlate them. This is useful for:

- **Refunds**: Link the original payment and refund transaction with a shared refund ID
- **Multi-leg payments**: Track a stablecoin swap where funds move through an intermediary
- **Batch operations**: Group related transfers under a single reference

**Example: Processing a refund**

```ts
const refundId = toHex('REFUND-7890', { size: 32 })

// Original payment (already on chain with this memo)
// Customer paid: transferWithMemo(merchant, 50 USDC, REFUND-7890)

// Process refund with the same memo
await token.write.transferWithMemo([
  customerAddress,
  parseUnits('50', 6),
  refundId  // Same memo links refund to original payment
])
```

Query all transactions for this refund:

```ts
const logs = await client.getLogs({
  event: parseAbiItem('event TransferWithMemo(address indexed from, address indexed to, uint256 value, bytes32 indexed memo)'),
  args: { memo: refundId },
  fromBlock: startBlock,
})
// Returns both the original payment and the refund transaction
```

**Example: Multi-leg currency exchange**

```ts
const paymentId = toHex('PAY-98765', { size: 32 })

// Leg 1: User sends EURC to exchange
await eurcToken.write.transferWithMemo([
  exchangeAddress,
  parseUnits('100', 6),
  paymentId
])

// Leg 2: Exchange sends USDC to recipient
await usdcToken.write.transferWithMemo([
  recipientAddress,
  parseUnits('108', 6),
  paymentId  // Same memo correlates both legs
])
```

## Memo methods

All TIP-20 tokens support memo variants for core operations:

| Method | Description |
|--------|-------------|
| `transferWithMemo(to, amount, memo)` | Transfer with memo |
| `transferFromWithMemo(from, to, amount, memo)` | Approved transfer with memo |
| `mintWithMemo(to, amount, memo)` | Mint with memo (issuer only) |
| `burnWithMemo(amount, memo)` | Burn with memo (issuer only) |

Each emits a corresponding event (`TransferWithMemo`, `MintWithMemo`, `BurnWithMemo`) with the memo as an indexed parameter for efficient filtering.

<Callout type="info">
Memos are `bytes32` values. Use `toHex(string, { size: 32 })` to convert strings, or pass raw bytes for binary identifiers.
</Callout>

## Next steps

- [Send a payment](/guide/payments/send-a-payment) — Complete payment integration guide
- [Accept a payment](/guide/payments/accept-a-payment) — Watch for incoming payments and reconcile with memos
- [TIP-20 specification](/protocol/tip20/spec) — Full API reference for memo methods
