import { Callout } from 'vocs/components'
import * as Demo from '../../../components/guides/Demo.tsx'
import * as Step from '../../../components/guides/steps'

# Transfer Memos [Attach payment references to transactions for easy reconciliation.]

Transfer memos let you attach a 32-byte reference to any TIP-20 transfer, mint, or burn operation. Use them to link onchain transactions to your internal records—customer IDs, invoice numbers, payment references, or any identifier that helps you reconcile payments.

## Try it

Send a payment with a memo attached. After sending, check the transaction on the block explorer to see the memo in the `TransferWithMemo` event.

<Demo.Container name="Transfer with Memo" footerVariant="source" src="tempoxyz/tempo-ts/tree/main/examples/payments">
  <Step.Connect stepNumber={1} />
  <Step.AddFunds stepNumber={2} />
  <Step.SendPaymentWithMemo stepNumber={3} last />
</Demo.Container>

## Use cases

### Exchange deposit reconciliation

**As an exchange**, you want customers to deposit to a single master hot wallet instead of generating unique addresses per user. Customers call `transferWithMemo` with their customer ID as the memo, and you reconcile deposits in your database.

```ts
// Customer deposits with their customer ID
await token.write.transferWithMemo([
  exchangeHotWallet,        // Single master deposit address
  parseUnits('500', 6),
  toHex('CUST-12345', { size: 32 })  // Customer ID
])
```

Watch for deposits and credit the right account:

```ts
watchContractEvent(client, {
  address: tokenAddress,
  abi: tip20Abi,
  eventName: 'TransferWithMemo',
  onLogs: (logs) => {
    for (const log of logs) {
      const customerId = fromHex(log.args.memo, 'string').replace(/\0/g, '')
      creditCustomerAccount(customerId, log.args.value)
    }
  },
})
```

### Payroll batch payments

**As a payroll provider**, you want to batch multiple payments in a single Tempo transaction while maintaining clear records of which employee received each payment.

```ts
// Batch payroll with employee IDs in memos
const calls = employees.map(emp => ({
  to: tokenAddress,
  data: encodeFunctionData({
    abi: tip20Abi,
    functionName: 'transferWithMemo',
    args: [emp.wallet, parseUnits(emp.salary, 6), toHex(emp.id, { size: 32 })]
  })
}))

await walletClient.sendCalls({ calls })
// One transaction, five transfers, each with clear employee ID for accounting
```

### Refund address in memo

**As a payee**, you want to send a payment but indicate a refund address in case it fails or needs to be reversed.

```ts
// Include refund address in the memo
const refundMemo = toHex('REFUND 0x742d35Cc6634C0532925a3b8', { size: 32 })

await token.write.transferWithMemo([
  merchantAddress,
  parseUnits('100', 6),
  refundMemo  // Merchant knows where to send refund if needed
])
```

## Memo methods

All TIP-20 tokens support memo variants for core operations:

| Method | Description |
|--------|-------------|
| `transferWithMemo(to, amount, memo)` | Transfer with memo |
| `transferFromWithMemo(from, to, amount, memo)` | Approved transfer with memo |
| `mintWithMemo(to, amount, memo)` | Mint with memo (issuer only) |
| `burnWithMemo(amount, memo)` | Burn with memo (issuer only) |

Each emits a corresponding event (`TransferWithMemo`, `MintWithMemo`, `BurnWithMemo`) with the memo as an indexed parameter for efficient filtering.

<Callout type="info">
Memos are `bytes32` values. Use `toHex(string, { size: 32 })` to convert strings, or pass raw bytes for binary identifiers.
</Callout>

## Next steps

- [Send a payment](/guide/payments/send-a-payment) — Complete payment integration guide
- [Accept a payment](/guide/payments/accept-a-payment) — Watch for incoming payments and reconcile with memos
- [TIP-20 specification](/protocol/tip20/spec) — Full API reference for memo methods
