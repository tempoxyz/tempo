import { Callout } from 'vocs/components'


# EVM Differences

Tempo is fully compatible with the Ethereum Virtual Machine (EVM), targeting the **Osaka** EVM hard fork. Developers can deploy and interact with smart contracts using the same tools, languages, and frameworks they use on Ethereum, such as Solidity, Foundry, and Hardhat.

While the execution environment mirrors Ethereum's, Tempo introduces some differences optimized for payments, described below.


### Existing Ethereum Wallet & RPC Compatibility

If you are using a wallet that does not yet support Tempo Transactions, you can integrate with Tempo using standard RPC calls. This is not recommended as it is not as efficient as using Tempo Transactions.

<Callout type="warning">
This integration path is designed for compatibility only and comes with limited functionality. We strongly recommend the native transaction type above for production use.
</Callout>

### JSON-RPC

Tempo supports all Ethereum JSON-RPC methods out of the box. 

### Handling ETH Balance Checks

Many wallets and applications check a user's "native account balance" before letting them complete some action. In this scenario, you might see an error message like "Insufficient balance".

This stems from the return value of the `eth_getBalance` RPC method. When a wallet calls this method, it expects a hex string representing the "native token balance", hard-coded to be represented as an 18-decimal place number.

On Tempo, the `eth_getBalance` method returns a hex string representing an extremely large number. Specifically it returns: `0x9612084f0316e0ebd5182f398e5195a51b5ca47667d4c9b26c9b26c9b26c9b2` which is represented in decimals as 4.242424242424242e+75.

Our recommendation to wallets and to applications using this method is to remove this balance check, and to not represent any "native balance" in your user's UI. This will allow users to complete actions without being blocked by balance checks.

| Feature | Behavior on Tempo |
|---------|-------------------|
| **`eth_balance` RPC calls** | Return `424242424242...` for compatibility (no meaningful balance) |
| **`BALANCE` and `SELFBALANCE` opcodes** | Do not return native token balance (use TIP-20 `balanceOf` instead) |
| **Transaction fees** | Paid in supported USD-denominated TIP-20 tokens |


### Specifying a Native Token Currency Symbol

Sometimes wallets will need to specify the currency symbol for the native token. On Tempo, there is no native token, but fees are denominated in USD. So, we recommend using the currency symbol "USD".

### Default Fee Token

Since there is no native token, Tempo has implemented a cascading system of preferences for what the "default" is when submitting a regular Ethereum transaction type. This preference system is specified [here](/documentation/protocol/fees/spec-fee#fee-token-preferences) in detail, but in this scenario we can focus specifically on how defaults get set for regular Ethereum transaction types where there is no user preference set.

There are two cases to consider.

#### **TIP-20 Tokens**

If the user is calling a method on a TIP-20 token (e.g., `transfer`), the default fee token is that token itself. For example, if the user is calling the `transfer` method on a TIP-20 token with a symbol of "USDC", the default fee token would be "USDC".

Importantly, note that the `amount` field in this case is sent in full. So, if the user is calling the `transfer` method on a TIP-20 token with a symbol of "USDC" with the `amount` field set to 1000, the full amount of the token will be transferred **and** the sender's balance will be reduced by the amount spent in fees. So, the recipient will receive 1000 USDC.

#### **Other Contracts**

However, if the user is calling a contract that is not a TIP-20 token, the transaction will fail.

If a wallet wants to submit a non-TIP20 transaction without having to submit the above transaction, we recommend investing in using [Tempo Transactions](/guide/quickstart/integrate-tempo#tempo-transactions) instead.

## Consensus & Finality

Tempo uses **Simplex BFT consensus** with a permissioned validator set at launch, providing deterministic finality in approximately 06 seconds, unlike Ethereum's finality gadget which takes approximately 12 minutes.

Block times are  targeted at ~0.5 seconds compared to Ethereum's ~12 second slots.



