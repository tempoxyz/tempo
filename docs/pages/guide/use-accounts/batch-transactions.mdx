import { Callout } from 'vocs/components'

# Batch Transactions

One of the most powerful features of the [Tempo Transaction](/protocol/transactions/spec-tempo-transaction) type is batching multiple operations into a single transaction. This allows you to execute several actions atomically (i.e., they all succeed or all fail together). This helps reduce gas costs, prevents partial failures, and creates better user experiences by combining multiple steps into one transaction.

<Callout type="info">
  Batch transactions are a feature of Tempo's [TempoTransaction type](/protocol/transactions/spec-tempo-transaction). See the TempoTransaction spec for complete details on batching and other features.
</Callout>

## Example: Sending a Batch of Transactions

:::code-group
```ts [batchTransactions.ts]
const { address, hash, id } = await client.sendTransaction({ // [!code focus]
  calls: [{ // [!code focus]
    to: tokenAddress, // [!code focus]
    data: transferCalldata // Transfer tokens // [!code focus]
  }, // [!code focus]
  { // [!code focus]
    to: anotherTokenAddress,  // [!code focus]
    data: approveCalldata // Approve spending // [!code focus]
  }, // [!code focus]
  { // [!code focus]
    to: dexAddress, // [!code focus]
    data: swapCalldata // Execute swap // [!code focus]
  }], // [!code focus]
}) // [!code focus]
```

```ts [viem.config.ts]
// [!include ~/snippets/setup.ts:setup] 
```
:::

## How It Works

Unlike traditional EVM transactions which only support a single call per transaction, the [Tempo Transaction](/protocol/transactions/spec-tempo-transaction) type natively supports a `calls` vector—enabling multiple operations in a single atomic transaction.

### Native Protocol Support

Batching is built directly into the transaction type at the protocol level. This means:

- **Atomic execution**: All calls succeed or all calls revert together—no partial failures
- **Single signature**: Sign once for the entire batch, reducing UX friction
- **Lower gas costs**: Avoid the overhead of multiple transaction submissions
- **No smart contract required**: Works with any EOA, no need to deploy a separate batching contract

### Transaction Structure

The `TempoTransaction` includes a `calls` field that accepts a list of operations:

```rust
pub struct TempoTransaction {
    // Standard EIP-1559 fields
    chain_id: ChainId,                          // EIP-155 replay protection
    max_priority_fee_per_gas: u128,
    max_fee_per_gas: u128,
    gas_limit: u64,
    calls: Vec<Call>,                           // Batch of calls to execute atomically // [!code highlight]
    access_list: AccessList,                    // EIP-2930 access list

    // AA-specific fields
    nonce_key: U256,                            // 2D nonce key (0 = protocol nonce, >0 = user nonces)
    nonce: u64,                                 // Current nonce value for the nonce key

    // Optional features
    fee_token: Option<Address>,                 // Optional fee token preference
    fee_payer_signature: Option<Signature>,     // Sponsored transactions (secp256k1 only)
    valid_before: Option<u64>,                  // Transaction expiration timestamp
    valid_after: Option<u64>,                   // Transaction can only be included after this timestamp
    key_authorization: Option<SignedKeyAuthorization>, // Access key authorization (optional)
    aa_authorization_list: Vec<TempoSignedAuthorization>, // EIP-7702 style authorizations with AA signatures
}

// Call structure for batching // [!code highlight]
pub struct Call { // [!code highlight]
    to: TxKind,      // Can be Address or Create // [!code highlight]
    value: U256, // [!code highlight]
    input: Bytes     // Calldata for the call // [!code highlight]
} // [!code highlight]
```

