import { Callout } from 'vocs/components'

# Fee AMM Specification

## Abstract

This specification defines a system of one-way Automated Market Makers (AMMs) designed to facilitate gas fee payments from a user using one stablecoin (the `userToken`) to a validator who prefers a different stablecoin (the `validatorToken`). Each AMM handles fee swaps from a `userToken` to a `validatorToken` at one price (0.9970 `validatorToken` per `userToken`), and allows rebalancing in the other direction at another fixed price (0.9985 `validatorToken` per `userToken`).

## Motivation

Current blockchain fee systems typically require users to hold native tokens for gas payments. This creates friction for users who prefer to transact in stablecoins.

The Fee AMM is a dedicated AMM for trading between stablecoins, which can only be used by the protocol (and by arbitrageurs rebalancing it to keep it balanced). The protocol automatically collects fees and executes fee swaps during pre-transaction processing, converting user tokens to validator tokens at a fixed rate.

## Specification

### Overview

The Fee AMM implements two distinct swap mechanisms:

1. **Fee Swaps**: Fixed-rate swaps at a price of `0.9970` (validator token per user token) from `userToken` to `validatorToken`
2. **Rebalancing Swaps**: Fixed-rate swaps at a price of `0.9985` (validator token per user token) from `validatorToken` to `userToken`

### Core Components

#### 1. FeeAMM Contract

The primary AMM contract managing liquidity pools and swap operations.

##### Pool Structure
```solidity
struct Pool {
    uint128 reserveUserToken;           // Reserve of userToken
    uint128 reserveValidatorToken;      // Reserve of validatorToken
}
```

Each pool is directional: `userToken` â†’ `validatorToken`. For a pair of tokens A and B, there are two separate pools:
- Pool(A, B): for swapping A to B at fixed rate of 0.997 (fee swaps) and B to A at fixed rate of 0.9985 (rebalancing)
- Pool(B, A): for swapping B to A at fixed rate of 0.997 (fee swaps) and A to B at fixed rate of 0.9985 (rebalancing)

##### Constants
- `M = 9970` (scaled by 10000, representing 0.9970)
- `N = 9985` (scaled by 10000, representing 0.9985)
- `SCALE = 10000`
- `MIN_LIQUIDITY = 1000`

##### Key Functions

```solidity
function getPool(
    address userToken,
    address validatorToken
) external view returns (Pool memory)
```

Returns the pool structure for a given token pair.

```solidity
function getPoolId(
    address userToken,
    address validatorToken
) external pure returns (bytes32)
```

Returns the pool ID for a given token pair (used internally for pool lookup).

```solidity
function rebalanceSwap(
    address userToken,
    address validatorToken,
    uint256 amountOut,
    address to
) external returns (uint256 amountIn)
```

Executes rebalancing swaps from `validatorToken` to `userToken` at fixed rate of 0.9985 (validator token per user token). Can be executed by anyone. Calculates `amountIn = (amountOut * N) / SCALE + 1` (rounds up). Updates reserves immediately. Emits `RebalanceSwap` event.

```solidity
function mint(
    address userToken,
    address validatorToken,
    uint256 amountUserToken,
    uint256 amountValidatorToken,
    address to
) external returns (uint256 liquidity)
```

Adds liquidity to a pool with both tokens. First provider sets initial reserves and must burn `MIN_LIQUIDITY` tokens. Subsequent providers must provide proportional amounts. Receives fungible LP tokens representing pro-rata share of pool reserves.

```solidity
function mintWithValidatorToken(
    address userToken,
    address validatorToken,
    uint256 amountValidatorToken,
    address to
) external returns (uint256 liquidity)
```

Single-sided liquidity provision with validator token only. Treats the deposit as equivalent to performing a hypothetical `rebalanceSwap` first at rate `n = 0.9985` until the ratio of reserves match, then minting liquidity by depositing both. Formula: `liquidity = amountValidatorToken * _totalSupply / (V + n * U)`, where `n = N / SCALE`. Rounds down to avoid over-issuing LP tokens. Updates reserves by increasing only `validatorToken` by `amountValidatorToken`. Emits `Mint` event with `amountUserToken = 0`.

```solidity
function burn(
    address userToken,
    address validatorToken,
    uint256 liquidity,
    address to
) external returns (uint256 amountUserToken, uint256 amountValidatorToken)
```

Burns LP tokens and receives pro-rata share of reserves. Emits `Burn` event.

```solidity
function executeFeeSwap(
    address userToken,
    address validatorToken,
    uint256 amountIn
) internal returns (uint256 amountOut)
```

Executes a fee swap, converting `userToken` to `validatorToken` at the fixed rate m = 0.9970. Called by `FeeManager.collectFeePreTx` during pre-transaction fee collection. Calculates `amountOut = (amountIn * M) / SCALE`. Reverts if insufficient liquidity. Updates reserves immediately. Access: Internal only (called by FeeManager).

#### 2. FeeManager Contract

Tempo introduces a precompiled contract, the `FeeManager`, at the address `0xfeec000000000000000000000000000000000000`.

The `FeeManager` is a singleton contract that implements all the functions of the Fee AMM for every pool. It also handles the collection and accounting of fees during each transaction, stores fee token preferences for users and validators, and maintains fee balances per validator that can be collected at any time.

##### Key Functions

```solidity
function setUserToken(address token) external
```

Sets the default fee token preference for the caller (user). Requires token to be a USD TIP-20 token. Emits `UserTokenSet` event. Access: Direct calls only (not via delegatecall).

```solidity
function setValidatorToken(address token) external
```

Sets the fee token preference for the caller (validator). Requires token to be a USD TIP-20 token. Cannot be called during a block built by that validator. Emits `ValidatorTokenSet` event. Access: Direct calls only (not via delegatecall).

```solidity
function collectFeePreTx(
    address user,
    address userToken,
    uint256 maxAmount
) external
```

Called by the protocol before transaction execution. The fee token (`userToken`) is determined by the protocol before calling using logic that considers: explicit tx fee token, setUserToken calls, stored user preference, tx.to if TIP-20. Collects the maximum fee from the user using `transferFeePreTx`. If user token differs from validator token, executes the fee swap via `executeFeeSwap` and adds the output to the validator's fee balance. If tokens match, adds `maxAmount` directly to the validator's fee balance. Access: Protocol only (`msg.sender == address(0)`).

```solidity
function distributeFees(address validator) external
```

Allows anyone to trigger the transfer of accumulated fees to a validator. Transfers the validator's fee balance (in their preferred token) to their address. Emits `FeesDistributed` event. Access: Anyone.

```solidity
function collectedFeesByValidator(address validator) external view returns (uint256)
```

Returns the accumulated fee balance for a validator that has not yet been collected.

### Swap Mechanisms

#### Fee Swaps
- **Rate**: Fixed at m=0.9970 (validator receives 0.9970 of their preferred token per 1 user token that user pays)
- **Direction**: User token to validator token
- **Purpose**: Convert tokens paid by users as fees to tokens preferred by validators
- **Settlement**: Immediate during `collectFeePreTx`
- **Access**: Protocol only

#### Rebalancing Swaps
- **Rate**: Fixed at n=0.9985 (swapper receives 1 of the user token for every 0.9985 that they put in of the validator's preferred token)
- **Direction**: Validator token to user token
- **Purpose**: Refill reserves of validator token in the pool
- **Settlement**: Immediate
- **Access**: Anyone

### Fee Collection Flow

1. **Pre-Transaction**:
   - Protocol determines user's fee token using logic that considers: explicit tx fee token, setUserToken calls, stored user preference, tx.to if TIP-20
   - Protocol calculates maximum gas needed (`maxAmount = gasLimit * maxFeePerGas`)
   - `FeeManager.collectFeePreTx(user, userToken, maxAmount)` is called:
     - Collects maximum fee from user using `transferFeePreTx()`
     - If user token differs from validator token, executes fee swap via `executeFeeSwap()`
     - Adds fee amount (in validator's token) to the validator's fee balance
   - If any check fails (insufficient balance, insufficient liquidity), transaction is invalid

2. **Fee Distribution**:
   - Validators (or anyone on their behalf) can call `distributeFees(validator)` at any time
   - Transfers the validator's accumulated fee balance to their address
   - Emits `FeesDistributed` event

### Events

```solidity
event RebalanceSwap(
    address indexed userToken,
    address indexed validatorToken,
    address indexed swapper,
    uint256 amountIn,
    uint256 amountOut
)
event Mint(
    address indexed sender,
    address indexed userToken,
    address indexed validatorToken,
    uint256 amountUserToken,
    uint256 amountValidatorToken,
    uint256 liquidity
)
event Burn(
    address indexed sender,
    address indexed userToken,
    address indexed validatorToken,
    uint256 amountUserToken,
    uint256 amountValidatorToken,
    uint256 liquidity,
    address to
)
event UserTokenSet(address indexed user, address indexed token)
event ValidatorTokenSet(address indexed validator, address indexed token)
event FeesDistributed(address indexed validator, address indexed token, uint256 amount)
```

`Transfer` events are emitted as usual for transactions, with the exception of paying gas fees via TIP20 tokens. For fee payments, a single `Transfer` event is emitted post execution to represent the actual fee amount consumed (i.e. `gasUsed * gasPrice`).

### Gas

Fee swaps are designed to be gas-free from the user perspective. The pre-tx step in each transaction does not cost any gas.
