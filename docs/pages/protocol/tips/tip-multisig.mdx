---
title: TIP-XXXX Multisig Precompile
description: Native multisig wallets as precompiles with deterministic addressing, M-of-N confirmation thresholds, and on-chain transaction execution.
---

# Multisig Precompile

This document specifies a native multisig system implemented as precompiles on Tempo, enabling M-of-N multi-signature wallets with deterministic addressing.

- **TIP ID**: TIP-XXXX
- **Authors/Owners**: Tempo Team
- **Status**: Draft
- **Related Specs/TIPs**: [TIP-20](/protocol/tip20/spec), [TIP-20 Factory](/protocol/tip20/overview)

---

# Overview

## Abstract

This TIP introduces two precompiles: a **Multisig Factory** that creates multisig wallets at deterministic addresses, and a **Multisig** precompile that manages M-of-N transaction confirmations and execution. Multisig addresses are derived from a hash of the owner list and threshold, enabling address prediction before deployment.

## Motivation

Multi-signature wallets are essential for secure asset management, requiring multiple parties to approve transactions before execution. Current solutions require deploying smart contracts, which:

1. **Lack deterministic addressing**: Wallet addresses cannot be predicted from configuration alone
2. **Incur deployment costs**: Each multisig requires a contract deployment
3. **Fragment liquidity**: TIP-20 tokens held in contract wallets behave differently than precompile-based accounts

By implementing multisig as a precompile:

- **Deterministic addresses**: Given owners and threshold, the address is predictable and consistent
- **Native integration**: Multisig wallets work seamlessly with TIP-20 tokens and other precompiles
- **Lower costs**: No contract deployment required; only factory interaction
- **Standardized interface**: All multisigs share the same well-audited logic

---

# Specification

## Constants and Limits

| Constant | Value | Rationale |
|----------|-------|-----------|
| `MAX_OWNERS` | 50 | Prevents gas DoS on confirmation loops |
| `MAX_DATA_SIZE` | 65536 (64KB) | Bounds storage and execution costs |
| `DEFAULT_EXPIRY` | 30 days | Prevents stale transaction execution |

## Address Scheme

### Multisig Factory Address

The Multisig Factory is deployed at a fixed precompile address:

```
0xF15C000000000000000000000000000000000000
```

The `F15C` prefix is derived from "mUltiSig" → hex representation mnemonic.

### Multisig Address Derivation

Multisig addresses use a dedicated prefix and deterministic derivation. To prevent birthday-attack collisions, we use 16 bytes of the hash (128 bits of entropy):

```
MULTISIG_PREFIX (4 bytes) || keccak256(owners, threshold)[0:16] (16 bytes)
```

Where:
- `MULTISIG_PREFIX` = `0xF15C0000` (4 bytes)
- `owners` = sorted array of owner addresses (ascending order)
- `threshold` = required number of confirmations (uint8)

```solidity
function computeMultisigAddress(address[] memory owners, uint8 threshold) pure returns (address) {
    // Sort owners ascending to ensure deterministic address
    address[] memory sorted = sortAscending(owners);
    bytes32 hash = keccak256(abi.encode(sorted, threshold));
    
    bytes20 addr;
    addr[0:4] = MULTISIG_PREFIX;   // 4 bytes prefix
    addr[4:20] = hash[0:16];       // 16 bytes from hash (128-bit collision resistance)
    
    return address(addr);
}
```

> **Security Note**: Using 16 bytes (128 bits) of the hash provides birthday-attack resistance of ~2^64 operations, making collision attacks computationally infeasible.

### Reserved Addresses

The first 1024 addresses in the multisig address space are reserved for protocol use:

```
0xF15C000000000000000000000000000000000000 - Factory
0xF15C000000000000000000000000000000000001 - Reserved
...
0xF15C0000000000000000000000000000000003FF - Reserved
```

---

## Multisig Factory Interface

```solidity
interface IMultisigFactory {
    /// @notice Emitted when a new multisig wallet is created
    /// @param multisig The address of the created multisig
    /// @param owners Array of owner addresses (sorted ascending)
    /// @param threshold Number of required confirmations
    event MultisigCreated(
        address indexed multisig,
        address[] owners,
        uint8 threshold
    );

    /// @notice The computed address falls in the reserved range
    error AddressReserved();

    /// @notice A multisig already exists at this address
    error MultisigAlreadyExists(address multisig);

    /// @notice Invalid threshold (zero, or greater than owner count)
    error InvalidThreshold(uint8 threshold, uint8 ownerCount);

    /// @notice Owner list is empty
    error NoOwners();

    /// @notice Too many owners (exceeds MAX_OWNERS)
    error TooManyOwners(uint8 count, uint8 max);

    /// @notice Duplicate owner in the list
    error DuplicateOwner(address owner);

    /// @notice Zero address in owner list
    error ZeroAddressOwner();

    /// @notice Creates a new multisig wallet
    /// @param owners Array of owner addresses (will be sorted internally, max 50)
    /// @param threshold Number of required confirmations (1 <= threshold <= owners.length)
    /// @return multisig The address of the created multisig
    function createMultisig(
        address[] calldata owners,
        uint8 threshold
    ) external returns (address multisig);

    /// @notice Computes the deterministic address for a multisig configuration
    /// @param owners Array of owner addresses
    /// @param threshold Number of required confirmations
    /// @return The address where the multisig would be deployed
    function getMultisigAddress(
        address[] calldata owners,
        uint8 threshold
    ) external pure returns (address);

    /// @notice Checks if an address is a deployed multisig
    /// @param addr The address to check
    /// @return True if the address is a valid, deployed multisig
    function isMultisig(address addr) external view returns (bool);
}
```

### Factory Behavior

#### `createMultisig`

1. Validate inputs:
   - Revert with `NoOwners` if `owners.length == 0`
   - Revert with `TooManyOwners` if `owners.length > MAX_OWNERS` (50)
   - Revert with `ZeroAddressOwner` if any owner is `address(0)`
   - Revert with `DuplicateOwner` if any owner appears twice
   - Revert with `InvalidThreshold` if `threshold == 0` or `threshold > owners.length`

2. Sort owners in ascending order

3. Compute the deterministic address

4. Check address validity:
   - Revert with `AddressReserved` if address is in reserved range
   - Revert with `MultisigAlreadyExists` if multisig already deployed

5. Initialize the multisig at the computed address with:
   - Sorted owner list
   - Threshold value
   - Empty transaction queue

6. Emit `MultisigCreated` event

7. Return the multisig address

---

## Multisig Interface

```solidity
interface IMultisig {
    /// @notice A transaction has been submitted for confirmation
    /// @param txId The transaction ID
    /// @param proposer The address that submitted the transaction
    /// @param to Target address for the transaction
    /// @param value TIP-20 token address and amount (encoded)
    /// @param data Calldata for the transaction
    /// @param expiresAt Timestamp after which the transaction cannot be executed
    event TransactionSubmitted(
        uint256 indexed txId,
        address indexed proposer,
        address indexed to,
        bytes value,
        bytes data,
        uint256 expiresAt
    );

    /// @notice An owner has confirmed a transaction
    /// @param txId The transaction ID
    /// @param owner The confirming owner
    /// @param confirmationCount Current number of confirmations
    event TransactionConfirmed(
        uint256 indexed txId,
        address indexed owner,
        uint8 confirmationCount
    );

    /// @notice An owner has revoked their confirmation
    /// @param txId The transaction ID
    /// @param owner The owner who revoked
    /// @param confirmationCount Current number of confirmations
    event ConfirmationRevoked(
        uint256 indexed txId,
        address indexed owner,
        uint8 confirmationCount
    );

    /// @notice A transaction has been executed
    /// @param txId The transaction ID
    /// @param executor The address that triggered execution
    event TransactionExecuted(
        uint256 indexed txId,
        address indexed executor
    );

    /// @notice A transaction has been cancelled
    /// @param txId The transaction ID
    /// @param canceller The owner who initiated cancellation
    event TransactionCancelled(
        uint256 indexed txId,
        address indexed canceller
    );

    /// @notice Caller is not an owner
    error NotOwner(address caller);

    /// @notice Transaction does not exist
    error TransactionNotFound(uint256 txId);

    /// @notice Transaction already executed
    error TransactionAlreadyExecuted(uint256 txId);

    /// @notice Transaction has been cancelled
    error TransactionCancelled(uint256 txId);

    /// @notice Transaction has expired
    error TransactionExpired(uint256 txId, uint256 expiresAt, uint256 currentTime);

    /// @notice Owner has already confirmed this transaction
    error AlreadyConfirmed(uint256 txId, address owner);

    /// @notice Owner has not confirmed this transaction
    error NotConfirmed(uint256 txId, address owner);

    /// @notice Transaction does not have enough confirmations
    error InsufficientConfirmations(uint256 txId, uint8 have, uint8 need);

    /// @notice Transaction execution failed
    error ExecutionFailed(uint256 txId, bytes returnData);

    /// @notice Transaction data exceeds maximum size
    error DataTooLarge(uint256 size, uint256 max);

    /// @notice Invalid value encoding (must be empty or abi.encode(address, uint256))
    error InvalidValueEncoding();

    /// @notice Reentrancy detected
    error ReentrancyGuard();

    /// @notice Returns the list of owners
    function owners() external view returns (address[] memory);

    /// @notice Returns the confirmation threshold
    function threshold() external view returns (uint8);

    /// @notice Returns the current transaction count (next txId)
    function transactionCount() external view returns (uint256);

    /// @notice Returns transaction details
    /// @param txId The transaction ID
    /// @return to Target address
    /// @return value Encoded token transfer (token address + amount), or empty for pure calls
    /// @return data Calldata
    /// @return executed Whether the transaction has been executed
    /// @return cancelled Whether the transaction has been cancelled
    /// @return confirmations Number of confirmations
    /// @return expiresAt Timestamp after which the transaction cannot be executed
    function getTransaction(uint256 txId) external view returns (
        address to,
        bytes memory value,
        bytes memory data,
        bool executed,
        bool cancelled,
        uint8 confirmations,
        uint256 expiresAt
    );

    /// @notice Returns whether an owner has confirmed a transaction
    /// @param txId The transaction ID
    /// @param owner The owner address
    function isConfirmedBy(uint256 txId, address owner) external view returns (bool);

    /// @notice Returns addresses that have confirmed a transaction
    /// @param txId The transaction ID
    function getConfirmations(uint256 txId) external view returns (address[] memory);

    /// @notice Submits a new transaction for confirmation
    /// @dev Also counts as a confirmation from msg.sender. Validates value encoding.
    /// @param to Target address
    /// @param value Encoded token transfer: abi.encode(tokenAddress, amount), or empty bytes
    /// @param data Calldata for the transaction (max 64KB)
    /// @return txId The ID of the submitted transaction
    function submitTransaction(
        address to,
        bytes calldata value,
        bytes calldata data
    ) external returns (uint256 txId);

    /// @notice Submits a new transaction with custom expiry
    /// @param to Target address
    /// @param value Encoded token transfer: abi.encode(tokenAddress, amount), or empty bytes
    /// @param data Calldata for the transaction (max 64KB)
    /// @param expiresAt Timestamp after which the transaction cannot be executed
    /// @return txId The ID of the submitted transaction
    function submitTransactionWithExpiry(
        address to,
        bytes calldata value,
        bytes calldata data,
        uint256 expiresAt
    ) external returns (uint256 txId);

    /// @notice Confirms a pending transaction
    /// @param txId The transaction ID to confirm
    function confirmTransaction(uint256 txId) external;

    /// @notice Revokes a confirmation for a pending transaction
    /// @param txId The transaction ID
    function revokeConfirmation(uint256 txId) external;

    /// @notice Cancels a pending transaction (requires threshold confirmations to cancel)
    /// @dev Creates a cancellation "meta-transaction" that owners must confirm
    /// @param txId The transaction ID to cancel
    function cancelTransaction(uint256 txId) external;

    /// @notice Executes a transaction that has sufficient confirmations
    /// @dev Only callable by owners. Reverts on execution failure.
    /// @param txId The transaction ID to execute
    function executeTransaction(uint256 txId) external;

    /// @notice Submits, confirms, and executes a transaction in one call
    /// @dev Only works if threshold == 1, otherwise reverts
    /// @param to Target address
    /// @param value Encoded token transfer
    /// @param data Calldata
    function execute(
        address to,
        bytes calldata value,
        bytes calldata data
    ) external;

    // ============ Owner Management ============

    /// @notice Adds a new owner to the multisig
    /// @dev Requires threshold confirmations. Reverts if owner already exists or MAX_OWNERS reached.
    /// @param owner The address to add as owner
    function addOwner(address owner) external;

    /// @notice Removes an owner from the multisig
    /// @dev Requires threshold confirmations. Reverts if owner doesn't exist or would make threshold > ownerCount.
    /// @param owner The address to remove
    function removeOwner(address owner) external;

    /// @notice Replaces an existing owner with a new address
    /// @dev Requires threshold confirmations. Atomic swap to avoid temporary threshold issues.
    /// @param oldOwner The owner to remove
    /// @param newOwner The owner to add
    function replaceOwner(address oldOwner, address newOwner) external;

    /// @notice Changes the confirmation threshold
    /// @dev Requires threshold confirmations. Reverts if newThreshold is 0 or > ownerCount.
    /// @param newThreshold The new threshold value
    function changeThreshold(uint8 newThreshold) external;
}
```

### Owner Management Events and Errors

```solidity
/// @notice An owner was added to the multisig
event OwnerAdded(address indexed owner);

/// @notice An owner was removed from the multisig
event OwnerRemoved(address indexed owner);

/// @notice An owner was replaced with another address
event OwnerReplaced(address indexed oldOwner, address indexed newOwner);

/// @notice The confirmation threshold was changed
event ThresholdChanged(uint8 oldThreshold, uint8 newThreshold);

/// @notice The address is already an owner
error AlreadyOwner(address owner);

/// @notice Cannot remove: would make threshold > owner count
error ThresholdExceedsOwners(uint8 threshold, uint8 newOwnerCount);

/// @notice Cannot have zero owners
error CannotRemoveLastOwner();
```

### Transaction Structure

Transactions are stored with the following data:

```solidity
struct Transaction {
    address to;           // Target address
    bytes value;          // Encoded: abi.encode(address token, uint256 amount) or empty
    bytes data;           // Calldata to execute (max 64KB)
    bool executed;        // Has been executed
    bool cancelled;       // Has been cancelled
    uint8 confirmations;  // Current confirmation count
    uint256 expiresAt;    // Timestamp after which execution is blocked
}
```

The `value` field encodes a TIP-20 transfer:
- Empty bytes (`0x`): No token transfer, just a call
- `abi.encode(token, amount)`: Transfer `amount` of `token` to `to` before executing `data`
- Any other encoding: **Invalid**, reverts with `InvalidValueEncoding` at submission time

### Multisig Behavior

#### `submitTransaction`

1. Revert with `NotOwner` if `msg.sender` is not an owner
2. Revert with `DataTooLarge` if `data.length > MAX_DATA_SIZE` (64KB)
3. Validate `value` encoding:
   - If `value.length == 0`: valid (no token transfer)
   - If `value.length == 64`: valid (abi.encode(address, uint256))
   - Otherwise: revert with `InvalidValueEncoding`
4. Create transaction with `txId = transactionCount++`
5. Set `expiresAt = block.timestamp + DEFAULT_EXPIRY` (30 days)
6. Store transaction data
7. Auto-confirm for `msg.sender`
8. Emit `TransactionSubmitted` and `TransactionConfirmed`
9. Return `txId`

#### `submitTransactionWithExpiry`

Same as `submitTransaction`, but:
- Uses provided `expiresAt` instead of default
- `expiresAt` must be in the future (`> block.timestamp`)

#### `confirmTransaction`

1. Revert with `NotOwner` if `msg.sender` is not an owner
2. Revert with `TransactionNotFound` if transaction doesn't exist
3. Revert with `TransactionAlreadyExecuted` if already executed
4. Revert with `TransactionCancelled` if cancelled
5. Revert with `TransactionExpired` if `block.timestamp > expiresAt`
6. Revert with `AlreadyConfirmed` if already confirmed by sender
7. Record confirmation and increment count
8. Emit `TransactionConfirmed`

#### `revokeConfirmation`

1. Revert with `NotOwner` if `msg.sender` is not an owner
2. Revert with `TransactionNotFound` if transaction doesn't exist
3. Revert with `TransactionAlreadyExecuted` if already executed
4. Revert with `TransactionCancelled` if cancelled
5. Revert with `NotConfirmed` if sender hasn't confirmed
6. Remove confirmation and decrement count
7. Emit `ConfirmationRevoked`

#### `cancelTransaction`

Cancellation requires threshold confirmations, similar to execution:

1. Revert with `NotOwner` if `msg.sender` is not an owner
2. Revert with `TransactionNotFound` if transaction doesn't exist
3. Revert with `TransactionAlreadyExecuted` if already executed
4. Revert with `TransactionCancelled` if already cancelled
5. Record cancellation vote from `msg.sender`
6. If cancellation votes >= threshold:
   - Set `cancelled = true`
   - Emit `TransactionCancelled`

> **Note**: Cancellation uses a separate vote count from confirmation. An owner can confirm a transaction AND vote to cancel it (allowing them to change their mind).

#### `executeTransaction`

1. Revert with `NotOwner` if `msg.sender` is not an owner
2. Revert with `ReentrancyGuard` if already in execution context
3. Revert with `TransactionNotFound` if transaction doesn't exist
4. Revert with `TransactionAlreadyExecuted` if already executed
5. Revert with `TransactionCancelled` if cancelled
6. Revert with `TransactionExpired` if `block.timestamp > expiresAt`
7. Revert with `InsufficientConfirmations` if `confirmations < threshold`
8. Set reentrancy guard
9. Mark as executed
10. If `value` is non-empty:
    - Decode `(token, amount)` from `value`
    - Transfer `amount` of `token` from multisig to `to`
11. If `data` is non-empty:
    - Execute `to.call(data)` with multisig as `msg.sender`
12. Clear reentrancy guard
13. Emit `TransactionExecuted`
14. Revert with `ExecutionFailed` if the call failed

> **Security Note**: Only owners can trigger execution. This prevents MEV attacks where attackers front-run or sandwich multisig transactions.

#### `execute`

Convenience function for 1-of-1 multisigs only:

1. Revert if `threshold != 1`
2. Submit transaction (which auto-confirms)
3. Execute immediately (since 1 confirmation = threshold)
4. Revert with `ExecutionFailed` if execution fails

---

### Owner Management Behavior

Owner management functions use the same confirmation pattern as regular transactions. Each function internally creates a "config change" transaction that owners must confirm.

#### `addOwner`

1. Revert with `NotOwner` if `msg.sender` is not an owner
2. Revert with `ZeroAddressOwner` if `owner` is `address(0)`
3. Revert with `AlreadyOwner` if `owner` is already an owner
4. Revert with `TooManyOwners` if `ownerCount >= MAX_OWNERS`
5. Create config-change transaction for adding owner
6. Auto-confirm for `msg.sender`
7. If confirmations >= threshold:
   - Add owner to owners array (maintain sorted order)
   - Increment `ownerCount`
   - Emit `OwnerAdded`

#### `removeOwner`

1. Revert with `NotOwner` if `msg.sender` is not an owner
2. Revert with `NotOwner` if `owner` is not in owners list
3. Revert with `CannotRemoveLastOwner` if `ownerCount == 1`
4. Revert with `ThresholdExceedsOwners` if `threshold > ownerCount - 1`
5. Create config-change transaction for removing owner
6. Auto-confirm for `msg.sender`
7. If confirmations >= threshold:
   - Remove owner from owners array
   - Decrement `ownerCount`
   - Emit `OwnerRemoved`

> **Note**: If the removed owner had pending confirmations, those confirmations remain valid. However, they can no longer confirm new transactions or execute.

#### `replaceOwner`

1. Revert with `NotOwner` if `msg.sender` is not an owner
2. Revert with `NotOwner` if `oldOwner` is not in owners list
3. Revert with `ZeroAddressOwner` if `newOwner` is `address(0)`
4. Revert with `AlreadyOwner` if `newOwner` is already an owner
5. Create config-change transaction for replacement
6. Auto-confirm for `msg.sender`
7. If confirmations >= threshold:
   - Replace `oldOwner` with `newOwner` in owners array (maintain sorted order)
   - Emit `OwnerReplaced`

> **Note**: `replaceOwner` is atomic - it never temporarily reduces owner count, avoiding threshold validation edge cases.

#### `changeThreshold`

1. Revert with `NotOwner` if `msg.sender` is not an owner
2. Revert with `InvalidThreshold` if `newThreshold == 0`
3. Revert with `InvalidThreshold` if `newThreshold > ownerCount`
4. Create config-change transaction for threshold change
5. Auto-confirm for `msg.sender`
6. If confirmations >= threshold (using **current** threshold):
   - Update threshold to `newThreshold`
   - Emit `ThresholdChanged`

> **Security Note**: Threshold changes use the **current** threshold for confirmation, not the new one. This prevents a single owner from reducing threshold to 1 and taking over.

---

## Storage Layout

### Multisig Factory Storage

```
Slot 0: initialized (bool)
```

No additional storage needed; all validation is stateless.

### Multisig Storage

Each multisig uses the following storage layout at its deterministic address:

```
Slot 0: initialized (bool) | locked (bool, reentrancy guard)
Slot 1: threshold (uint8)
Slot 2: ownerCount (uint8)
Slot 3: transactionCount (uint256)

Owners array (starting at keccak256("owners")):
  Slot hash + i: owner[i] (address)

Transactions mapping (at keccak256("transactions", txId)):
  +0: to (address)
  +1: expiresAt (uint256)
  +2: value length + first 24 bytes
  +3+: value continuation (if needed)
  +N: data length + bytes
  +N+1: executed (bool) | cancelled (bool) | confirmations (uint8)

Confirmations mapping (at keccak256("confirmations", txId, owner)):
  bool confirmed

Cancellation votes mapping (at keccak256("cancellations", txId, owner)):
  bool votedToCancel

Cancellation count (at keccak256("cancellationCount", txId)):
  uint8 count
```

---

## TIP-20 Integration

Multisig wallets can hold and transfer TIP-20 tokens:

1. **Receiving tokens**: Any TIP-20 can be transferred to a multisig address
2. **Sending tokens**: Owners submit a transaction with `value = abi.encode(token, amount)`
3. **Calling token functions**: Use `data` field to call `approve`, `transfer`, etc.

Example: Transfer 100 USDC from multisig to recipient:

```solidity
// Option 1: Using value field
multisig.submitTransaction(
    recipient,
    abi.encode(USDC_ADDRESS, 100e6),
    "" // No additional calldata
);

// Option 2: Using data field (direct transfer call)
multisig.submitTransaction(
    USDC_ADDRESS,
    "", // No value
    abi.encodeCall(ITIP20.transfer, (recipient, 100e6))
);
```

---

# Invariants

## Factory Invariants

1. `getMultisigAddress(owners, threshold)` must always return the same address for the same inputs (after sorting)
2. `createMultisig` must revert if the multisig already exists
3. `isMultisig` must return `true` if and only if the address was created by the factory
4. Owner lists must be sorted ascending before address derivation
5. Duplicate owners must be rejected
6. Owner count must be <= `MAX_OWNERS` (50)

## Multisig Invariants

1. Only owners can submit, confirm, revoke, cancel, or execute transactions
2. A transaction can only be executed once
3. A transaction requires exactly `threshold` confirmations to execute
4. An owner can only confirm a transaction once
5. Executed transactions cannot be modified or re-executed
6. Cancelled transactions cannot be executed or confirmed
7. Expired transactions cannot be executed or confirmed
8. `confirmations` count must equal the number of owners who have confirmed
9. `transactionCount` must be monotonically increasing
10. Transaction `data` size must be <= `MAX_DATA_SIZE` (64KB)
11. Transaction `value` must be empty or exactly 64 bytes (valid encoding)
12. `ownerCount` must always be >= 1 (cannot remove last owner)
13. `threshold` must always be >= 1 and <= `ownerCount`
14. Owner management operations require `threshold` confirmations
15. Config changes use the current threshold, not the proposed new threshold

## Security Invariants

1. No transaction can execute with fewer than `threshold` confirmations
2. Non-owners cannot influence transaction state (submit, confirm, revoke, cancel, execute)
3. Revoked confirmations must decrease the confirmation count
4. Token transfers in `value` field must respect TIP-403 policies
5. Reentrancy during `executeTransaction` must be blocked
6. Cancellation requires `threshold` votes (same as execution)
7. Address derivation uses 128 bits of entropy (collision-resistant)

---

# Test Cases

## Factory Tests

- Create multisig with valid 2-of-3 configuration
- Create multisig with 1-of-1 configuration
- Reject duplicate owners
- Reject zero address owner
- Reject threshold = 0
- Reject threshold > owner count
- Reject creation if multisig exists
- Reject creation with > 50 owners (`TooManyOwners`)
- Verify deterministic address matches prediction
- Verify owner order doesn't affect address (sorted internally)
- Verify 128-bit address derivation (no collisions with different configs)

## Multisig Tests

### Submission
- Submit transaction as owner
- Reject submission from non-owner
- Reject submission with data > 64KB (`DataTooLarge`)
- Reject submission with invalid value encoding (`InvalidValueEncoding`)
- Verify default expiry is set (30 days)
- Submit with custom expiry via `submitTransactionWithExpiry`

### Confirmation
- Confirm transaction as different owner
- Reject double confirmation
- Reject confirmation from non-owner
- Reject confirmation of cancelled transaction
- Reject confirmation of expired transaction
- Reject confirmation of executed transaction

### Revocation
- Revoke confirmation
- Reject revoke if not confirmed
- Reject revoke of cancelled transaction
- Reject revoke of executed transaction

### Cancellation
- Cancel transaction with threshold votes
- Reject cancel from non-owner
- Reject cancel of already-cancelled transaction
- Reject cancel of executed transaction
- Verify cancellation requires threshold votes (not just 1)
- Owner can confirm AND vote to cancel same transaction

### Execution
- Execute when threshold reached
- Reject execution with insufficient confirmations
- Reject execution from non-owner
- Reject execution of cancelled transaction
- Reject execution of expired transaction
- Reject double execution
- Execute TIP-20 transfer via value field
- Execute arbitrary call via data field
- Execute combined value + data transaction
- Verify reentrancy is blocked
- Verify events are emitted correctly

### Edge Cases
- 1-of-1 immediate execution via `execute()`
- `execute()` reverts if threshold > 1
- Transaction with empty value and empty data (no-op)
- Transaction targeting multisig itself (self-call)

## Owner Management Tests

### Add Owner
- Add owner with threshold confirmations
- Reject add from non-owner
- Reject adding existing owner (`AlreadyOwner`)
- Reject adding zero address
- Reject adding when at MAX_OWNERS (50)
- Verify owner list remains sorted after add

### Remove Owner
- Remove owner with threshold confirmations
- Reject remove from non-owner
- Reject removing non-existent owner
- Reject removing last owner (`CannotRemoveLastOwner`)
- Reject if would make threshold > ownerCount (`ThresholdExceedsOwners`)
- Removed owner's pending confirmations remain valid
- Removed owner cannot confirm new transactions

### Replace Owner
- Replace owner atomically with threshold confirmations
- Reject replace from non-owner
- Reject replacing non-existent owner
- Reject replacing with zero address
- Reject replacing with existing owner
- Verify owner list remains sorted after replace

### Change Threshold
- Change threshold with current threshold confirmations
- Reject change from non-owner
- Reject threshold = 0
- Reject threshold > ownerCount
- Verify change uses current threshold (not new one)
- 2-of-3 can change to 1-of-3, then 1-of-3 to 3-of-3

## Integration Tests

- Create multisig and transfer TIP-20 tokens
- 2-of-3 workflow: submit → confirm → confirm → execute
- 1-of-1 immediate execution via `execute()`
- Multisig receiving tokens from another account
- Multisig interacting with DEX
- Multisig as owner of another multisig (nested multisig)
- Cancel race condition: execute vs cancel reaching threshold simultaneously
- Expiry edge case: confirm just before expiry, execute just after
