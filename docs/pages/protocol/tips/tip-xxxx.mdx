# ValidatorConfig V2

This document specifies the second version of the Validator Config precompile,
introducing an append-only, delete-once design that eliminates the need for
historical state access during node recovery.

- **TIP ID**: TIP-XXXX
- **Authors/Owners**: Janis
- **Status**: Draft
- **Related Specs/TIPs**: N/A
- **Protocol Version**: TBD

---

# Overview

## Abstract

TIP-XXXX introduces ValidatorConfig V2, a new precompile for managing consensus
validators with append-only semantics. Unlike the original ValidatorConfig, V2
replaces the mutable `active` boolean with `addedAtHeight` (set when adding an
entry) and `deletedAtHeight` fields (set when deleting), enabling nodes to
reconstruct the validator set for any historical epoch using only current state.
The new design also requires Ed25519 signature verification when adding
validators to prove key ownership.

## Motivation

The original ValidatorConfig precompile allows validators to be updated
arbitrarily, which creates challenges for node recovery:

1. **Historical state dependency**: To determine the validator set at a past
   epoch, nodes must access historical account state, which requires retaining
   and indexing all historical data.

2. **Key ownership verification**: V1 does not verify that the caller controls
   the private key corresponding to the public key being registered, allowing
   potential key squatting attacks.

3. **Validator re-registration**: V1 allows deleted validators to be re-added
   with different parameters, complicating historical queries.

V2 solves these problems with an append-only design where:
- Validators are immutable after creation (no `updateValidator`)
- `addedAtHeight` and `deletedAtHeight` fields enable historical reconstruction
  from current state
- Ed25519 signature verification proves key ownership at registration time
- Both address and public key remain reserved forever (even after deletion)

### Key Design Principle

By recording `addedAtHeight` and `deletedAtHeight`, nodes can determine DKG players for any epoch using only current state. When preparing for a DKG ceremony in epoch `E+2`, a node reads the contract at `boundary(E)` and filters:

```
players(E+2) = validators.filter(v =>
    v.addedAtHeight <= boundary(E) &&
    (v.deletedAtHeight == 0 || v.deletedAtHeight > boundary(E))
)
```

This eliminates the need to retain historical account state for consensus recovery—nodes can derive DKG player sets from the current contract state alone.

---

# Specification

## Precompile Address

```solidity
address constant VALIDATOR_CONFIG_V2_ADDRESS = 0xCCCCCCCC00000000000000000000000000000002;
```

## Interface

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

/// @title IValidatorConfigV2 - Validator Config V2 Precompile Interface
/// @notice Interface for managing consensus validators with append-only, delete-once semantics
/// @dev This precompile manages the set of validators that participate in consensus.
///      V2 uses an append-only design that eliminates the need for historical state access
///      during node recovery. Validators are immutable after creation and can only be deleted once.
///
///      Key differences from V1:
///      - `active` bool replaced by `addedAtHeight` and `deletedAtHeight`
///      - No `updateValidator` - validators are immutable after creation
///      - Requires Ed25519 signature on `addValidator` to prove key ownership
///      - Both address and public key must be unique across all validators (including deleted)
interface IValidatorConfigV2 {

    /// @notice Thrown when caller lacks authorization to perform the requested action
    error Unauthorized();

    /// @notice Thrown when trying to add a validator with an address that already exists
    error ValidatorAlreadyExists();

    /// @notice Thrown when trying to add a validator with a public key that already exists
    error PublicKeyAlreadyExists();

    /// @notice Thrown when validator is not found
    error ValidatorNotFound();

    /// @notice Thrown when trying to delete a validator that is already deleted
    error ValidatorAlreadyDeleted();

    /// @notice Thrown when public key is invalid (zero)
    error InvalidPublicKey();

    /// @notice Thrown when the Ed25519 signature verification fails
    error InvalidSignature();

    /// @notice Thrown when inbound address is not in valid host:port format
    /// @param field The field name that failed validation
    /// @param input The invalid input that was provided
    /// @param backtrace Additional error context
    error NotHostPort(string field, string input, string backtrace);

    /// @notice Thrown when outbound address is not in valid ip:port format
    /// @param field The field name that failed validation
    /// @param input The invalid input that was provided
    /// @param backtrace Additional error context
    error NotIpPort(string field, string input, string backtrace);

    /// @notice Validator information (V2 - append-only, delete-once)
    /// @param publicKey Ed25519 communication public key (non-zero, unique across all validators)
    /// @param validatorAddress Ethereum-style address of the validator (unique across all validators)
    /// @param inboundAddress Address where other validators can connect (format: `<hostname|ip>:<port>`)
    /// @param outboundAddress IP address for firewall whitelisting (format: `<ip>:<port>`, no hostnames)
    /// @param index Position in validators array (assigned at creation, immutable)
    /// @param addedAtHeight Block height when validator was added (set by builder, immutable)
    /// @param deletedAtHeight Block height when validator was deleted (0 = active, set by builder)
    struct Validator {
        bytes32 publicKey;
        address validatorAddress;
        string inboundAddress;
        string outboundAddress;
        uint64 index;
        uint64 addedAtHeight;
        uint64 deletedAtHeight;
    }

    /// @notice Get all validators (including deleted ones) in array order
    /// @return validators Array of all validators with their information
    function getValidators() external view returns (Validator[] memory validators);

    /// @notice Get only active validators (where deletedAtHeight == 0)
    /// @return validators Array of active validators
    function getActiveValidators() external view returns (Validator[] memory validators);

    /// @notice Get the owner of the precompile
    /// @return The owner address
    function owner() external view returns (address);

    /// @notice Get total number of validators ever added (including deleted)
    /// @return The count of validators
    function validatorCount() external view returns (uint64);

    /// @notice Get validator information by index in the validators array
    /// @param index The index in the validators array
    /// @return The validator struct at the given index
    function validatorByIndex(uint256 index) external view returns (Validator memory);

    /// @notice Get validator information by address
    /// @param validatorAddress The validator address to look up
    /// @return The validator struct for the given address
    function validatorByAddress(address validatorAddress) external view returns (Validator memory);

    /// @notice Get validator information by public key
    /// @param publicKey The validator's public key to look up
    /// @return The validator struct for the given public key
    function validatorByPublicKey(bytes32 publicKey) external view returns (Validator memory);

    /// @notice Get the epoch at which a fresh DKG ceremony will be triggered
    /// @return The epoch number, or 0 if no fresh DKG is scheduled.
    ///         The fresh DKG ceremony runs in epoch N, and epoch N+1 uses the new DKG polynomial.
    function getNextFullDkgCeremony() external view returns (uint64);

    /// @notice Add a new validator (owner only)
    /// @dev The signature must be an Ed25519 signature over:
    ///      keccak256(abi.encodePacked(chainId, contractAddress, validatorAddress, inboundAddress, outboundAddress))
    ///      This proves the caller controls the private key corresponding to publicKey.
    /// @param validatorAddress The address of the new validator
    /// @param publicKey The validator's Ed25519 communication public key
    /// @param inboundAddress The validator's inbound address `<hostname|ip>:<port>` for incoming connections
    /// @param outboundAddress The validator's outbound IP address `<ip>:<port>` for firewall whitelisting
    /// @param signature Ed25519 signature (64 bytes) proving ownership of the public key
    function addValidator(
        address validatorAddress,
        bytes32 publicKey,
        string calldata inboundAddress,
        string caaaaalldata outboundAddress,
        bytes calldata signature
    ) external;

    /// @notice Delete a validator (owner only)
    /// @dev Marks the validator as deleted by setting deletedAtHeight to the current block height.
    ///      The validator's entry remains in storage for historical queries.
    ///      The address and public key remain reserved and cannot be reused.
    /// @param validatorAddress The validator address to delete
    function deleteValidator(address validatorAddress) external;

    /// @notice Change owner (owner only)
    /// @param newOwner The new owner address
    function changeOwner(address newOwner) external;

    /// @notice Set the epoch at which a fresh DKG ceremony will be triggered (owner only)
    /// @param epoch The epoch in which to run the fresh DKG ceremony.
    ///        Epoch N runs the ceremony, and epoch N+1 uses the new DKG polynomial.
    function setNextFullDkgCeremony(uint64 epoch) external;

    /// @notice Initialize V2 from V1 state (callable by anyone)
    /// @dev If already initialized, this is a no-op. Reads validators from V1 and
    ///      populates V2 storage. If V1 read fails, sets initialized = true without
    ///      importing any validators.
    function initialize() external;
}
```

## Behavior

### Validator Lifecycle

Unlike V1, validators in V2 follow a strict lifecycle:

1. **Addition**: `addValidator` creates an immutable validator entry with
   `addedAtHeight` set to the current block height and `deletedAtHeight = 0`
2. **Active period**: Validator participates in consensus while
   `deletedAtHeight == 0`
3. **Deletion**: `deleteValidator` sets `deletedAtHeight` to the current block
   height
4. **Preserved**: The validator entry remains in storage forever for historical
   queries

```
┌─────────────┐     addValidator()     ┌─────────────┐     deleteValidator()     ┌─────────────┐
│             │ ────────────────────►  │             │ ────────────────────────► │             │
│  Not Exist  │                        │   Active    │                           │   Deleted   │
│             │                        │ deleted=0   │                           │ deleted>0   │
└─────────────┘                        └─────────────┘                           └─────────────┘
                                              │                                         │
                                              │◄────────────────────────/───────────────┘
                                              │         (No transition back)
```

### Signature Verification

When adding a validator, the caller must provide an Ed25519 signature proving
ownership of the public key:

```
message = keccak256(abi.encodePacked(
    b"TEMPO",                             // bytes: global namespace prefix 
    b"_VALIDATOR_CONFIG_V2_ADD_VALIDATOR" // bytes: contract specific namespace
    chainId,                              // uint64: Prevents cross-chain replay
    contractAddress,                      // address: Prevents cross-contract replay
    validatorAddress,                     // address: Binds to specific validator address
    inboundAddress,                       // string: Binds network configuration
    outboundAddress                       // string: Binds network configuration
))
```

The signature must be exactly 64 bytes and must verify against the provided
public key.

### DKG Player Selection

The DKG manager uses the validator set from this contract to determine participants in each DKG ceremony. To ensure validators have sufficient time to join the network and synchronize, there is a **one-epoch gap** between registration and DKG participation.

**Rule**: A validator becomes a DKG player in epoch `E+2` if `addedAtHeight <= boundary(E)`, where `boundary(E)` is the last block height of epoch `E`.

```
Epoch E                    Epoch E+1                  Epoch E+2
│                          │                          │
│  addValidator() called   │  Validator syncs,        │  Validator participates
│  at some height H        │  prepares for DKG        │  as DKG player
│                          │                          │
├──────────────────────────┼──────────────────────────┼──────────────────────────►
│                          │                          │
           boundary(E)              boundary(E+1)
           (last block)             (last block)
```

**Example timeline** (assuming epoch length of 100 blocks):
1. Validator is added at height 1050 during epoch 10, confirmed at `boundary(10) = 1000`
2. Epoch 11 (heights 1001–1100): The validator syncs with the network
3. Epoch 12 (heights 1101–1200): The validator participates as a DKG player and receives a share (on success)
4. Epoch 13 (heights 1201–1300): The validator becomes a signer using the share from the epoch 12 DKG

**Deletion follows the same pattern**: A deleted validator is excluded from epoch `E+2` if `deletedAtHeight <= boundary(E)`.

The complete filter for DKG players at epoch `E+2`:
```
players = validators.filter(v =>
    v.addedAtHeight <= boundary(E) &&
    (v.deletedAtHeight == 0 || v.deletedAtHeight > boundary(E))
)
```

### Determining Active Validators

Reading this contract alone is **not sufficient** to determine who the active validators (signers) are during a given epoch. The contract only records which validators are *eligible* to participate in DKG ceremonies—it does not record DKG outcomes.

To determine the actual validators for epoch `E+1`:

1. Read the DKG outcome from block `boundary(E)`
2. The DKG outcome contains the Ed25519 public keys of successful DKG players
3. Match these public keys against the contract via `validatorByPublicKey()` to obtain validator addresses and IP addresses

```
activeValidators(E+1) = dkgOutcome(boundary(E)).players.map(pubkey =>
    contract.validatorByPublicKey(pubkey)
)
```

This distinction matters because:
- The DKG can fail, reverting to the previous DKG outcome (for example, not all
  eligible players may successfully participate in the the DKG due to network
  issues, crashes, etc.)
- The DKG outcome is the authoritative record of who holds valid key shares
- Only validators with valid shares can produce valid signatures in epoch `E+1`

### Address Validation

- **inboundAddress**: Must be in `<hostname|ip>:<port>` format. Hostnames and IP
  addresses are both accepted.
- **outboundAddress**: Must be in `<ip>:<port>` format. Only IP addresses are
  accepted (no hostnames).

Both IPv4 and IPv6 addresses are supported. IPv6 addresses must be enclosed in
brackets: `[2001:db8::1]:8080`.

### Reconstructing DKG Players

Nodes can determine the DKG players for any past or future epoch using only current contract state. To find the players for epoch `E+2`, fetch all validators via `getValidators()` and filter based on `boundary(E)`:

```
players(E+2) = validators.filter(v =>
    v.addedAtHeight <= boundary(E) &&
    (v.deletedAtHeight == 0 || v.deletedAtHeight > boundary(E))
)
```

This enables nodes to reconstruct DKG player sets without accessing historical account state—critical for node recovery and late-joining validators.

### Uniqueness Constraints

Both the validator address and public key must be globally unique across all
validators (including deleted ones):

- `ValidatorAlreadyExists`: Reverts if the address has ever been registered
- `PublicKeyAlreadyExists`: Reverts if the public key has ever been registered

This ensures historical queries always return consistent results.

## Storage Layout

| Slot | Field | Description |
|------|-------|-------------|
| 0 (bits 0-159) | `owner` | Owner address (160 bits, right-aligned) |
| 0 (bit 255) | `initialized` | Whether V2 has been initialized from V1 (1 bit) |
| 1 | `validatorsArray.length` | Count of validators ever added |
| keccak256(1) + i | `validatorsArray[i]` | Validator address at index i |
| keccak256(addr, 2) | `validators[addr]` | Validator struct for address |
| keccak256(pubkey, 3) | `pubkeyToIndex[pubkey]` | Index for public key lookup |
| 4 | `nextDkgCeremony` | Next full DKG ceremony epoch |

The `owner` address is right-aligned (bits 0-159) following Solidity's standard
packing. The `initialized` flag uses bit 255 (the highest bit), leaving bits
160-254 unused.

## Differences from V1

| Aspect | V1 | V2 |
|--------|----|----|
| Status field | `active: bool` | `deletedAtHeight: uint64` (0 = active) |
| Creation tracking | None | `addedAtHeight: uint64` |
| Mutability | Mutable via `updateValidator()` | Immutable after creation |
| Deletion | Sets `active = false` | Sets `deletedAtHeight = block.number` |
| Re-registration | Allowed after deletion | Never allowed (address/pubkey reserved forever) |
| Key ownership | Not verified | Ed25519 signature required |
| Historical queries | Requires historical state | Filter `getValidators()` by `addedAtHeight`/`deletedAtHeight` |
| Uniqueness | Address only | Address AND public key |
| Precompile address | `0xCCCC...0001` | `0xCCCC...0002` |

---

# Invariants

The following invariants must always hold:

1. **Append-only array**: The `validatorsArray` length only increases; it never
   decreases.

2. **Immutable validators**: Once a validator is added, its `publicKey`,
   `validatorAddress`, `inboundAddress`, `outboundAddress`, `index`, and
   `addedAtHeight` fields never change.

3. **Delete-once**: A validator's `deletedAtHeight` can only transition from 0
   to a non-zero value, never back to 0 or to a different non-zero value.

4. **Unique addresses**: No two validators (including deleted ones) can have the
   same `validatorAddress`.

5. **Unique public keys**: No two validators (including deleted ones) can have
   the same `publicKey`.

6. **Non-zero public keys**: All validators must have a non-zero `publicKey`.

7. **Monotonic index**: Validator `index` equals its position in
   `validatorsArray` and equals `validatorCount - 1` at creation time.

8. **Historical consistency**: For any height H, `getValidatorSetAtHeight(H)`
   returns exactly the validators where
   `addedAtHeight <= H && (deletedAtHeight == 0 || deletedAtHeight > H)`.

9. **Signature binding**: The signature message includes `chainId`,
   `contractAddress`, `validatorAddress`, `inboundAddress`, and
   `outboundAddress`, preventing replay across chains, contracts, or parameter
   changes.

10. **Owner authorization**: Only the owner can call `addValidator`,
    `deleteValidator`, `changeOwner`, and `setNextFullDkgCeremony`.

11. **Initialized once**: The `initialized` bit (bit 255 of slot 0) can only
    transition from 0 to 1, never back to 0.

---

# Migration from V1

This section describes the migration strategy from ValidatorConfig V1 to V2.

## Overview

The migration uses a two-pronged approach:

1. **New hardfork ("Allegro")**: Timestamp-based activation that switches
   consensus from reading V1 to V2
2. **Lazy initialization**: On first access (read or write), V2 automatically
   populates itself from V1 state

## Hardfork-Based Switching

The DKG manager determines which contract to read based on the block timestamp
at the boundary height:

```
if chainspec.is_allegro_active_at_timestamp(block.timestamp) {
    read_from_contract_v2_at_height(height)
} else {
    read_from_contract_at_height(height)  // V1
}
```

This ensures all nodes switch deterministically at the same point.

## Lazy Initialization

V2 uses lazy initialization to automatically populate from V1 on first access.
The `initialized` bit (bit 255 of slot 0) tracks whether initialization has
occurred.

### Triggering Functions

The following functions trigger initialization if `initialized == false`:

- `getValidators()`
- `getActiveValidators()`
- `validatorCount()`
- `validatorByIndex(uint256 index)`
- `validatorByAddress(address validatorAddress)`
- `validatorByPublicKey(bytes32 publicKey)`
- `addValidator(...)`
- `initialize()`

### Initialization Procedure

When any triggering function is called and `initialized == false`:

1. Read all validators from ValidatorConfig V1 at
   `0xCCCCCCCC00000000000000000000000000000000`
2. For each V1 validator where `active == true`:
   - Create a V2 validator entry with:
     - `publicKey`: copied from V1
     - `validatorAddress`: copied from V1
     - `inboundAddress`: copied from V1
     - `outboundAddress`: copied from V1
     - `index`: assigned sequentially (0, 1, 2, ...)
     - `addedAtHeight`: set to `block.number`
     - `deletedAtHeight`: set to 0 (active)
   - Add to `validatorsArray`
   - Populate lookup maps (`validators[addr]`, `pubkeyToIndex[pubkey]`)
3. Copy `nextDkgCeremony` from V1 to V2 (if V1 read succeeds)
4. Set `initialized = true` (bit 255 of slot 0)

If the V1 read fails at any point, skip steps 2-3 and proceed directly to step 4.

Note: The `owner` is NOT copied from V1. V2's owner must be set separately
(typically at genesis or via a privileged initialization call).

```solidity
// V1 interface used during initialization
interface IValidatorConfigV1 {
    struct Validator {
        bytes32 publicKey;
        bool active;
        uint64 index;
        address validatorAddress;
        string inboundAddress;
        string outboundAddress;
    }

    function getValidators() external view returns (Validator[] memory);
    function getNextFullDkgCeremony() external view returns (uint64);
}
```

### Properties

- **One-time**: Initialization executes exactly once; subsequent calls are no-ops
- **Atomic**: The entire initialization completes in a single transaction
- **Transparent**: Callers do not need to know whether initialization occurred
- **No signatures required**: V1 validators are imported without Ed25519 signatures
  (they were already validated in V1)
- **Inactive validators skipped**: Only V1 validators with `active == true` are
  imported

## Timeline

```
Before Fork                    First V2 Read                   After Initialization
     │                              │                              │
     │  DKG reads V1                │  Lazy init executes          │  DKG reads V2
     │  V2 empty, initialized=0     │  V2 populated from V1        │  initialized=1
     │                              │                              │
─────┴──────────────────────────────┴──────────────────────────────┴─────────────────►
                                    │
                              allegroTime
```

## Migration Steps

### For Existing Networks (testnet, mainnet)

1. **Release new node software** with Allegro hardfork support
2. **Schedule the fork** by updating chainspec with target `allegroTime`
3. **At fork activation**: First V2 read automatically triggers initialization
4. **Post-fork**: DKG reads V2; future validator changes use V2's `addValidator`
   with signatures

### For New Networks

1. Initialize V2 at genesis with the initial validator set (set `initialized = true`)
2. Optionally populate V1 for backward tooling compatibility
3. Set `allegroTime = 0` to activate V2 immediately

## Safety Checks

If V1 read fails during initialization (e.g., V1 contract not deployed, call
reverts), the initialization procedure skips importing validators and sets
`initialized = true`. This allows V2 to start fresh without V1 data.

Nodes should fail fast if:
- V2 validator set is empty after initialization AND V1 had active validators
  (indicates a bug in the initialization logic)

---

## Test Cases

The test suite must cover:

### Basic Operations

1. **Add validator**: Successfully adds a validator with valid signature
2. **Delete validator**: Successfully marks validator as deleted
3. **Change owner**: Successfully transfers ownership
4. **Set next DKG ceremony**: Successfully sets the epoch

### Query Functions

5. **getValidators**: Returns all validators including deleted with correct
   `addedAtHeight` and `deletedAtHeight`
6. **getActiveValidators**: Returns only validators with `deletedAtHeight == 0`
7. **validatorByPublicKey**: Returns validator by public key lookup
8. **validatorCount**: Returns total count including deleted

### Error Conditions

9. **Unauthorized**: Non-owner cannot call protected functions
10. **ValidatorAlreadyExists**: Cannot re-add same address
11. **PublicKeyAlreadyExists**: Cannot re-use same public key
12. **ValidatorNotFound**: Cannot query/delete non-existent validator
13. **ValidatorAlreadyDeleted**: Cannot delete twice
14. **InvalidPublicKey**: Rejects zero public key
15. **InvalidSignature**: Rejects wrong signature, wrong length, wrong signer

### Address Validation

16. **Valid IPv4:port**: Accepts `192.168.1.1:8080`
17. **Valid IPv6:port**: Accepts `[2001:db8::1]:8080`
18. **Invalid format**: Rejects malformed addresses

### Historical Filtering (Caller-side)

19. **addedAtHeight correctness**: Validators have correct `addedAtHeight` set
    at creation
20. **deletedAtHeight correctness**: Deleted validators have correct
    `deletedAtHeight` set
21. **Filter logic**: Caller can correctly filter by
    `addedAtHeight <= H && (deletedAtHeight == 0 || deletedAtHeight > H)`

### Lazy Initialization

22. **Triggering functions**: `getValidators`, `getActiveValidators`,
    `validatorCount`, `validatorByIndex`, `validatorByAddress`,
    `validatorByPublicKey`, `addValidator`, `initialize` all trigger
    initialization on first access; subsequent accesses are no-ops
23. **Active validators only**: V1 validators with `active == false` are not
    imported
24. **DKG ceremony copied**: V2 `getNextFullDkgCeremony()` matches V1
25. **addedAtHeight set correctly**: Imported validators have
    `addedAtHeight == block.number` at initialization time
26. **V1 read failure**: If V1 read fails, initialization sets bit without
    importing validators
