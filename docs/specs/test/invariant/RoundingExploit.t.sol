// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import { FeeManager } from "../../src/FeeManager.sol";
import { TIP20 } from "../../src/TIP20.sol";
import { IFeeAMM } from "../../src/interfaces/IFeeAMM.sol";
import { BaseTest } from "../BaseTest.t.sol";

/// @title RoundingExploitTest
/// @notice Unit tests attempting to exploit rounding in FeeAMM (A7, A8, I2)
/// @dev Tests various attack vectors exploiting floor division rounding
contract RoundingExploitTest is BaseTest {

    TIP20 public userToken;
    TIP20 public validatorToken;
    bytes32 public poolId;

    address public attacker = address(0xBAD);
    address public lp = address(0x1111);

    uint256 public constant M = 9970;
    uint256 public constant N = 9985;
    uint256 public constant SCALE = 10_000;

    function setUp() public override {
        super.setUp();

        userToken = TIP20(
            factory.createToken("UserToken", "UTK", "USD", pathUSD, admin, bytes32("user"))
        );
        validatorToken = TIP20(
            factory.createToken(
                "ValidatorToken", "VTK", "USD", pathUSD, admin, bytes32("validator")
            )
        );

        userToken.grantRole(_ISSUER_ROLE, admin);
        validatorToken.grantRole(_ISSUER_ROLE, admin);
        userToken.grantRole(_ISSUER_ROLE, address(this));
        validatorToken.grantRole(_ISSUER_ROLE, address(this));

        // Setup initial pool liquidity
        uint256 initialLiquidity = 10_000_000e18;
        validatorToken.mint(lp, initialLiquidity);
        vm.startPrank(lp);
        validatorToken.approve(address(amm), initialLiquidity);
        amm.mint(address(userToken), address(validatorToken), initialLiquidity, lp);
        vm.stopPrank();

        poolId = amm.getPoolId(address(userToken), address(validatorToken));

        // Fund attacker
        userToken.mint(attacker, 100_000_000e18);
        validatorToken.mint(attacker, 100_000_000e18);
    }

    /*//////////////////////////////////////////////////////////////
            A7 BREAK ATTEMPT: MINT/BURN ROUNDING EXTRACTION
    //////////////////////////////////////////////////////////////*/

    /// @notice Attempt to extract value via small mint/burn cycles
    /// @dev Each mint rounds down LP tokens, each burn rounds down output
    function test_A7_SmallMintBurnCycles() public {
        uint256 cycles = 100;
        uint256 smallAmount = 1000; // Very small deposit

        vm.startPrank(attacker);
        validatorToken.approve(address(amm), type(uint256).max);

        uint256 attackerStartBal = validatorToken.balanceOf(attacker);
        uint256 poolStartReserve =
            amm.getPool(address(userToken), address(validatorToken)).reserveValidatorToken;

        for (uint256 i = 0; i < cycles; i++) {
            // Mint with small amount
            try amm.mint(
                address(userToken), address(validatorToken), smallAmount, attacker
            ) returns (
                uint256 liq
            ) {
                if (liq > 0) {
                    // Immediately burn
                    amm.burn(address(userToken), address(validatorToken), liq, attacker);
                }
            } catch {
                // Expected - amount too small for liquidity
            }
        }

        vm.stopPrank();

        uint256 attackerEndBal = validatorToken.balanceOf(attacker);
        uint256 poolEndReserve =
            amm.getPool(address(userToken), address(validatorToken)).reserveValidatorToken;

        // Attacker should not profit - rounding should favor the pool
        assertLe(
            attackerEndBal, attackerStartBal, "Attacker should not profit from mint/burn cycles"
        );
        assertGe(poolEndReserve, poolStartReserve, "Pool should not lose reserves to rounding");
    }

    /// @notice Attempt to extract value via repeated small mints
    function test_A7_RepeatedSmallMints() public {
        uint256 cycles = 50;
        uint256 smallAmount = 10_000; // Small but viable deposit

        vm.startPrank(attacker);
        validatorToken.approve(address(amm), type(uint256).max);

        uint256 totalDeposited = 0;
        uint256 totalLiquidity = 0;

        for (uint256 i = 0; i < cycles; i++) {
            try amm.mint(
                address(userToken), address(validatorToken), smallAmount, attacker
            ) returns (
                uint256 liq
            ) {
                totalDeposited += smallAmount;
                totalLiquidity += liq;
            } catch {
                break;
            }
        }

        // Now burn all at once
        if (totalLiquidity > 0) {
            (uint256 outUser, uint256 outValidator) =
                amm.burn(address(userToken), address(validatorToken), totalLiquidity, attacker);

            // Attacker should not get more than deposited
            assertLe(outValidator, totalDeposited, "Should not extract more than deposited");
        }

        vm.stopPrank();
    }

    /// @notice Test first depositor attack (inflation attack)
    /// @dev First depositor tries to manipulate share price
    function test_A7_FirstDepositorInflationAttack() public {
        // Create a new pool for this test
        TIP20 newUserToken = TIP20(
            factory.createToken("NewUser", "NU", "USD", pathUSD, admin, bytes32("newuser"))
        );
        TIP20 newValidatorToken = TIP20(
            factory.createToken("NewValidator", "NV", "USD", pathUSD, admin, bytes32("newval"))
        );
        newUserToken.grantRole(_ISSUER_ROLE, address(this));
        newValidatorToken.grantRole(_ISSUER_ROLE, address(this));

        // Attacker is first depositor with minimal amount
        uint256 minDeposit = amm.MIN_LIQUIDITY() * 2 + 2;
        newValidatorToken.mint(attacker, minDeposit);

        vm.startPrank(attacker);
        newValidatorToken.approve(address(amm), minDeposit);
        uint256 attackerLiquidity =
            amm.mint(address(newUserToken), address(newValidatorToken), minDeposit, attacker);
        vm.stopPrank();

        // Verify MIN_LIQUIDITY was locked
        bytes32 newPoolId = amm.getPoolId(address(newUserToken), address(newValidatorToken));
        uint256 lockedLiquidity = amm.totalSupply(newPoolId) - attackerLiquidity;
        assertEq(lockedLiquidity, amm.MIN_LIQUIDITY(), "MIN_LIQUIDITY should be locked");

        // Second depositor comes in
        address victim = address(0xBEEF);
        uint256 victimDeposit = 1_000_000e18;
        newValidatorToken.mint(victim, victimDeposit);

        vm.startPrank(victim);
        newValidatorToken.approve(address(amm), victimDeposit);
        uint256 victimLiquidity =
            amm.mint(address(newUserToken), address(newValidatorToken), victimDeposit, victim);
        vm.stopPrank();

        // Victim should get proportional share - MIN_LIQUIDITY prevents inflation attack
        assertGt(victimLiquidity, 0, "Victim should receive LP tokens");

        // Verify total supply accounting
        uint256 totalSupply = amm.totalSupply(newPoolId);
        assertEq(totalSupply, amm.MIN_LIQUIDITY() + attackerLiquidity + victimLiquidity);
    }

    /*//////////////////////////////////////////////////////////////
            A8 BREAK ATTEMPT: REBALANCE SWAP ROUNDING
    //////////////////////////////////////////////////////////////*/

    /// @notice Attempt to exploit rebalanceSwap rounding with small amounts
    /// @dev rebalanceSwap: amountIn = (amountOut * N) / SCALE + 1 (rounds up)
    function test_A8_SmallRebalanceSwaps() public {
        uint256 cycles = 100;

        // First, add some userToken reserves via simulated fee swaps
        // We need userToken in the pool to do rebalanceSwap
        _addUserTokenReserves(1_000_000e18);

        vm.startPrank(attacker);
        validatorToken.approve(address(amm), type(uint256).max);

        uint256 totalIn = 0;
        uint256 totalOut = 0;

        IFeeAMM.Pool memory pool = amm.getPool(address(userToken), address(validatorToken));
        uint256 maxOut = pool.reserveUserToken / cycles / 2;
        if (maxOut == 0) maxOut = 1;

        for (uint256 i = 0; i < cycles; i++) {
            pool = amm.getPool(address(userToken), address(validatorToken));
            if (pool.reserveUserToken < maxOut) break;

            try amm.rebalanceSwap(
                address(userToken), address(validatorToken), maxOut, attacker
            ) returns (
                uint256 amountIn
            ) {
                totalIn += amountIn;
                totalOut += maxOut;
            } catch {
                break;
            }
        }

        vm.stopPrank();

        // Calculate expected input (with rounding)
        // Each swap: expectedIn = (amountOut * N) / SCALE + 1
        // Due to +1 rounding up, attacker pays more than theoretical rate
        uint256 theoreticalIn = (totalOut * N) / SCALE;

        // Total input should be >= theoretical (rounding up protects pool)
        assertGe(totalIn, theoreticalIn, "Actual input should be >= theoretical");
    }

    /// @notice Attempt to exploit with amount = 1 (maximum rounding impact)
    /// @dev This test verifies the rounding formula mathematically when pool has reserves
    function test_A8_SingleUnitRebalanceSwap() public {
        // On Tempo, storage manipulation doesn't work, so skip if no reserves
        IFeeAMM.Pool memory pool = amm.getPool(address(userToken), address(validatorToken));
        if (pool.reserveUserToken == 0) {
            // Verify the formula mathematically instead
            // amountOut = 1
            // expectedIn = (1 * 9985) / 10000 + 1 = 0 + 1 = 1
            uint256 amountOut = 1;
            uint256 expectedIn = (amountOut * N) / SCALE + 1;

            // For amount=1, expectedIn = 1 (rounds up)
            assertEq(expectedIn, 1, "Expected input should be 1");

            // Verify no profit: pay 1 to get 1
            assertGe(expectedIn, amountOut, "Input >= output (no profit)");
            return;
        }

        vm.startPrank(attacker);
        validatorToken.approve(address(amm), type(uint256).max);

        uint256 amountOut = 1;
        uint256 expectedIn = (amountOut * N) / SCALE + 1;

        uint256 balBefore = validatorToken.balanceOf(attacker);
        amm.rebalanceSwap(address(userToken), address(validatorToken), amountOut, attacker);
        uint256 balAfter = validatorToken.balanceOf(attacker);

        uint256 actualIn = balBefore - balAfter;

        // For amount=1, we pay 1 to get 1 - no profit possible
        assertEq(actualIn, expectedIn, "Should pay expected amount");
        assertGe(actualIn, 1, "Must pay at least 1");

        vm.stopPrank();
    }

    /// @notice Repeated single-unit swaps should not accumulate rounding profit
    function test_A8_RepeatedSingleUnitSwaps() public {
        _addUserTokenReserves(10_000e18);

        vm.startPrank(attacker);
        validatorToken.approve(address(amm), type(uint256).max);

        uint256 swaps = 1000;
        uint256 totalIn = 0;
        uint256 totalOut = 0;

        for (uint256 i = 0; i < swaps; i++) {
            IFeeAMM.Pool memory pool = amm.getPool(address(userToken), address(validatorToken));
            if (pool.reserveUserToken == 0) break;

            try amm.rebalanceSwap(
                address(userToken), address(validatorToken), 1, attacker
            ) returns (
                uint256 amountIn
            ) {
                totalIn += amountIn;
                totalOut += 1;
            } catch {
                break;
            }
        }

        vm.stopPrank();

        // Each swap pays at least 1 for 1, so totalIn >= totalOut
        assertGe(totalIn, totalOut, "Total input should be >= total output");

        // Due to +1 rounding, attacker actually overpays
        // Theoretical: (totalOut * N) / SCALE
        uint256 theoretical = (totalOut * N) / SCALE;
        assertGe(totalIn, theoretical, "Paid at least theoretical amount");
    }

    /*//////////////////////////////////////////////////////////////
            I2 BREAK ATTEMPT: ARBITRAGE VIA SWAP SEQUENCES
    //////////////////////////////////////////////////////////////*/

    /// @notice Attempt arbitrage by cycling through fee swap and rebalance
    /// @dev Fee swap: rate M = 0.997, Rebalance: rate N = 0.9985
    /// Spread of 15 bps should prevent arbitrage
    function test_I2_FeeRebalanceCycle() public {
        // We can't directly call executeFeeSwap (internal)
        // But we can verify the spread prevents arbitrage mathematically

        uint256 amount = 1_000_000e18;

        // Fee swap: userToken -> validatorToken at rate M
        uint256 feeSwapOut = (amount * M) / SCALE; // 997,000

        // Rebalance swap: validatorToken -> userToken at rate N
        // Input needed to get feeSwapOut back
        uint256 rebalanceIn = (feeSwapOut * N) / SCALE + 1; // ~996,005 + 1

        // For arbitrage: we'd need rebalanceIn < amount
        // But with the spread: amount * M / SCALE then back costs more

        // Actually the cycle is:
        // 1. Start with X userToken
        // 2. Fee swap: get X * M / SCALE validatorToken
        // 3. Rebalance: to get X userToken back, need (X * N / SCALE + 1) validatorToken

        // Check: fee swap output < rebalance input needed
        // feeSwapOut = X * M / SCALE
        // To get X back via rebalance: need (X * N / SCALE + 1)
        // So we receive X * M / SCALE but need X * N / SCALE + 1

        // For no arbitrage: X * M / SCALE < X * N / SCALE + 1
        // M * X < N * X + SCALE (always true since M < N and scale adds buffer)

        // Verify mathematically
        assertLt(M, N, "M should be less than N");
        assertEq(N - M, 15, "Spread should be 15 basis points");

        // For any amount, fee swap out < rebalance input needed to recover
        uint256 feeOut = (amount * M) / SCALE;
        uint256 rebalanceNeededForAmount = (amount * N) / SCALE + 1;

        assertLt(feeOut, rebalanceNeededForAmount, "Fee swap output < rebalance cost to recover");
    }

    /// @notice Verify no profit from small swap cycles
    function test_I2_SmallSwapCycleNoProfit() public {
        // Small amounts where rounding matters most
        uint256[] memory amounts = new uint256[](5);
        amounts[0] = 1;
        amounts[1] = 10;
        amounts[2] = 100;
        amounts[3] = 1000;
        amounts[4] = 10_000;

        for (uint256 i = 0; i < amounts.length; i++) {
            uint256 amount = amounts[i];

            // Fee swap output
            uint256 feeOut = (amount * M) / SCALE;

            // Rebalance input to get original amount back
            uint256 rebalanceIn = (amount * N) / SCALE + 1;

            // feeOut is what we receive, rebalanceIn is what we'd need to pay
            // For profit: feeOut > rebalanceIn (never true with this spread)
            assertLe(
                feeOut,
                rebalanceIn,
                string(abi.encodePacked("No profit at amount ", vm.toString(amount)))
            );
        }
    }

    /*//////////////////////////////////////////////////////////////
            BURN ROUNDING TESTS
    //////////////////////////////////////////////////////////////*/

    /// @notice Test that burn rounds down (favors pool)
    function test_BurnRoundsDown() public {
        // Get LP's liquidity
        uint256 lpLiquidity = amm.liquidityBalances(poolId, lp);
        assertGt(lpLiquidity, 0, "LP should have liquidity");

        // Burn 1 unit of liquidity
        vm.prank(lp);
        (uint256 outUser, uint256 outValidator) =
            amm.burn(address(userToken), address(validatorToken), 1, lp);

        // With very small burn relative to pool, rounding down means 0 output
        // This protects the pool from rounding exploitation
        // (Actual values depend on pool state)
        assertGe(outUser + outValidator, 0, "Output should be non-negative");
    }

    /// @notice Test repeated small burns don't accumulate extra value
    function test_RepeatedSmallBurns() public {
        // Get LP's liquidity
        uint256 lpLiquidity = amm.liquidityBalances(poolId, lp);
        uint256 burnAmount = lpLiquidity / 100; // 1% per burn
        if (burnAmount == 0) return;

        IFeeAMM.Pool memory poolBefore = amm.getPool(address(userToken), address(validatorToken));
        uint256 totalSupplyBefore = amm.totalSupply(poolId);

        uint256 totalOutValidator = 0;
        uint256 totalBurned = 0;

        vm.startPrank(lp);
        for (uint256 i = 0; i < 10; i++) {
            uint256 balance = amm.liquidityBalances(poolId, lp);
            if (balance < burnAmount) break;

            (, uint256 outVal) =
                amm.burn(address(userToken), address(validatorToken), burnAmount, lp);
            totalOutValidator += outVal;
            totalBurned += burnAmount;
        }
        vm.stopPrank();

        // Calculate expected output (theoretical, without rounding)
        uint256 expectedOut = (totalBurned * poolBefore.reserveValidatorToken) / totalSupplyBefore;

        // Due to per-burn rounding down, actual output <= expected
        assertLe(
            totalOutValidator,
            expectedOut + 10,
            "Output should be <= expected (with small tolerance)"
        );
    }

    /*//////////////////////////////////////////////////////////////
            FUZZ TESTS
    //////////////////////////////////////////////////////////////*/

    /// @notice Fuzz: rebalanceSwap always requires >= theoretical input
    function testFuzz_RebalanceSwapRounding(uint256 amountOut) public {
        amountOut = bound(amountOut, 1, 1_000_000e18);

        _addUserTokenReserves(amountOut * 2);

        IFeeAMM.Pool memory pool = amm.getPool(address(userToken), address(validatorToken));
        if (pool.reserveUserToken < amountOut) return;

        uint256 expectedIn = (amountOut * N) / SCALE + 1;

        vm.startPrank(attacker);
        validatorToken.approve(address(amm), type(uint256).max);

        uint256 balBefore = validatorToken.balanceOf(attacker);
        amm.rebalanceSwap(address(userToken), address(validatorToken), amountOut, attacker);
        uint256 balAfter = validatorToken.balanceOf(attacker);
        uint256 actualIn = balBefore - balAfter;

        vm.stopPrank();

        assertEq(actualIn, expectedIn, "Input should match expected with +1 rounding");
        assertGe(actualIn, (amountOut * N) / SCALE, "Input >= theoretical rate");
    }

    /// @notice Fuzz: mint/burn cycle never profits
    function testFuzz_MintBurnNoProfit(uint256 amount) public {
        amount = bound(amount, 10_000, 1_000_000e18);

        uint256 attackerBalBefore = validatorToken.balanceOf(attacker);

        vm.startPrank(attacker);
        validatorToken.approve(address(amm), type(uint256).max);

        uint256 liquidity = amm.mint(address(userToken), address(validatorToken), amount, attacker);

        (, uint256 outValidator) =
            amm.burn(address(userToken), address(validatorToken), liquidity, attacker);

        vm.stopPrank();

        uint256 attackerBalAfter = validatorToken.balanceOf(attacker);

        // Attacker should not profit (may lose due to rounding)
        assertLe(attackerBalAfter, attackerBalBefore, "Should not profit from mint/burn");
    }

    /*//////////////////////////////////////////////////////////////
            HELPERS
    //////////////////////////////////////////////////////////////*/

    /// @dev Add userToken reserves to pool by simulating accumulated fees
    /// In real system, this happens via executeFeeSwap from protocol
    function _addUserTokenReserves(uint256 amount) internal {
        // We can't directly add to pool, but we can simulate by having LP provide
        // Actually, we need to manipulate storage since executeFeeSwap is internal

        // For test purposes, directly transfer userToken to AMM and update reserves
        userToken.mint(address(amm), amount);

        // Update pool reserves via storage (only works in non-Tempo env)
        if (!isTempo) {
            bytes32 poolSlot = keccak256(abi.encode(poolId, uint256(0)));
            bytes32 currentData = vm.load(address(amm), poolSlot);

            uint128 currentUserReserve = uint128(uint256(currentData));
            uint128 currentValidatorReserve = uint128(uint256(currentData) >> 128);

            uint128 newUserReserve = currentUserReserve + uint128(amount);
            bytes32 newData =
                bytes32((uint256(currentValidatorReserve) << 128) | uint256(newUserReserve));
            vm.store(address(amm), poolSlot, newData);
        }
    }

}
