name: Precompiles Coverage

on:
  workflow_run:
    workflows: ["Test", "Specs"]
    types: [completed]
  pull_request:
    branches: [main]

permissions:
  pull-requests: write
  actions: read

jobs:
  merge-coverage:
    name: Merge Precompiles Coverage
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'pull_request' ||
      github.event.workflow_run.conclusion == 'success'
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: llvm-tools-preview

      - name: Download cargo test coverage
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: test.yml
          name: cargo-test-coverage
          path: cargo-coverage
          if_no_artifact_found: warn
          search_artifacts: true
          branch: ${{ github.head_ref || github.ref_name }}
        continue-on-error: true

      - name: Download forge test coverage
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: specs.yml
          name: forge-test-coverage
          path: forge-coverage
          if_no_artifact_found: warn
          search_artifacts: true
          branch: ${{ github.head_ref || github.ref_name }}
        continue-on-error: true

      - name: Install lcov
        run: sudo apt-get update && sudo apt-get install -y lcov

      - name: Merge and generate coverage report
        run: |
          LLVM_BIN="$(rustc --print sysroot)/lib/rustlib/$(rustc -vV | grep host | cut -d' ' -f2)/bin"
          mkdir -p coverage-report

          # Collect profdata files
          PROFDATA_FILES=""
          if [[ -f cargo-coverage/cargo-test.profdata ]]; then
            PROFDATA_FILES="$PROFDATA_FILES cargo-coverage/cargo-test.profdata"
            echo "Found cargo test coverage"
          fi
          if [[ -f forge-coverage/coverage/forge-test.profdata ]]; then
            PROFDATA_FILES="$PROFDATA_FILES forge-coverage/coverage/forge-test.profdata"
            echo "Found forge test coverage"
          fi

          if [[ -z "$PROFDATA_FILES" ]]; then
            echo "No coverage data found"
            echo "No coverage data available" > coverage-report/summary.txt
            exit 0
          fi

          # Merge profdata
          "$LLVM_BIN/llvm-profdata" merge -sparse $PROFDATA_FILES -o coverage-report/merged.profdata

          # Build object flags
          OBJECT_FLAGS=""
          if [[ -f forge-coverage/tempo-foundry/target/release/forge ]]; then
            chmod +x forge-coverage/tempo-foundry/target/release/forge
            OBJECT_FLAGS="$OBJECT_FLAGS --object=forge-coverage/tempo-foundry/target/release/forge"
          fi
          if [[ -d cargo-coverage/precompiles-bin ]]; then
            for bin in cargo-coverage/precompiles-bin/*; do
              if [[ -f "$bin" ]]; then
                chmod +x "$bin"
                OBJECT_FLAGS="$OBJECT_FLAGS --object=$bin"
              fi
            done
          fi

          if [[ -z "$OBJECT_FLAGS" ]]; then
            echo "No binaries found"
            exit 0
          fi

          # Generate report
          "$LLVM_BIN/llvm-cov" report \
            --instr-profile=coverage-report/merged.profdata \
            $OBJECT_FLAGS \
            --ignore-filename-regex='/rustc/' \
            --ignore-filename-regex='\.cargo/' \
            --ignore-filename-regex='\.rustup/' \
            --ignore-filename-regex='tempo-foundry/' \
            --ignore-filename-regex='library/' \
            2>/dev/null > coverage-report/full-summary.txt || true

          # Filter to precompiles (crates/precompiles and crates/contracts/src/precompiles)
          grep -E 'Filename|precompiles/src/.*\.rs|contracts/src/precompiles/.*\.rs|TOTAL' coverage-report/full-summary.txt \
            > coverage-report/summary.txt || true

          echo "=== Precompiles Coverage ==="
          cat coverage-report/summary.txt

          # Generate lcov
          "$LLVM_BIN/llvm-cov" export \
            --format=lcov \
            --instr-profile=coverage-report/merged.profdata \
            $OBJECT_FLAGS \
            --ignore-filename-regex='/rustc/' \
            --ignore-filename-regex='\.cargo/' \
            --ignore-filename-regex='\.rustup/' \
            --ignore-filename-regex='tempo-foundry/' \
            --ignore-filename-regex='library/' \
            > coverage-report/full.lcov 2>/dev/null || true

          if [[ -s coverage-report/full.lcov ]]; then
            awk '
              /^SF:.*(precompiles\/src\/|contracts\/src\/precompiles\/).*\.rs$/ { found=1 }
              found { print }
              /^end_of_record$/ { found=0 }
            ' coverage-report/full.lcov > coverage-report/precompiles.lcov

            if [[ -s coverage-report/precompiles.lcov ]]; then
              genhtml coverage-report/precompiles.lcov \
                --output-directory coverage-report/html \
                --title "Tempo Precompiles Coverage" \
                --legend 2>/dev/null || true
            fi
          fi

      - name: Upload merged coverage
        uses: actions/upload-artifact@v4
        with:
          name: precompiles-coverage-merged
          path: coverage-report/
          retention-days: 10

      - name: Comment coverage on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            let body = '## ðŸ“Š Tempo Precompiles Coverage\n\n';
            
            try {
              const report = fs.readFileSync('coverage-report/summary.txt', 'utf-8');
              
              if (report.trim() && !report.includes('No coverage')) {
                const lines = report.trim().split('\n');
                const fileLines = lines.filter(l => l.includes('.rs') && !l.startsWith('Filename'));
                const totalLine = lines.find(l => l.startsWith('TOTAL'));
                
                if (fileLines.length > 0) {
                  body += '| File | Lines | Line Coverage |\n';
                  body += '|------|-------|---------------|\n';
                  
                  for (const line of fileLines) {
                    const parts = line.trim().split(/\s+/);
                    if (parts.length >= 7) {
                      const fullPath = parts[0];
                      let shortPath = fullPath.includes('precompiles/') 
                        ? fullPath.substring(fullPath.indexOf('precompiles/'))
                        : fullPath.split('/').slice(-3).join('/');
                      const linesCoverage = parts[parts.length - 4];
                      const linesMissed = parseInt(parts[parts.length - 5]) || 0;
                      const linesTotal = parseInt(parts[parts.length - 6]) || 0;
                      const linesCovered = linesTotal - linesMissed;
                      body += `| \`${shortPath}\` | ${linesCovered}/${linesTotal} | ${linesCoverage} |\n`;
                    }
                  }
                  
                  if (totalLine) {
                    const parts = totalLine.trim().split(/\s+/);
                    if (parts.length >= 7) {
                      const linesCoverage = parts[parts.length - 4];
                      const linesMissed = parseInt(parts[parts.length - 5]) || 0;
                      const linesTotal = parseInt(parts[parts.length - 6]) || 0;
                      const linesCovered = linesTotal - linesMissed;
                      body += `| **TOTAL** | **${linesCovered}/${linesTotal}** | **${linesCoverage}** |\n`;
                    }
                  }
                } else {
                  body += '```\n' + report + '\n```\n';
                }
              } else {
                body += 'No coverage data found for precompiles sources.\n';
              }
            } catch (e) {
              body += `Coverage report not available: ${e.message}\n`;
            }
            
            body += '\nðŸ“¦ [Download full HTML report](../actions/runs/${{ github.run_id }})\n';
            
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(c => 
              c.user.type === 'Bot' && c.body.includes('Tempo Precompiles Coverage')
            );
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body
              });
            }
