name: Precompiles Coverage

permissions: {}

on:
  workflow_call:
    inputs:
      commit_sha:
        description: 'Commit SHA to download artifacts for'
        required: true
        type: string
      pr_number:
        description: 'PR number for commenting'
        required: false
        type: number

jobs:
  wait-for-test:
    name: Wait for Test workflow
    runs-on: ubuntu-latest
    permissions:
      actions: read
    steps:
      - name: Wait for Test workflow to complete
        uses: actions/github-script@v7
        env:
          COMMIT_SHA: ${{ inputs.commit_sha }}
        with:
          script: |
            const commitSha = process.env.COMMIT_SHA;
            const maxWaitMinutes = 30;
            const pollIntervalSeconds = 30;
            const maxAttempts = (maxWaitMinutes * 60) / pollIntervalSeconds;
            
            console.log(`Waiting for Test workflow to complete for commit: ${commitSha}`);
            
            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
              const { data: runs } = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'test.yml',
                head_sha: commitSha,
                per_page: 1
              });
              
              if (runs.workflow_runs.length > 0) {
                const run = runs.workflow_runs[0];
                console.log(`Test workflow status: ${run.status}, conclusion: ${run.conclusion}`);
                
                if (run.status === 'completed') {
                  if (run.conclusion === 'success') {
                    console.log('Test workflow completed successfully');
                    return;
                  } else {
                    console.log(`Test workflow completed with conclusion: ${run.conclusion}`);
                    return;
                  }
                }
              } else {
                console.log('No Test workflow run found yet');
              }
              
              if (attempt < maxAttempts) {
                console.log(`Attempt ${attempt}/${maxAttempts}, waiting ${pollIntervalSeconds}s...`);
                await new Promise(r => setTimeout(r, pollIntervalSeconds * 1000));
              }
            }
            
            console.log('Timeout waiting for Test workflow, proceeding with forge coverage only');

  merge-coverage:
    name: Merge Precompiles Coverage
    runs-on: ubuntu-latest
    needs: [wait-for-test]
    permissions:
      contents: read
      actions: read
      pull-requests: write
    steps:
      - uses: actions/checkout@v6
        with:
          persist-credentials: false

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: llvm-tools-preview

      - name: Download cargo test coverage
        uses: dawidd6/action-download-artifact@bf251b5aa9c2f7eeb574a96ee720e24f801b7c11 # v6
        with:
          workflow: test.yml
          name: cargo-test-coverage
          path: cargo-coverage
          if_no_artifact_found: warn
          search_artifacts: true
          commit: ${{ inputs.commit_sha }}
        continue-on-error: true

      - name: Download forge test coverage
        uses: actions/download-artifact@v4
        with:
          name: forge-test-coverage
          path: forge-coverage
        continue-on-error: true

      - name: Install lcov
        run: sudo apt-get update && sudo apt-get install -y lcov

      - name: Merge and generate coverage report
        run: |
          LLVM_BIN="$(rustc --print sysroot)/lib/rustlib/$(rustc -vV | grep host | cut -d' ' -f2)/bin"
          mkdir -p coverage-report

          # Collect profdata files
          PROFDATA_FILES=""
          if [[ -f cargo-coverage/cargo-test.profdata ]]; then
            PROFDATA_FILES="$PROFDATA_FILES cargo-coverage/cargo-test.profdata"
            echo "Found cargo test coverage"
          fi
          if [[ -f forge-coverage/coverage/forge-test.profdata ]]; then
            PROFDATA_FILES="$PROFDATA_FILES forge-coverage/coverage/forge-test.profdata"
            echo "Found forge test coverage"
          fi

          if [[ -z "$PROFDATA_FILES" ]]; then
            echo "No coverage data found"
            echo "No coverage data available" > coverage-report/summary.txt
            exit 0
          fi

          # Merge profdata
          "$LLVM_BIN/llvm-profdata" merge -sparse $PROFDATA_FILES -o coverage-report/merged.profdata

          # Build object flags
          OBJECT_FLAGS=""
          if [[ -f forge-coverage/tempo-foundry/target/release/forge ]]; then
            chmod +x forge-coverage/tempo-foundry/target/release/forge
            OBJECT_FLAGS="$OBJECT_FLAGS --object=forge-coverage/tempo-foundry/target/release/forge"
          fi
          if [[ -d cargo-coverage/precompiles-bin ]]; then
            for bin in cargo-coverage/precompiles-bin/*; do
              if [[ -f "$bin" ]]; then
                chmod +x "$bin"
                OBJECT_FLAGS="$OBJECT_FLAGS --object=$bin"
              fi
            done
          fi

          if [[ -z "$OBJECT_FLAGS" ]]; then
            echo "No binaries found"
            exit 0
          fi

          # Generate report
          "$LLVM_BIN/llvm-cov" report \
            --instr-profile=coverage-report/merged.profdata \
            $OBJECT_FLAGS \
            --ignore-filename-regex='/rustc/' \
            --ignore-filename-regex='\.cargo/' \
            --ignore-filename-regex='\.rustup/' \
            --ignore-filename-regex='tempo-foundry/' \
            --ignore-filename-regex='library/' \
            2>/dev/null > coverage-report/full-summary.txt || true

          # Filter to precompiles crates (precompiles/ and contracts/)
          # Paths in llvm-cov output are like: precompiles/src/... and contracts/src/...
          grep -E '^Filename|^precompiles/|^contracts/|^TOTAL' coverage-report/full-summary.txt \
            > coverage-report/summary.txt || true

          echo "=== Precompiles Coverage ==="
          cat coverage-report/summary.txt
          
          echo ""
          echo "=== Debug: Line count in summary.txt ==="
          wc -l coverage-report/summary.txt || true

          # Generate lcov
          "$LLVM_BIN/llvm-cov" export \
            --format=lcov \
            --instr-profile=coverage-report/merged.profdata \
            $OBJECT_FLAGS \
            --ignore-filename-regex='/rustc/' \
            --ignore-filename-regex='\.cargo/' \
            --ignore-filename-regex='\.rustup/' \
            --ignore-filename-regex='tempo-foundry/' \
            --ignore-filename-regex='library/' \
            > coverage-report/full.lcov 2>/dev/null || true

          if [[ -s coverage-report/full.lcov ]]; then
            # Generate per-crate lcov files
            # Paths in lcov are absolute: SF:/home/runner/.../crates/precompiles/src/...
            mkdir -p coverage-report/precompiles
            mkdir -p coverage-report/contracts

            # Filter lcov for crates/precompiles/
            awk '
              /^SF:.*crates\/precompiles\/.*\.rs$/ { found=1 }
              found { print }
              /^end_of_record$/ { found=0 }
            ' coverage-report/full.lcov > coverage-report/precompiles/coverage.lcov

            # Filter lcov for crates/contracts/
            awk '
              /^SF:.*crates\/contracts\/.*\.rs$/ { found=1 }
              found { print }
              /^end_of_record$/ { found=0 }
            ' coverage-report/full.lcov > coverage-report/contracts/coverage.lcov

            echo "precompiles lcov lines: $(wc -l < coverage-report/precompiles/coverage.lcov)"
            echo "contracts lcov lines: $(wc -l < coverage-report/contracts/coverage.lcov)"

            # Generate HTML for precompiles
            if [[ -s coverage-report/precompiles/coverage.lcov ]]; then
              genhtml coverage-report/precompiles/coverage.lcov \
                --output-directory coverage-report/precompiles/html \
                --title "precompiles Coverage" \
                --legend 2>/dev/null || true
              echo "Generated HTML report for precompiles"
            fi

            # Generate HTML for contracts
            if [[ -s coverage-report/contracts/coverage.lcov ]]; then
              genhtml coverage-report/contracts/coverage.lcov \
                --output-directory coverage-report/contracts/html \
                --title "contracts Coverage" \
                --legend 2>/dev/null || true
              echo "Generated HTML report for contracts"
            fi

            # Also generate combined report for all precompiles-related code
            awk '
              /^SF:.*(crates\/precompiles\/|crates\/contracts\/).*\.rs$/ { found=1 }
              found { print }
              /^end_of_record$/ { found=0 }
            ' coverage-report/full.lcov > coverage-report/combined.lcov

            if [[ -s coverage-report/combined.lcov ]]; then
              genhtml coverage-report/combined.lcov \
                --output-directory coverage-report/html \
                --title "Tempo Precompiles Coverage (Combined)" \
                --legend 2>/dev/null || true
              echo "Generated combined HTML report"
            fi
          fi

      - name: Upload merged coverage
        uses: actions/upload-artifact@v4
        with:
          name: precompiles-coverage-merged
          path: coverage-report/
          retention-days: 10

      - name: Comment coverage on PR
        if: inputs.pr_number != 0
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const prNumber = ${{ inputs.pr_number || 0 }};

            if (!prNumber) {
              console.log('No PR number found, skipping comment');
              return;
            }

            let body = '## ðŸ“Š Tempo Precompiles Coverage\n\n';

            try {
              const report = fs.readFileSync('coverage-report/summary.txt', 'utf-8');

              if (report.trim() && !report.includes('No coverage')) {
                const lines = report.trim().split('\n');
                const fileLines = lines.filter(l => l.includes('.rs') && !l.startsWith('Filename'));
                const totalLine = lines.find(l => l.startsWith('TOTAL'));

                console.log(`Found ${fileLines.length} file lines in report`);
                if (fileLines.length > 0) {
                  console.log(`Sample lines from report:`);
                  fileLines.slice(0, 2).forEach(l => console.log(`  "${l}"`));
                }

                // Group files by crate - paths are like: precompiles/src/... and contracts/src/...
                const crates = {
                  'precompiles': { files: [], covered: 0, total: 0 },
                  'contracts': { files: [], covered: 0, total: 0 }
                };

                for (const line of fileLines) {
                  const parts = line.trim().split(/\s+/);
                  
                  // llvm-cov report format (13 columns with branches):
                  // Filename Regions MissedRegions RegionCover Functions MissedFunctions FuncCover Lines MissedLines LineCover Branches MissedBranches BranchCover
                  
                  if (parts.length >= 10) {
                    const fullPath = parts[0];
                    
                    // Lines data is at fixed positions: indices 7, 8, 9
                    const linesTotal = parseInt(parts[7]) || 0;
                    const linesMissed = parseInt(parts[8]) || 0;
                    const linesCoverage = parts[9];
                    const linesCovered = linesTotal - linesMissed;
                    
                    // Determine which crate this file belongs to
                    // Paths are like: precompiles/src/... or contracts/src/...
                    let crateName = null;
                    let shortPath = fullPath;
                    
                    if (fullPath.startsWith('precompiles/')) {
                      crateName = 'precompiles';
                      shortPath = fullPath.substring('precompiles/'.length);
                    } else if (fullPath.startsWith('contracts/')) {
                      crateName = 'contracts';
                      shortPath = fullPath.substring('contracts/'.length);
                    }
                    
                    if (crateName && crates[crateName]) {
                      crates[crateName].files.push({
                        path: shortPath,
                        covered: linesCovered,
                        total: linesTotal,
                        percentage: linesCoverage
                      });
                      crates[crateName].covered += linesCovered;
                      crates[crateName].total += linesTotal;
                    }
                  }
                }

                console.log(`precompiles files: ${crates['precompiles'].files.length}`);
                console.log(`contracts files: ${crates['contracts'].files.length}`);

                // Generate report per crate
                for (const [crateName, data] of Object.entries(crates)) {
                  if (data.files.length === 0) continue;
                  
                  const cratePercentage = data.total > 0 
                    ? ((data.covered / data.total) * 100).toFixed(2) + '%'
                    : '0.00%';
                  
                  body += `### ${crateName}\n\n`;
                  body += `**Coverage: ${data.covered}/${data.total} lines (${cratePercentage})**\n\n`;
                  body += '<details>\n<summary>File details</summary>\n\n';
                  body += '| File | Lines | Coverage |\n';
                  body += '|------|-------|----------|\n';
                  
                  for (const file of data.files) {
                    body += `| \`${file.path}\` | ${file.covered}/${file.total} | ${file.percentage} |\n`;
                  }
                  
                  body += '\n</details>\n\n';
                }

                // Add overall total (sum of precompiles + contracts only)
                const totalCovered = crates['precompiles'].covered + crates['contracts'].covered;
                const totalLines = crates['precompiles'].total + crates['contracts'].total;
                const totalPercentage = totalLines > 0 
                  ? ((totalCovered / totalLines) * 100).toFixed(2) + '%'
                  : '0.00%';
                
                if (totalLines > 0) {
                  body += `### Total: ${totalCovered}/${totalLines} lines (${totalPercentage})\n\n`;
                }
              } else {
                body += 'No coverage data found for precompiles sources.\n';
              }
            } catch (e) {
              body += `Coverage report not available: ${e.message}\n`;
            }

            body += 'ðŸ“¦ [Download full HTML report](../actions/runs/${{ github.run_id }})\n';

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes('Tempo Precompiles Coverage')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body
              });
            }
