name: Precompiles Coverage

on:
  workflow_call:
    inputs:
      commit_sha:
        description: 'Commit SHA to download artifacts for'
        required: true
        type: string
      pr_number:
        description: 'PR number for commenting'
        required: false
        type: number

permissions:
  pull-requests: write
  actions: read

jobs:
  wait-for-test:
    name: Wait for Test workflow
    runs-on: ubuntu-latest
    steps:
      - name: Wait for Test workflow to complete
        uses: actions/github-script@v7
        with:
          script: |
            const commitSha = '${{ inputs.commit_sha }}';
            const maxWaitMinutes = 30;
            const pollIntervalSeconds = 30;
            const maxAttempts = (maxWaitMinutes * 60) / pollIntervalSeconds;
            
            console.log(`Waiting for Test workflow to complete for commit: ${commitSha}`);
            
            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
              const { data: runs } = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'test.yml',
                head_sha: commitSha,
                per_page: 1
              });
              
              if (runs.workflow_runs.length > 0) {
                const run = runs.workflow_runs[0];
                console.log(`Test workflow status: ${run.status}, conclusion: ${run.conclusion}`);
                
                if (run.status === 'completed') {
                  if (run.conclusion === 'success') {
                    console.log('Test workflow completed successfully');
                    return;
                  } else {
                    console.log(`Test workflow completed with conclusion: ${run.conclusion}`);
                    return;
                  }
                }
              } else {
                console.log('No Test workflow run found yet');
              }
              
              if (attempt < maxAttempts) {
                console.log(`Attempt ${attempt}/${maxAttempts}, waiting ${pollIntervalSeconds}s...`);
                await new Promise(r => setTimeout(r, pollIntervalSeconds * 1000));
              }
            }
            
            console.log('Timeout waiting for Test workflow, proceeding with forge coverage only');

  merge-coverage:
    name: Merge Precompiles Coverage
    runs-on: ubuntu-latest
    needs: [wait-for-test]
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: llvm-tools-preview

      - name: Download cargo test coverage
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: test.yml
          name: cargo-test-coverage
          path: cargo-coverage
          if_no_artifact_found: warn
          search_artifacts: true
          commit: ${{ inputs.commit_sha }}
        continue-on-error: true

      - name: Download forge test coverage
        uses: actions/download-artifact@v4
        with:
          name: forge-test-coverage
          path: forge-coverage
        continue-on-error: true

      - name: Install lcov
        run: sudo apt-get update && sudo apt-get install -y lcov

      - name: Merge and generate coverage report
        run: |
          LLVM_BIN="$(rustc --print sysroot)/lib/rustlib/$(rustc -vV | grep host | cut -d' ' -f2)/bin"
          mkdir -p coverage-report

          # Collect profdata files
          PROFDATA_FILES=""
          if [[ -f cargo-coverage/cargo-test.profdata ]]; then
            PROFDATA_FILES="$PROFDATA_FILES cargo-coverage/cargo-test.profdata"
            echo "Found cargo test coverage"
          fi
          if [[ -f forge-coverage/coverage/forge-test.profdata ]]; then
            PROFDATA_FILES="$PROFDATA_FILES forge-coverage/coverage/forge-test.profdata"
            echo "Found forge test coverage"
          fi

          if [[ -z "$PROFDATA_FILES" ]]; then
            echo "No coverage data found"
            echo "No coverage data available" > coverage-report/summary.txt
            exit 0
          fi

          # Merge profdata
          "$LLVM_BIN/llvm-profdata" merge -sparse $PROFDATA_FILES -o coverage-report/merged.profdata

          # Build object flags
          OBJECT_FLAGS=""
          if [[ -f forge-coverage/tempo-foundry/target/release/forge ]]; then
            chmod +x forge-coverage/tempo-foundry/target/release/forge
            OBJECT_FLAGS="$OBJECT_FLAGS --object=forge-coverage/tempo-foundry/target/release/forge"
          fi
          if [[ -d cargo-coverage/precompiles-bin ]]; then
            for bin in cargo-coverage/precompiles-bin/*; do
              if [[ -f "$bin" ]]; then
                chmod +x "$bin"
                OBJECT_FLAGS="$OBJECT_FLAGS --object=$bin"
              fi
            done
          fi

          if [[ -z "$OBJECT_FLAGS" ]]; then
            echo "No binaries found"
            exit 0
          fi

          # Generate report
          "$LLVM_BIN/llvm-cov" report \
            --instr-profile=coverage-report/merged.profdata \
            $OBJECT_FLAGS \
            --ignore-filename-regex='/rustc/' \
            --ignore-filename-regex='\.cargo/' \
            --ignore-filename-regex='\.rustup/' \
            --ignore-filename-regex='tempo-foundry/' \
            --ignore-filename-regex='library/' \
            2>/dev/null > coverage-report/full-summary.txt || true

          # Filter to precompiles (crates/precompiles and crates/contracts/src/precompiles)
          grep -E 'Filename|precompiles/src/.*\.rs|contracts/src/precompiles/.*\.rs|TOTAL' coverage-report/full-summary.txt \
            > coverage-report/summary.txt || true

          echo "=== Precompiles Coverage ==="
          cat coverage-report/summary.txt

          # Generate lcov
          "$LLVM_BIN/llvm-cov" export \
            --format=lcov \
            --instr-profile=coverage-report/merged.profdata \
            $OBJECT_FLAGS \
            --ignore-filename-regex='/rustc/' \
            --ignore-filename-regex='\.cargo/' \
            --ignore-filename-regex='\.rustup/' \
            --ignore-filename-regex='tempo-foundry/' \
            --ignore-filename-regex='library/' \
            > coverage-report/full.lcov 2>/dev/null || true

          if [[ -s coverage-report/full.lcov ]]; then
            awk '
              /^SF:.*(precompiles\/src\/|contracts\/src\/precompiles\/).*\.rs$/ { found=1 }
              found { print }
              /^end_of_record$/ { found=0 }
            ' coverage-report/full.lcov > coverage-report/precompiles.lcov

            if [[ -s coverage-report/precompiles.lcov ]]; then
              genhtml coverage-report/precompiles.lcov \
                --output-directory coverage-report/html \
                --title "Tempo Precompiles Coverage" \
                --legend 2>/dev/null || true
            fi
          fi

      - name: Upload merged coverage
        uses: actions/upload-artifact@v4
        with:
          name: precompiles-coverage-merged
          path: coverage-report/
          retention-days: 10

      - name: Comment coverage on PR
        if: inputs.pr_number != 0
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const prNumber = ${{ inputs.pr_number || 0 }};

            if (!prNumber) {
              console.log('No PR number found, skipping comment');
              return;
            }

            let body = '## ðŸ“Š Tempo Precompiles Coverage\n\n';

            try {
              const report = fs.readFileSync('coverage-report/summary.txt', 'utf-8');

              if (report.trim() && !report.includes('No coverage')) {
                const lines = report.trim().split('\n');
                const fileLines = lines.filter(l => l.includes('.rs') && !l.startsWith('Filename'));
                const totalLine = lines.find(l => l.startsWith('TOTAL'));

                if (fileLines.length > 0) {
                  body += '| File | Lines | Line Coverage |\n';
                  body += '|------|-------|---------------|\n';

                  for (const line of fileLines) {
                    const parts = line.trim().split(/\s+/);
                    if (parts.length >= 7) {
                      const fullPath = parts[0];
                      let shortPath = fullPath.includes('precompiles/')
                        ? fullPath.substring(fullPath.indexOf('precompiles/'))
                        : fullPath.split('/').slice(-3).join('/');
                      const linesCoverage = parts[parts.length - 4];
                      const linesMissed = parseInt(parts[parts.length - 5]) || 0;
                      const linesTotal = parseInt(parts[parts.length - 6]) || 0;
                      const linesCovered = linesTotal - linesMissed;
                      body += `| \`${shortPath}\` | ${linesCovered}/${linesTotal} | ${linesCoverage} |\n`;
                    }
                  }

                  if (totalLine) {
                    const parts = totalLine.trim().split(/\s+/);
                    if (parts.length >= 7) {
                      const linesCoverage = parts[parts.length - 4];
                      const linesMissed = parseInt(parts[parts.length - 5]) || 0;
                      const linesTotal = parseInt(parts[parts.length - 6]) || 0;
                      const linesCovered = linesTotal - linesMissed;
                      body += `| **TOTAL** | **${linesCovered}/${linesTotal}** | **${linesCoverage}** |\n`;
                    }
                  }
                } else {
                  body += '```\n' + report + '\n```\n';
                }
              } else {
                body += 'No coverage data found for precompiles sources.\n';
              }
            } catch (e) {
              body += `Coverage report not available: ${e.message}\n`;
            }

            body += '\nðŸ“¦ [Download full HTML report](../actions/runs/${{ github.run_id }})\n';

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes('Tempo Precompiles Coverage')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body
              });
            }
